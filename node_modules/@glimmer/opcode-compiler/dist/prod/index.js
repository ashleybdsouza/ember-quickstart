import{extractHandle as e,assert as t,expect as o,unwrap as n,debugToString as l,isSmallInt as r,Stack as a,isPresentArray as i,encodeHandle as s,EMPTY_STRING_ARRAY as u,dict as p,assign as c,enumerate as m,encodeImmediate as d,EMPTY_ARRAY as h,reverse as f}from"@glimmer/util";import{debugSlice as b}from"@glimmer/debug";import{Op as y,MachineOp as S,TYPE_SIZE as v,isMachineOp as w,MACHINE_MASK as g,ARG_SHIFT as L,$v0 as k,$fp as A,$sp as C,InternalComponentCapabilities as P,$s0 as E,$s1 as F,ContentType as D}from"@glimmer/vm";import{InstructionEncoderImpl as B}from"@glimmer/encoder";import{SexpOpcodes as N}from"@glimmer/wire-format";import{hasCapability as G}from"@glimmer/manager";const H=!("undefined"==typeof window||!window.location||!/[&?]enable_local_should_log/u.test(window.location.search));let I;function T(e){return t=>{if(!function(e){return Array.isArray(e)&&2===e.length}(t))return!1;let o=t[0];return o===N.GetStrictKeyword||o===N.GetLexicalSymbol||o===e}}H&&(I=(t,o)=>{let n=e(o),{heap:l}=t.program,r=l.getaddr(n),a=r+l.sizeof(n);b(t,r,a)});const x=T(N.GetFreeAsComponentHead),M=T(N.GetFreeAsModifierHead),O=T(N.GetFreeAsHelperHead),V=T(N.GetFreeAsComponentOrHelperHead);function R(e){if(!e.upvars)throw new Error("Attempted to resolve a component, helper, or modifier, but no free vars were found");if(!e.owner)throw new Error("Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from");return e}function U(e,o,l,r,a){let{upvars:i}=R(l),s=n(i[e[1]]),u=o.lookupBuiltInHelper(s);if(null===u)throw t(!l.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve a ${a} in a strict mode template, but that value was not in scope: ${l.upvars[e[1]]??"{unknown variable}"}`);return r.helper(u,s)}const $={Modifier:1003,Component:1004,Helper:1005,ComponentOrHelper:1007,OptionalComponentOrHelper:1008,Local:1010,TemplateLocal:1011},J={Label:1e3,StartLabels:1001,StopLabels:1002,Start:1e3,End:1002},Y={Label:1,IsStrictMode:2,DebugSymbols:3,Block:4,StdLib:5,NonSmallInt:6,SymbolTable:7,Layout:8};function K(e){return{type:Y.Label,value:e}}function _(){return{type:Y.IsStrictMode,value:void 0}}function j(e){return{type:Y.StdLib,value:e}}function z(e){return{type:Y.SymbolTable,value:e}}function W(e){return{type:Y.Layout,value:e}}class q{labels=p();targets=[];label(e,t){this.labels[e]=t}target(e,t){this.targets.push({at:e,target:t})}patch(e){let{targets:o,labels:n}=this;for(const{at:l,target:r}of o){let o=n[r]-l;t(-1===e.getbyaddr(l),"Expected heap to contain a placeholder, but it did not"),e.setbyaddr(l,o)}}}function Q(e,r,a,i,s){if(function(e){return e<J.Start}(s[0])){let[t,...o]=s;e.push(r,t,...o)}else switch(s[0]){case J.Label:return e.label(s[1]);case J.StartLabels:return e.startLabels();case J.StopLabels:return e.stopLabels();case $.Component:return function(e,l,r,[,a,i]){t(x(a),"Attempted to resolve a component with incorrect opcode");let s=a[0];if(a[0]===N.GetStrictKeyword)throw t(!r.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${r.upvars[a[1]]??"{unknown variable}"}`);if(s===N.GetLexicalSymbol){let{scopeValues:e,owner:t}=r,n=o(e,"BUG: scopeValues must exist if template symbol is used")[a[1]];i(l.component(n,o(t,"BUG: expected owner when resolving component definition")))}else{let{upvars:o,owner:s}=R(r),u=n(o[a[1]]),p=e.lookupComponent(u,s);if("object"!=typeof p||null===p)throw t(!r.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve \`${u}\`, which was expected to be a component, but nothing was found.`);i(l.resolvedComponent(p,u))}}(a,r,i,s);case $.Modifier:return function(e,l,r,[,a,i]){t(M(a),"Attempted to resolve a modifier with incorrect opcode");let s=a[0];if(s===N.GetLexicalSymbol){let{scopeValues:e}=r,t=o(e,"BUG: scopeValues must exist if template symbol is used")[a[1]];i(l.modifier(t))}else if(s===N.GetStrictKeyword){let{upvars:o}=R(r),s=n(o[a[1]]),u=e.lookupBuiltInModifier(s);if(null===u)throw t(!r.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${s}`);i(l.modifier(u,s))}else{let{upvars:o,owner:s}=R(r),u=n(o[a[1]]),p=e.lookupModifier(u,s);if(null===p)throw t(!r.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve \`${u}\`, which was expected to be a modifier, but nothing was found.`);i(l.modifier(p,u))}}(a,r,i,s);case $.Helper:return function(e,l,r,[,a,i]){t(O(a),"Attempted to resolve a helper with incorrect opcode");let s=a[0];if(s===N.GetLexicalSymbol){let{scopeValues:e}=r,t=o(e,"BUG: scopeValues must exist if template symbol is used")[a[1]];i(l.helper(t))}else if(s===N.GetStrictKeyword)i(U(a,e,r,l,"helper"));else{let{upvars:o,owner:s}=R(r),u=n(o[a[1]]),p=e.lookupHelper(u,s);if(null===p)throw t(!r.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve \`${u}\`, which was expected to be a helper, but nothing was found.`);i(l.helper(p,u))}}(a,r,i,s);case $.ComponentOrHelper:return function(e,r,a,[,i,{ifComponent:s,ifHelper:u}]){t(V(i),"Attempted to resolve a component or helper with incorrect opcode");let p=i[0];if(p===N.GetLexicalSymbol){let{scopeValues:e,owner:n}=a,p=o(e,"BUG: scopeValues must exist if template symbol is used")[i[1]],c=r.component(p,o(n,"BUG: expected owner when resolving component definition"),!0);if(null!==c)return void s(c);let m=r.helper(p,null,!0);if(null===m)throw t(!a.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${l(p)}`);u(o(m,"BUG: helper must exist"))}else if(p===N.GetStrictKeyword)u(U(i,e,a,r,"component or helper"));else{let{upvars:o,owner:l}=R(a),p=n(o[i[1]]),c=e.lookupComponent(p,l);if(null!==c)s(r.resolvedComponent(c,p));else{let o=e.lookupHelper(p,l);if(null===o)throw t(!a.isStrictMode,"Strict mode errors should already be handled at compile time"),new Error(`Attempted to resolve \`${p}\`, which was expected to be a component or helper, but nothing was found.`);u(r.helper(o,p))}}}(a,r,i,s);case $.OptionalComponentOrHelper:return function(e,l,r,[,a,{ifComponent:i,ifHelper:s,ifValue:u}]){t(V(a),"Attempted to resolve an optional component or helper with incorrect opcode");let p=a[0];if(p===N.GetLexicalSymbol){let{scopeValues:e,owner:t}=r,n=o(e,"BUG: scopeValues must exist if template symbol is used")[a[1]];if("function"!=typeof n&&("object"!=typeof n||null===n))return void u(l.value(n));let p=l.component(n,o(t,"BUG: expected owner when resolving component definition"),!0);if(null!==p)return void i(p);let c=l.helper(n,null,!0);if(null!==c)return void s(c);u(l.value(n))}else if(p===N.GetStrictKeyword)s(U(a,e,r,l,"value"));else{let{upvars:t,owner:o}=R(r),u=n(t[a[1]]),p=e.lookupComponent(u,o);if(null!==p)return void i(l.resolvedComponent(p,u));let c=e.lookupHelper(u,o);null!==c&&s(l.helper(c,u))}}(a,r,i,s);case $.Local:{let e=s[1],t=o(i.upvars,"BUG: attempted to resolve value but no upvars found")[e];(0,s[2])(t,i.moduleName);break}case $.TemplateLocal:{let[,e,t]=s,n=o(i.scopeValues,"BUG: Attempted to get a template local, but template does not have any")[e];t(r.value(n));break}default:throw new Error(`Unexpected high level opcode ${s[0]}`)}}class X{labelsStack=new a;encoder=new B([]);errors=[];handle;constructor(e,t,o){this.heap=e,this.meta=t,this.stdlib=o,this.handle=e.malloc()}error(e){this.encoder.encode(y.Primitive,0),this.errors.push(e)}commit(e){let t=this.handle;return this.heap.pushMachine(S.Return),this.heap.finishMalloc(t,e),i(this.errors)?{errors:this.errors,handle:t}:t}push(e,t,...o){let{heap:n}=this;if(t>v)throw new Error(`Opcode type over 8-bits. Got ${t}.`);let l=t|(w(t)?g:0)|o.length<<L;n.pushRaw(l);for(let t=0;t<o.length;t++){let l=o[t];n.pushRaw(this.operand(e,l))}}operand(e,t){if("number"==typeof t)return t;if("object"==typeof t&&null!==t){if(Array.isArray(t))return s(e.array(t));switch(t.type){case Y.Label:return this.currentLabels.target(this.heap.offset,t.value),-1;case Y.IsStrictMode:return s(e.value(this.meta.isStrictMode));case Y.DebugSymbols:return s(e.array(this.meta.evalSymbols||u));case Y.Block:return s(e.value((n=t.value,l=this.meta,new Je(n[0],l,{parameters:n[1]||h}))));case Y.StdLib:return o(this.stdlib,"attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?")[t.value];case Y.NonSmallInt:case Y.SymbolTable:case Y.Layout:return e.value(t.value)}}var n,l;return s(e.value(t))}get currentLabels(){return o(this.labelsStack.current,"bug: not in a label stack")}label(e){this.currentLabels.label(e,this.heap.offset+1)}startLabels(){this.labelsStack.push(new q)}stopLabels(){o(this.labelsStack.pop(),"unbalanced push and pop labels").patch(this.heap)}}class Z{constructor(e,t,o,n,l){this.main=e,this.trustingGuardedAppend=t,this.cautiousGuardedAppend=o,this.trustingNonDynamicAppend=n,this.cautiousNonDynamicAppend=l}get"trusting-append"(){return this.trustingGuardedAppend}get"cautious-append"(){return this.cautiousGuardedAppend}get"trusting-non-dynamic-append"(){return this.trustingNonDynamicAppend}get"cautious-non-dynamic-append"(){return this.cautiousNonDynamicAppend}getAppend(e){return e?this.trustingGuardedAppend:this.cautiousGuardedAppend}}class ee{names;constructor(e){this.blocks=e,this.names=e?Object.keys(e):[]}get(e){return this.blocks&&this.blocks[e]||null}has(e){let{blocks:t}=this;return null!==t&&e in t}with(e,t){let{blocks:o}=this;return new ee(o?c({},o,{[e]:t}):{[e]:t})}get hasAny(){return null!==this.blocks}}const te=new ee(null);function oe(e){if(null===e)return te;let t=p(),[o,l]=e;for(const[e,r]of m(o))t[r]=n(l[e]);return new ee(t)}function ne(e,t){le(e,t),e(y.PrimitiveReference)}function le(e,o){let n=o;var l;"number"==typeof n&&(n=r(n)?d(n):(t(!r(l=n),"Attempted to make a operand for an int that was not a small int, you should encode this as an immediate"),{type:Y.NonSmallInt,value:l})),e(y.Primitive,n)}function re(e,t,o,n){e(S.PushFrame),me(e,o,n,!1),e(y.Helper,t),e(S.PopFrame),e(y.Fetch,k)}function ae(e,t,o,n){e(S.PushFrame),me(e,t,o,!1),e(y.Dup,A,1),e(y.DynamicHelper),n?(e(y.Fetch,k),n(),e(S.PopFrame),e(y.Pop,1)):(e(S.PopFrame),e(y.Pop,1),e(y.Fetch,k))}function ie(e,t,o,n,l){e(S.PushFrame),me(e,n,l,!1),e(y.CaptureArgs),ce(e,o),e(y.Curry,t,_()),e(S.PopFrame),e(y.Fetch,k)}class se{names={};funcs=[];add(e,t){this.names[e]=this.funcs.push(t)-1}compile(e,o){let l=o[0],r=n(this.names[l]),a=this.funcs[r];t(!!a,`expected an implementation for ${o[0]}`),a(e,o)}}const ue=new se;function pe(e,t){if(void 0!==t&&0!==t.length)for(let o=0;o<t.length;o++)e(y.GetProperty,t[o])}function ce(e,t){Array.isArray(t)?ue.compile(e,t):(le(e,t),e(y.PrimitiveReference))}function me(e,t,o,n){if(null===t&&null===o)return void e(y.PushEmptyArgs);let l=de(e,t)<<4;n&&(l|=8);let r=u;if(o){r=o[0];let t=o[1];for(let o=0;o<t.length;o++)ce(e,t[o])}e(y.PushArgs,r,u,l)}function de(e,t){if(null===t)return 0;for(let o=0;o<t.length;o++)ce(e,t[o]);return t.length}function he(e){let[,t,,o]=e.block;return{evalSymbols:fe(e),upvars:o,scopeValues:e.scope?.()??null,isStrictMode:e.isStrictMode,moduleName:e.moduleName,owner:e.owner,size:t.length}}function fe(e){let{block:t}=e,[,o,n]=t;return n?o:null}function be(e,t,o){me(e,o,null,!0),e(y.GetBlock,t),e(y.SpreadBlock),e(y.CompileBlock),e(y.InvokeYield),e(y.PopScope),e(S.PopFrame)}function ye(e,t){!function(e,t){null!==t?e(y.PushSymbolTable,z({parameters:t})):le(e,null)}(e,t&&t[1]),e(y.PushBlockScope),we(e,t)}function Se(e,t){e(S.PushFrame),we(e,t),e(y.CompileBlock),e(S.InvokeVirtual),e(S.PopFrame)}function ve(e,t,o){let n=t[1],l=n.length,r=Math.min(o,l);if(0!==r){if(e(S.PushFrame),r){e(y.ChildScope);for(let t=0;t<r;t++)e(y.Dup,A,o-t),e(y.SetVariable,n[t])}we(e,t),e(y.CompileBlock),e(S.InvokeVirtual),r&&e(y.PopScope),e(S.PopFrame)}else Se(e,t)}function we(e,t){var o;null===t?le(e,null):e(y.Constant,(o=t,{type:Y.Block,value:o}))}function ge(e,t,o){let l=[],r=0;o((function(e,t){l.push({match:e,callback:t,label:"CLAUSE"+r++})})),e(y.Enter,1),t(),e(J.StartLabels);for(let t of l.slice(0,-1))e(y.JumpEq,K(t.label),t.match);for(let t=l.length-1;t>=0;t--){let o=n(l[t]);e(J.Label,o.label),e(y.Pop,1),o.callback(),0!==t&&e(S.Jump,K("END"))}e(J.Label,"END"),e(J.StopLabels),e(y.Exit)}function Le(e,t,o){e(J.StartLabels),e(S.PushFrame),e(S.ReturnTo,K("ENDINITIAL"));let n=t();e(y.Enter,n),o(),e(J.Label,"FINALLY"),e(y.Exit),e(S.Return),e(J.Label,"ENDINITIAL"),e(S.PopFrame),e(J.StopLabels)}function ke(e,t,o,n){return Le(e,t,(()=>{e(y.JumpUnless,K("ELSE")),o(),e(S.Jump,K("FINALLY")),e(J.Label,"ELSE"),void 0!==n&&n()}))}ue.add(N.Concat,((e,[,t])=>{for(let o of t)ce(e,o);e(y.Concat,t.length)})),ue.add(N.Call,((e,[,t,o,n])=>{O(t)?e($.Helper,t,(t=>{re(e,t,o,n)})):(ce(e,t),ae(e,o,n))})),ue.add(N.Curry,((e,[,t,o,n,l])=>{ie(e,o,t,n,l)})),ue.add(N.GetSymbol,((e,[,t,o])=>{e(y.GetVariable,t),pe(e,o)})),ue.add(N.GetLexicalSymbol,((e,[,t,o])=>{e($.TemplateLocal,t,(t=>{e(y.ConstantReference,t),pe(e,o)}))})),ue.add(N.GetStrictKeyword,((e,t)=>{e($.Local,t[1],(o=>{e($.Helper,t,(t=>{re(e,t,null,null)}))}))})),ue.add(N.GetFreeAsHelperHead,((e,t)=>{e($.Local,t[1],(o=>{e($.Helper,t,(t=>{re(e,t,null,null)}))}))})),ue.add(N.Undefined,(e=>ne(e,void 0))),ue.add(N.HasBlock,((e,[,t])=>{ce(e,t),e(y.HasBlock)})),ue.add(N.HasBlockParams,((e,[,t])=>{ce(e,t),e(y.SpreadBlock),e(y.CompileBlock),e(y.HasBlockParams)})),ue.add(N.IfInline,((e,[,t,o,n])=>{ce(e,n),ce(e,o),ce(e,t),e(y.IfInline)})),ue.add(N.Not,((e,[,t])=>{ce(e,t),e(y.Not)})),ue.add(N.GetDynamicVar,((e,[,t])=>{ce(e,t),e(y.GetDynamicVar)})),ue.add(N.Log,((e,[,t])=>{e(S.PushFrame),me(e,t,null,!1),e(y.Log),e(S.PopFrame),e(y.Fetch,k)}));const Ae="&attrs";function Ce(e,t,o,l,r,a){let{compilable:i,capabilities:s,handle:p}=t,c=o?[o,[]]:null,m=Array.isArray(a)||null===a?oe(a):a;i?(e(y.PushComponentDefinition,p),function(e,{capabilities:t,layout:o,elementBlock:l,positional:r,named:a,blocks:i}){let{symbolTable:s}=o,p=s.hasEval||G(t,P.prepareArgs);if(p)return void Ee(e,{capabilities:t,elementBlock:l,positional:r,named:a,atNames:!0,blocks:i,layout:o});e(y.Fetch,E),e(y.Dup,C,1),e(y.Load,E),e(S.PushFrame);let{symbols:c}=s,m=[],d=[],h=[],b=i.names;if(null!==l){let t=c.indexOf(Ae);-1!==t&&(ye(e,l),m.push(t))}for(const t of b){let o=c.indexOf(`&${t}`);-1!==o&&(ye(e,i.get(t)),m.push(o))}if(G(t,P.createArgs)){let t=de(e,r)<<4;t|=8;let o=u;if(null!==a){o=a[0];let t=a[1];for(let l=0;l<t.length;l++){let r=c.indexOf(n(o[l]));ce(e,t[l]),d.push(r)}}e(y.PushArgs,o,u,t),d.push(-1)}else if(null!==a){let t=a[0],o=a[1];for(let l=0;l<o.length;l++){let r=n(t[l]),a=c.indexOf(r);-1!==a&&(ce(e,o[l]),d.push(a),h.push(r))}}e(y.BeginComponentTransaction,E),G(t,P.dynamicScope)&&e(y.PushDynamicScope);G(t,P.createInstance)&&e(y.CreateComponent,0|i.has("default"),E);e(y.RegisterComponentDestructor,E),G(t,P.createArgs)?e(y.GetComponentSelf,E):e(y.GetComponentSelf,E,h);e(y.RootScope,c.length+1,Object.keys(i).length>0?1:0),e(y.SetVariable,0);for(const t of f(d))-1===t?e(y.Pop,1):e(y.SetVariable,t+1);null!==r&&e(y.Pop,r.length);for(const t of f(m))e(y.SetBlock,t+1);e(y.Constant,W(o)),e(y.CompileBlock),e(S.InvokeVirtual),e(y.DidRenderLayout,E),e(S.PopFrame),e(y.PopScope),G(t,P.dynamicScope)&&e(y.PopDynamicScope);e(y.CommitComponentTransaction),e(y.Load,E)}(e,{capabilities:s,layout:i,elementBlock:c,positional:l,named:r,blocks:m})):(e(y.PushComponentDefinition,p),Ee(e,{capabilities:s,elementBlock:c,positional:l,named:r,atNames:!0,blocks:m}))}function Pe(e,t,o,n,l,r,a,i){let s=o?[o,[]]:null,u=Array.isArray(r)||null===r?oe(r):r;Le(e,(()=>(ce(e,t),e(y.Dup,C,0),2)),(()=>{e(y.JumpUnless,K("ELSE")),i?e(y.ResolveCurriedComponent):e(y.ResolveDynamicComponent,_()),e(y.PushDynamicComponentInstance),Ee(e,{capabilities:!0,elementBlock:s,positional:n,named:l,atNames:a,blocks:u}),e(J.Label,"ELSE")}))}function Ee(e,{capabilities:t,elementBlock:o,positional:n,named:l,atNames:r,blocks:a,layout:i}){let s=!!a,u=!0===t||G(t,P.prepareArgs)||!(!l||0===l[0].length),p=a.with("attrs",o);e(y.Fetch,E),e(y.Dup,C,1),e(y.Load,E),e(S.PushFrame),function(e,t,o,n,l){let r=n.names;for(const t of r)ye(e,n.get(t));let a=de(e,t)<<4;l&&(a|=8),n&&(a|=7);let i=h;if(o){i=o[0];let t=o[1];for(let o=0;o<t.length;o++)ce(e,t[o])}e(y.PushArgs,i,r,a)}(e,n,l,p,r),e(y.PrepareArgs,E),De(e,p.has("default"),s,u,(()=>{i?(e(y.PushSymbolTable,z(i.symbolTable)),e(y.Constant,W(i)),e(y.CompileBlock)):e(y.GetComponentLayout,E),e(y.PopulateLayout,E)})),e(y.Load,E)}function Fe(e,t,o){e(J.StartLabels),function(e,t,o){e(y.Fetch,t),o(),e(y.Load,t)}(e,F,(()=>{e(y.GetComponentTagName,E),e(y.PrimitiveReference),e(y.Dup,C,0)})),e(y.JumpUnless,K("BODY")),e(y.Fetch,F),e(y.PutComponentOperations),e(y.OpenDynamicElement),e(y.DidCreateElement,E),be(e,o,null),e(y.FlushElement),e(J.Label,"BODY"),Se(e,[t.block[0],[]]),e(y.Fetch,F),e(y.JumpUnless,K("END")),e(y.CloseElement),e(J.Label,"END"),e(y.Load,F),e(J.StopLabels)}function De(e,t,o,n,l=null){e(y.BeginComponentTransaction,E),e(y.PushDynamicScope),e(y.CreateComponent,0|t,E),l&&l(),e(y.RegisterComponentDestructor,E),e(y.GetComponentSelf,E),e(y.VirtualRootScope,E),e(y.SetVariable,0),e(y.SetupForEval,E),n&&e(y.SetNamedVariables,E),o&&e(y.SetBlocks,E),e(y.Pop,1),e(y.InvokeComponentLayout,E),e(y.DidRenderLayout,E),e(S.PopFrame),e(y.PopScope),e(y.PopDynamicScope),e(y.CommitComponentTransaction)}function Be(e,t,o){ge(e,(()=>e(y.ContentType)),(n=>{n(D.String,(()=>{t?(e(y.AssertSame),e(y.AppendHTML)):e(y.AppendText)})),"number"==typeof o?(n(D.Component,(()=>{e(y.ResolveCurriedComponent),e(y.PushDynamicComponentInstance),function(e){e(y.Fetch,E),e(y.Dup,C,1),e(y.Load,E),e(S.PushFrame),e(y.PushEmptyArgs),e(y.PrepareArgs,E),De(e,!1,!1,!0,(()=>{e(y.GetComponentLayout,E),e(y.PopulateLayout,E)})),e(y.Load,E)}(e)})),n(D.Helper,(()=>{ae(e,null,null,(()=>{e(S.InvokeStatic,o)}))}))):(n(D.Component,(()=>{e(y.AppendText)})),n(D.Helper,(()=>{e(y.AppendText)}))),n(D.SafeString,(()=>{e(y.AssertSame),e(y.AppendSafeHTML)})),n(D.Fragment,(()=>{e(y.AssertSame),e(y.AppendDocumentFragment)})),n(D.Node,(()=>{e(y.AssertSame),e(y.AppendNode)}))}))}function Ne(e){let t=He(e,(e=>function(e){e(y.Main,E),De(e,!1,!1,!0)}(e))),o=He(e,(e=>Be(e,!0,null))),n=He(e,(e=>Be(e,!1,null))),l=He(e,(e=>Be(e,!0,o))),r=He(e,(e=>Be(e,!1,n)));return new Z(t,l,r,o,n)}const Ge={evalSymbols:null,upvars:null,moduleName:"stdlib",scopeValues:null,isStrictMode:!0,owner:null,size:0};function He(e,t){let{constants:o,heap:n,resolver:l}=e,r=new X(n,Ge);t((function(...e){Q(r,o,l,Ge,e)}));let a=r.commit(0);if("number"!=typeof a)throw new Error("Unexpected errors compiling std");return a}class Ie{constants;heap;stdlib;constructor({constants:e,heap:t},o,n){this.resolver=o,this.createOp=n,this.constants=e,this.heap=t,this.stdlib=Ne(this)}}function Te(e,t,o){return new Ie(e,t,o)}function xe(e,t){return{program:e,encoder:new X(e.heap,t,e.stdlib),meta:t}}const Me=new se,Oe=["class","id","value","name","type","style","href"],Ve=["div","span","p","a"];function Re(e){return"string"==typeof e?e:Ve[e]}function Ue(e){return"string"==typeof e?e:Oe[e]}function $e(e){if(null===e)return null;return[e[0].map((e=>`@${e}`)),e[1]]}Me.add(N.Comment,((e,t)=>e(y.Comment,t[1]))),Me.add(N.CloseElement,(e=>e(y.CloseElement))),Me.add(N.FlushElement,(e=>e(y.FlushElement))),Me.add(N.Modifier,((e,[,t,o,n])=>{M(t)?e($.Modifier,t,(t=>{e(S.PushFrame),me(e,o,n,!1),e(y.Modifier,t),e(S.PopFrame)})):(ce(e,t),e(S.PushFrame),me(e,o,n,!1),e(y.Dup,A,1),e(y.DynamicModifier),e(S.PopFrame))})),Me.add(N.StaticAttr,((e,[,t,o,n])=>{e(y.StaticAttr,Ue(t),o,n??null)})),Me.add(N.StaticComponentAttr,((e,[,t,o,n])=>{e(y.StaticComponentAttr,Ue(t),o,n??null)})),Me.add(N.DynamicAttr,((e,[,t,o,n])=>{ce(e,o),e(y.DynamicAttr,Ue(t),!1,n??null)})),Me.add(N.TrustingDynamicAttr,((e,[,t,o,n])=>{ce(e,o),e(y.DynamicAttr,Ue(t),!0,n??null)})),Me.add(N.ComponentAttr,((e,[,t,o,n])=>{ce(e,o),e(y.ComponentAttr,Ue(t),!1,n??null)})),Me.add(N.TrustingComponentAttr,((e,[,t,o,n])=>{ce(e,o),e(y.ComponentAttr,Ue(t),!0,n??null)})),Me.add(N.OpenElement,((e,[,t])=>{e(y.OpenElement,Re(t))})),Me.add(N.OpenElementWithSplat,((e,[,t])=>{e(y.PutComponentOperations),e(y.OpenElement,Re(t))})),Me.add(N.Component,((e,[,t,o,n,l])=>{x(t)?e($.Component,t,(t=>{Ce(e,t,o,null,n,l)})):Pe(e,t,o,null,n,l,!0,!0)})),Me.add(N.Yield,((e,[,t,o])=>be(e,t,o))),Me.add(N.AttrSplat,((e,[,t])=>be(e,t,null))),Me.add(N.Debugger,((e,[,t])=>e(y.Debugger,{type:Y.DebugSymbols,value:void 0},t))),Me.add(N.Append,((e,[,t])=>{if(Array.isArray(t))if(V(t))e($.OptionalComponentOrHelper,t,{ifComponent(t){Ce(e,t,null,null,null,null)},ifHelper(t){e(S.PushFrame),re(e,t,null,null),e(S.InvokeStatic,j("cautious-non-dynamic-append")),e(S.PopFrame)},ifValue(t){e(S.PushFrame),e(y.ConstantReference,t),e(S.InvokeStatic,j("cautious-non-dynamic-append")),e(S.PopFrame)}});else if(t[0]===N.Call){let[,o,n,l]=t;V(o)?e($.ComponentOrHelper,o,{ifComponent(t){Ce(e,t,null,n,$e(l),null)},ifHelper(t){e(S.PushFrame),re(e,t,n,l),e(S.InvokeStatic,j("cautious-non-dynamic-append")),e(S.PopFrame)}}):ge(e,(()=>{ce(e,o),e(y.DynamicContentType)}),(t=>{t(D.Component,(()=>{e(y.ResolveCurriedComponent),e(y.PushDynamicComponentInstance),Ee(e,{capabilities:!0,elementBlock:null,positional:n,named:l,atNames:!1,blocks:oe(null)})})),t(D.Helper,(()=>{ae(e,n,l,(()=>{e(S.InvokeStatic,j("cautious-non-dynamic-append"))}))}))}))}else e(S.PushFrame),ce(e,t),e(S.InvokeStatic,j("cautious-append")),e(S.PopFrame);else e(y.Text,null==t?"":String(t))})),Me.add(N.TrustingAppend,((e,[,t])=>{Array.isArray(t)?(e(S.PushFrame),ce(e,t),e(S.InvokeStatic,j("trusting-append")),e(S.PopFrame)):e(y.Text,null==t?"":String(t))})),Me.add(N.Block,((e,[,t,o,n,l])=>{x(t)?e($.Component,t,(t=>{Ce(e,t,null,o,$e(n),l)})):Pe(e,t,null,o,n,l,!1,!1)})),Me.add(N.InElement,((e,[,t,o,n,l])=>{ke(e,(()=>(ce(e,o),void 0===l?ne(e,void 0):ce(e,l),ce(e,n),e(y.Dup,C,0),4)),(()=>{e(y.PushRemoteElement),Se(e,t),e(y.PopRemoteElement)}))})),Me.add(N.If,((e,[,t,o,n])=>ke(e,(()=>(ce(e,t),e(y.ToBoolean),1)),(()=>{Se(e,o)}),n?()=>{Se(e,n)}:void 0))),Me.add(N.Each,((e,[,t,o,n,l])=>Le(e,(()=>(o?ce(e,o):ne(e,null),ce(e,t),2)),(()=>{e(y.EnterList,K("BODY"),K("ELSE")),e(S.PushFrame),e(y.Dup,A,1),e(S.ReturnTo,K("ITER")),e(J.Label,"ITER"),e(y.Iterate,K("BREAK")),e(J.Label,"BODY"),ve(e,n,2),e(y.Pop,2),e(S.Jump,K("FINALLY")),e(J.Label,"BREAK"),e(S.PopFrame),e(y.ExitList),e(S.Jump,K("FINALLY")),e(J.Label,"ELSE"),l&&Se(e,l)})))),Me.add(N.Let,((e,[,t,o])=>{ve(e,o,de(e,t))})),Me.add(N.WithDynamicVars,((e,[,t,o])=>{if(t){let[n,l]=t;de(e,l),function(e,t,o){e(y.PushDynamicScope),e(y.BindDynamicScope,t),o(),e(y.PopDynamicScope)}(e,n,(()=>{Se(e,o)}))}else Se(e,o)})),Me.add(N.InvokeComponent,((e,[,t,o,n,l])=>{x(t)?e($.Component,t,(t=>{Ce(e,t,null,o,$e(n),l)})):Pe(e,t,null,o,n,l,!1,!1)}));class Je{compiled=null;constructor(e,t,o,n="plain block"){this.statements=e,this.meta=t,this.symbolTable=o,this.moduleName=n}compile(e){return function(e,t){if(null!==e.compiled)return e.compiled;e.compiled=-1;let{statements:o,meta:n}=e,l=Ke(o,n,t);return e.compiled=l,l}(this,e)}}function Ye(e,t){let[o,n,l]=e.block;return new Je(o,he(e),{symbols:n,hasEval:l},t)}function Ke(e,t,o){let n=Me,l=xe(o,t),{encoder:r,program:{constants:a,resolver:i}}=l;function s(...e){Q(r,a,i,t,e)}for(const t of e)n.compile(s,t);let u=l.encoder.commit(t.size);return H&&I(l,u),u}const _e={dynamicLayout:!0,dynamicTag:!0,prepareArgs:!0,createArgs:!0,attributeHook:!1,elementHook:!1,dynamicScope:!0,createCaller:!1,updateHook:!0,createInstance:!0,wrapped:!1,willDestroy:!1,hasSubOwner:!1},je={dynamicLayout:!1,dynamicTag:!1,prepareArgs:!1,createArgs:!1,attributeHook:!1,elementHook:!1,dynamicScope:!1,createCaller:!1,updateHook:!1,createInstance:!1,wrapped:!1,willDestroy:!1,hasSubOwner:!1};class ze{symbolTable;compiled=null;attrsBlockNumber;constructor(e,t){this.layout=e,this.moduleName=t;let{block:o}=e,[,n,l]=o;n=n.slice();let r=n.indexOf(Ae);this.attrsBlockNumber=-1===r?n.push(Ae):r+1,this.symbolTable={hasEval:l,symbols:n}}compile(e){if(null!==this.compiled)return this.compiled;let t=he(this.layout),o=xe(e,t),{encoder:n,program:{constants:l,resolver:r}}=o;Fe((function(...e){Q(n,l,r,t,e)}),this.layout,this.attrsBlockNumber);let a=o.encoder.commit(t.size);return"number"!=typeof a||(this.compiled=a,H&&I(o,a)),a}}let We=0,qe={cacheHit:0,cacheMiss:0};function Qe({id:e,moduleName:t,block:o,scope:n,isStrictMode:l}){let r,a=e||"client-"+We++,i=null,s=new WeakMap,u=e=>{if(void 0===r&&(r=JSON.parse(o)),void 0===e)return null===i?(qe.cacheMiss++,i=new Xe({id:a,block:r,moduleName:t,owner:null,scope:n,isStrictMode:l})):qe.cacheHit++,i;let u=s.get(e);return void 0===u?(qe.cacheMiss++,u=new Xe({id:a,block:r,moduleName:t,owner:e,scope:n,isStrictMode:l}),s.set(e,u)):qe.cacheHit++,u};return u.__id=a,u.__meta={moduleName:t},u}class Xe{result="ok";layout=null;wrappedLayout=null;constructor(e){this.parsedLayout=e}get moduleName(){return this.parsedLayout.moduleName}get id(){return this.parsedLayout.id}get referrer(){return{moduleName:this.parsedLayout.moduleName,owner:this.parsedLayout.owner}}asLayout(){return this.layout?this.layout:this.layout=Ye(c({},this.parsedLayout),this.moduleName)}asWrappedLayout(){return this.wrappedLayout?this.wrappedLayout:this.wrappedLayout=new ze(c({},this.parsedLayout),this.moduleName)}}export{Ie as CompileTimeCompilationContextImpl,_e as DEFAULT_CAPABILITIES,te as EMPTY_BLOCKS,je as MINIMAL_CAPABILITIES,Z as StdLib,ze as WrappedBuilder,Ye as compilable,Ke as compileStatements,Ne as compileStd,I as debugCompiler,Se as invokeStaticBlock,ve as invokeStaticBlockWithStack,he as meta,Te as programCompilationContext,qe as templateCacheCounters,xe as templateCompilationContext,Qe as templateFactory};
//# sourceMappingURL=index.js.map

{"version":3,"file":"index.js","sources":["../../../local-debug-flags/index.ts","../../lib/compiler.ts","../../lib/opcode-builder/helpers/resolution.ts","../../lib/opcode-builder/opcodes.ts","../../lib/opcode-builder/operands.ts","../../lib/opcode-builder/encoder.ts","../../lib/compilable-template.ts","../../lib/opcode-builder/stdlib.ts","../../lib/utils.ts","../../lib/opcode-builder/helpers/vm.ts","../../lib/syntax/compilers.ts","../../lib/syntax/expressions.ts","../../lib/opcode-builder/helpers/expr.ts","../../lib/opcode-builder/helpers/shared.ts","../../lib/opcode-builder/helpers/blocks.ts","../../lib/opcode-builder/helpers/conditional.ts","../../lib/opcode-builder/helpers/components.ts","../../lib/opcode-builder/helpers/stdlib.ts","../../lib/program-context.ts","../../lib/opcode-builder/context.ts","../../lib/syntax/statements.ts","../../lib/opcode-builder/delegate.ts","../../lib/wrapped-component.ts","../../lib/template.ts"],"sourcesContent":["export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { HandleResult, TemplateCompilationContext } from '@glimmer/interfaces';\nimport { debugSlice } from '@glimmer/debug';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { extractHandle } from '@glimmer/util';\n\nexport let debugCompiler: (context: TemplateCompilationContext, handle: HandleResult) => void;\n\nif (LOCAL_SHOULD_LOG) {\n  debugCompiler = (context: TemplateCompilationContext, result: HandleResult) => {\n    let handle = extractHandle(result);\n    let { heap } = context.program;\n    let start = heap.getaddr(handle);\n    let end = start + heap.sizeof(handle);\n\n    debugSlice(context, start, end);\n  };\n}\n","import type {\n  CompileTimeConstants,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Expressions,\n  Owner,\n  ResolutionTimeConstants,\n  ResolveComponentOp,\n  ResolveComponentOrHelperOp,\n  ResolveHelperOp,\n  ResolveModifierOp,\n  ResolveOptionalComponentOrHelperOp,\n  SexpOpcode,\n} from '@glimmer/interfaces';\nimport { assert, debugToString, expect, unwrap } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nfunction isGetLikeTuple(opcode: Expressions.Expression): opcode is Expressions.TupleExpression {\n  return Array.isArray(opcode) && opcode.length === 2;\n}\n\nfunction makeResolutionTypeVerifier(typeToVerify: SexpOpcode) {\n  return (\n    opcode: Expressions.Expression\n  ): opcode is Expressions.GetFree | Expressions.GetLexicalSymbol => {\n    if (!isGetLikeTuple(opcode)) return false;\n\n    let type = opcode[0];\n\n    return (\n      type === SexpOpcodes.GetStrictKeyword ||\n      type === SexpOpcodes.GetLexicalSymbol ||\n      type === typeToVerify\n    );\n  };\n}\n\nexport const isGetFreeComponent = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);\n\nexport const isGetFreeModifier = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);\n\nexport const isGetFreeHelper = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);\n\nexport const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHead\n);\n\ninterface ResolvedContainingMetadata extends ContainingMetadata {\n  owner: Owner;\n  upvars: string[];\n}\n\nfunction assertResolverInvariants(meta: ContainingMetadata): ResolvedContainingMetadata {\n  if (import.meta.env.DEV) {\n    if (!meta.upvars) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no free vars were found'\n      );\n    }\n\n    if (!meta.owner) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from'\n      );\n    }\n  }\n\n  return meta as unknown as ResolvedContainingMetadata;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nexport function resolveComponent(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveComponentOp\n): void {\n  assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');\n\n  let type = expr[0];\n\n  if (import.meta.env.DEV && expr[0] === SexpOpcodes.GetStrictKeyword) {\n    assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    throw new Error(\n      `Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(\n      constants.component(\n        definition as object,\n        expect(owner, 'BUG: expected owner when resolving component definition')\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner)!;\n\n    if (import.meta.env.DEV && (typeof definition !== 'object' || definition === null)) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n      );\n    }\n\n    then(constants.resolvedComponent(definition, name));\n  }\n}\n\n/**\n * (helper)\n * (helper arg)\n */\nexport function resolveHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveHelperOp\n): void {\n  assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.helper(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    then(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'helper')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let helper = resolver.lookupHelper(name, owner)!;\n\n    if (import.meta.env.DEV && helper === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`\n      );\n    }\n\n    then(constants.helper(helper, name));\n  }\n}\n\n/**\n * <div {{modifier}}/>\n * <div {{modifier arg}}/>\n * <Foo {{modifier}}/>\n */\nexport function resolveModifier(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveModifierOp\n): void {\n  assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.modifier(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    let { upvars } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupBuiltInModifier(name);\n\n    if (import.meta.env.DEV && modifier === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`\n      );\n    }\n\n    then(constants.modifier(modifier!, name));\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupModifier(name, owner)!;\n\n    if (import.meta.env.DEV && modifier === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`\n      );\n    }\n\n    then(constants.modifier(modifier, name));\n  }\n}\n\n/**\n * {{component-or-helper arg}}\n */\nexport function resolveComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper }]: ResolveComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve a component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    let component = constants.component(\n      definition as object,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition as object, null, true);\n\n    if (import.meta.env.DEV && helper === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    ifHelper(expect(helper, 'BUG: helper must exist'));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(\n        expr as Expressions.GetStrictFree,\n        resolver,\n        meta,\n        constants,\n        'component or helper'\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n    } else {\n      let helper = resolver.lookupHelper(name, owner);\n\n      if (import.meta.env.DEV && helper === null) {\n        assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n        throw new Error(\n          `Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`\n        );\n      }\n\n      ifHelper(constants.helper(helper!, name));\n    }\n  }\n}\n\n/**\n * {{maybeHelperOrComponent}}\n */\nexport function resolveOptionalComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper, ifValue }]: ResolveOptionalComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve an optional component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    if (\n      typeof definition !== 'function' &&\n      (typeof definition !== 'object' || definition === null)\n    ) {\n      // The value is not an object, so it can't be a component or helper.\n      ifValue(constants.value(definition));\n      return;\n    }\n\n    let component = constants.component(\n      definition,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition, null, true);\n\n    if (helper !== null) {\n      ifHelper(helper);\n      return;\n    }\n\n    ifValue(constants.value(definition));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'value')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n      return;\n    }\n\n    let helper = resolver.lookupHelper(name, owner);\n\n    if (helper !== null) {\n      ifHelper(constants.helper(helper, name));\n    }\n  }\n}\n\nfunction lookupBuiltInHelper(\n  expr: Expressions.GetStrictFree,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  constants: ResolutionTimeConstants,\n  type: string\n): number {\n  let { upvars } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupBuiltInHelper(name);\n\n  if (import.meta.env.DEV && helper === null) {\n    assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw new Error(\n      `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  return constants.helper(helper!, name);\n}\n","import type {\n  HighLevelEnd,\n  HighLevelLabel,\n  HighLevelResolveComponent,\n  HighLevelResolveComponentOrHelper,\n  HighLevelResolveHelper,\n  HighLevelResolveLocal,\n  HighLevelResolveModifier,\n  HighLevelResolveOptionalComponentOrHelper,\n  HighLevelResolveTemplateLocal,\n  HighLevelStart,\n  HighLevelStartLabels,\n  HighLevelStopLabels,\n} from '@glimmer/interfaces';\n\nexport const HighLevelResolutionOpcodes = {\n  Modifier: 1003 satisfies HighLevelResolveModifier,\n  Component: 1004 satisfies HighLevelResolveComponent,\n  Helper: 1005 satisfies HighLevelResolveHelper,\n  ComponentOrHelper: 1007 satisfies HighLevelResolveComponentOrHelper,\n  OptionalComponentOrHelper: 1008 satisfies HighLevelResolveOptionalComponentOrHelper,\n  Local: 1010 satisfies HighLevelResolveLocal,\n  TemplateLocal: 1011 satisfies HighLevelResolveTemplateLocal,\n} as const;\n\nexport const HighLevelBuilderOpcodes = {\n  Label: 1000 satisfies HighLevelLabel,\n  StartLabels: 1001 satisfies HighLevelStartLabels,\n  StopLabels: 1002 satisfies HighLevelStopLabels,\n  Start: 1000 satisfies HighLevelStart,\n  End: 1002 satisfies HighLevelEnd,\n} as const;\n","import type {\n  BlockOperand,\n  BlockOperandType,\n  CompilableTemplate,\n  DebugSymbolsOperand,\n  DebugSymbolsOperandType,\n  IsStrictModeOperand,\n  IsStrictModeOperandType,\n  LabelOperand,\n  LabelOperandType,\n  LayoutOperand,\n  LayoutOperandType,\n  NonSmallIntOperand,\n  NonSmallIntOperandType,\n  SerializedBlock,\n  SerializedInlineBlock,\n  StdLibOperand,\n  StdLibOperandType,\n  SymbolTable,\n  SymbolTableOperand,\n  SymbolTableOperandType,\n} from '@glimmer/interfaces';\nimport { assert, isSmallInt } from '@glimmer/util';\n\nexport const HighLevelOperands = {\n  Label: 1 satisfies LabelOperandType,\n  IsStrictMode: 2 satisfies IsStrictModeOperandType,\n  DebugSymbols: 3 satisfies DebugSymbolsOperandType,\n  Block: 4 satisfies BlockOperandType,\n  StdLib: 5 satisfies StdLibOperandType,\n  NonSmallInt: 6 satisfies NonSmallIntOperandType,\n  SymbolTable: 7 satisfies SymbolTableOperandType,\n  Layout: 8 satisfies LayoutOperandType,\n} as const;\n\nexport function labelOperand(value: string): LabelOperand {\n  return { type: HighLevelOperands.Label, value };\n}\n\nexport function debugSymbolsOperand(): DebugSymbolsOperand {\n  return { type: HighLevelOperands.DebugSymbols, value: undefined };\n}\n\nexport function isStrictMode(): IsStrictModeOperand {\n  return { type: HighLevelOperands.IsStrictMode, value: undefined };\n}\n\nexport function blockOperand(value: SerializedInlineBlock | SerializedBlock): BlockOperand {\n  return { type: HighLevelOperands.Block, value };\n}\n\nexport function stdlibOperand(\n  value:\n    | 'main'\n    | 'trusting-append'\n    | 'cautious-append'\n    | 'trusting-non-dynamic-append'\n    | 'cautious-non-dynamic-append'\n): StdLibOperand {\n  return { type: HighLevelOperands.StdLib, value };\n}\n\nexport function nonSmallIntOperand(value: number): NonSmallIntOperand {\n  assert(\n    !isSmallInt(value),\n    'Attempted to make a operand for an int that was not a small int, you should encode this as an immediate'\n  );\n  return { type: HighLevelOperands.NonSmallInt, value };\n}\n\nexport function symbolTableOperand(value: SymbolTable): SymbolTableOperand {\n  return { type: HighLevelOperands.SymbolTable, value };\n}\n\nexport function layoutOperand(value: CompilableTemplate): LayoutOperand {\n  return { type: HighLevelOperands.Layout, value };\n}\n","import type {\n  BuilderOp,\n  BuilderOpcode,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Dict,\n  Encoder,\n  EncoderError,\n  HandleResult,\n  HighLevelOp,\n  InstructionEncoder,\n  Operand,\n  ResolutionTimeConstants,\n  SingleBuilderOperand,\n  STDLib,\n} from '@glimmer/interfaces';\nimport { InstructionEncoderImpl } from '@glimmer/encoder';\nimport {\n  assert,\n  dict,\n  EMPTY_STRING_ARRAY,\n  encodeHandle,\n  expect,\n  isPresentArray,\n  Stack,\n} from '@glimmer/util';\nimport { ARG_SHIFT, isMachineOp, MACHINE_MASK, MachineOp, Op, TYPE_SIZE } from '@glimmer/vm';\n\nimport { compilableBlock } from '../compilable-template';\nimport {\n  resolveComponent,\n  resolveComponentOrHelper,\n  resolveHelper,\n  resolveModifier,\n  resolveOptionalComponentOrHelper,\n} from './helpers/resolution';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from './opcodes';\nimport { HighLevelOperands } from './operands';\n\nexport class Labels {\n  labels: Dict<number> = dict();\n  targets: Array<{ at: number; target: string }> = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, target: string) {\n    this.targets.push({ at, target });\n  }\n\n  patch(heap: CompileTimeHeap): void {\n    let { targets, labels } = this;\n\n    for (const { at, target } of targets) {\n      let address = labels[target]! - at;\n\n      assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not');\n\n      heap.setbyaddr(at, address);\n    }\n  }\n}\n\nexport function encodeOp(\n  encoder: Encoder,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  op: BuilderOp | HighLevelOp\n): void {\n  if (isBuilderOpcode(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...(operands as SingleBuilderOperand[]));\n  } else {\n    switch (op[0]) {\n      case HighLevelBuilderOpcodes.Label:\n        return encoder.label(op[1]);\n      case HighLevelBuilderOpcodes.StartLabels:\n        return encoder.startLabels();\n      case HighLevelBuilderOpcodes.StopLabels:\n        return encoder.stopLabels();\n      case HighLevelResolutionOpcodes.Component:\n        return resolveComponent(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Modifier:\n        return resolveModifier(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Helper:\n        return resolveHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.ComponentOrHelper:\n        return resolveComponentOrHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalComponentOrHelper:\n        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);\n\n      case HighLevelResolutionOpcodes.Local: {\n        let freeVar = op[1];\n        let name = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n          freeVar\n        ]!;\n\n        let andThen = op[2];\n        andThen(name, meta.moduleName);\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.TemplateLocal: {\n        let [, valueIndex, then] = op;\n        let value = expect(\n          meta.scopeValues,\n          'BUG: Attempted to get a template local, but template does not have any'\n        )[valueIndex];\n\n        then(constants.value(value));\n\n        break;\n      }\n\n      default:\n        throw new Error(`Unexpected high level opcode ${op[0]}`);\n    }\n  }\n}\n\nexport class EncoderImpl implements Encoder {\n  private labelsStack = new Stack<Labels>();\n  private encoder: InstructionEncoder = new InstructionEncoderImpl([]);\n  private errors: EncoderError[] = [];\n  private handle: number;\n\n  constructor(\n    private heap: CompileTimeHeap,\n    private meta: ContainingMetadata,\n    private stdlib?: STDLib\n  ) {\n    this.handle = heap.malloc();\n  }\n\n  error(error: EncoderError): void {\n    this.encoder.encode(Op.Primitive, 0);\n    this.errors.push(error);\n  }\n\n  commit(size: number): HandleResult {\n    let handle = this.handle;\n\n    this.heap.pushMachine(MachineOp.Return);\n    this.heap.finishMalloc(handle, size);\n\n    if (isPresentArray(this.errors)) {\n      return { errors: this.errors, handle };\n    } else {\n      return handle;\n    }\n  }\n\n  push(\n    constants: CompileTimeConstants,\n    type: BuilderOpcode,\n    ...args: SingleBuilderOperand[]\n  ): void {\n    let { heap } = this;\n\n    if (import.meta.env.DEV && (type as number) > TYPE_SIZE) {\n      throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    }\n\n    let machine = isMachineOp(type) ? MACHINE_MASK : 0;\n    let first = type | machine | (args.length << ARG_SHIFT);\n\n    heap.pushRaw(first);\n\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n\n  private operand(constants: CompileTimeConstants, operand: SingleBuilderOperand): Operand {\n    if (typeof operand === 'number') {\n      return operand;\n    }\n\n    if (typeof operand === 'object' && operand !== null) {\n      if (Array.isArray(operand)) {\n        return encodeHandle(constants.array(operand));\n      } else {\n        switch (operand.type) {\n          case HighLevelOperands.Label:\n            this.currentLabels.target(this.heap.offset, operand.value);\n            return -1;\n\n          case HighLevelOperands.IsStrictMode:\n            return encodeHandle(constants.value(this.meta.isStrictMode));\n\n          case HighLevelOperands.DebugSymbols:\n            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));\n\n          case HighLevelOperands.Block:\n            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));\n\n          case HighLevelOperands.StdLib:\n            return expect(\n              this.stdlib,\n              'attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?'\n            )[operand.value];\n\n          case HighLevelOperands.NonSmallInt:\n          case HighLevelOperands.SymbolTable:\n          case HighLevelOperands.Layout:\n            return constants.value(operand.value);\n        }\n      }\n    }\n\n    return encodeHandle(constants.value(operand));\n  }\n\n  private get currentLabels(): Labels {\n    return expect(this.labelsStack.current, 'bug: not in a label stack');\n  }\n\n  label(name: string) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = expect(this.labelsStack.pop(), 'unbalanced push and pop labels');\n    label.patch(this.heap);\n  }\n}\n\nfunction isBuilderOpcode(op: number): op is BuilderOpcode {\n  return op < HighLevelBuilderOpcodes.Start;\n}\n","import type {\n  BlockSymbolTable,\n  BuilderOp,\n  CompilableBlock,\n  CompilableProgram,\n  CompilableTemplate,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  SerializedBlock,\n  SerializedInlineBlock,\n  Statement,\n  SymbolTable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { EMPTY_ARRAY } from '@glimmer/util';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { meta } from './opcode-builder/helpers/shared';\nimport { STATEMENTS } from './syntax/statements';\n\nexport const PLACEHOLDER_HANDLE = -1;\n\nclass CompilableTemplateImpl<S extends SymbolTable> implements CompilableTemplate<S> {\n  compiled: Nullable<HandleResult> = null;\n\n  constructor(\n    readonly statements: WireFormat.Statement[],\n    readonly meta: ContainingMetadata,\n    // Part of CompilableTemplate\n    readonly symbolTable: S,\n    // Used for debugging\n    readonly moduleName = 'plain block'\n  ) {}\n\n  // Part of CompilableTemplate\n  compile(context: CompileTimeCompilationContext): HandleResult {\n    return maybeCompile(this, context);\n  }\n}\n\nexport function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram {\n  let [statements, symbols, hasEval] = layout.block;\n  return new CompilableTemplateImpl(\n    statements,\n    meta(layout),\n    {\n      symbols,\n      hasEval,\n    },\n    moduleName\n  );\n}\n\nfunction maybeCompile(\n  compilable: CompilableTemplateImpl<SymbolTable>,\n  context: CompileTimeCompilationContext\n): HandleResult {\n  if (compilable.compiled !== null) return compilable.compiled;\n\n  compilable.compiled = PLACEHOLDER_HANDLE;\n\n  let { statements, meta } = compilable;\n\n  let result = compileStatements(statements, meta, context);\n  compilable.compiled = result;\n\n  return result;\n}\n\nexport function compileStatements(\n  statements: Statement[],\n  meta: ContainingMetadata,\n  syntaxContext: CompileTimeCompilationContext\n): HandleResult {\n  let sCompiler = STATEMENTS;\n  let context = templateCompilationContext(syntaxContext, meta);\n\n  let {\n    encoder,\n    program: { constants, resolver },\n  } = context;\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, meta, op as BuilderOp | HighLevelOp);\n  }\n\n  for (const statement of statements) {\n    sCompiler.compile(pushOp, statement);\n  }\n\n  let handle = context.encoder.commit(meta.size);\n\n  if (LOCAL_SHOULD_LOG) {\n    debugCompiler(context, handle);\n  }\n\n  return handle;\n}\n\nexport function compilableBlock(\n  block: SerializedInlineBlock | SerializedBlock,\n  containing: ContainingMetadata\n): CompilableBlock {\n  return new CompilableTemplateImpl<BlockSymbolTable>(block[0], containing, {\n    parameters: block[1] || (EMPTY_ARRAY as number[]),\n  });\n}\n","export class StdLib {\n  constructor(\n    public main: number,\n    private trustingGuardedAppend: number,\n    private cautiousGuardedAppend: number,\n    private trustingNonDynamicAppend: number,\n    private cautiousNonDynamicAppend: number\n  ) {}\n\n  get 'trusting-append'() {\n    return this.trustingGuardedAppend;\n  }\n\n  get 'cautious-append'() {\n    return this.cautiousGuardedAppend;\n  }\n\n  get 'trusting-non-dynamic-append'() {\n    return this.trustingNonDynamicAppend;\n  }\n\n  get 'cautious-non-dynamic-append'() {\n    return this.cautiousNonDynamicAppend;\n  }\n\n  getAppend(trusting: boolean) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n","import type { NamedBlocks, Nullable, SerializedInlineBlock, WireFormat } from '@glimmer/interfaces';\nimport { assign, dict, enumerate, unwrap } from '@glimmer/util';\n\ninterface NamedBlocksDict {\n  [key: string]: Nullable<WireFormat.SerializedInlineBlock>;\n}\n\nexport class NamedBlocksImpl implements NamedBlocks {\n  public names: string[];\n\n  constructor(private blocks: Nullable<NamedBlocksDict>) {\n    this.names = blocks ? Object.keys(blocks) : [];\n  }\n\n  get(name: string): Nullable<SerializedInlineBlock> {\n    if (!this.blocks) return null;\n\n    return this.blocks[name] || null;\n  }\n\n  has(name: string): boolean {\n    let { blocks } = this;\n    return blocks !== null && name in blocks;\n  }\n\n  with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks {\n    let { blocks } = this;\n\n    if (blocks) {\n      return new NamedBlocksImpl(assign({}, blocks, { [name]: block }));\n    } else {\n      return new NamedBlocksImpl({ [name]: block });\n    }\n  }\n\n  get hasAny(): boolean {\n    return this.blocks !== null;\n  }\n}\n\nexport const EMPTY_BLOCKS = new NamedBlocksImpl(null);\n\nexport function namedBlocks(blocks: WireFormat.Core.Blocks): NamedBlocks {\n  if (blocks === null) {\n    return EMPTY_BLOCKS;\n  }\n\n  let out: NamedBlocksDict = dict();\n\n  let [keys, values] = blocks;\n\n  for (const [i, key] of enumerate(keys)) {\n    out[key] = unwrap(values[i]);\n  }\n\n  return new NamedBlocksImpl(out);\n}\n","import type { CurriedType, NonSmallIntOperand, Nullable, WireFormat } from '@glimmer/interfaces';\nimport { encodeImmediate, isSmallInt } from '@glimmer/util';\nimport { $fp, $v0, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { isStrictMode, nonSmallIntOperand } from '../operands';\nimport { expr } from './expr';\nimport { SimpleArgs } from './shared';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport interface CompileHelper {\n  handle: number;\n  positional: Nullable<WireFormat.Core.Params>;\n  named: WireFormat.Core.Hash;\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void {\n  PushPrimitive(op, value);\n  op(Op.PrimitiveReference);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void {\n  let p: Primitive | NonSmallIntOperand = primitive;\n\n  if (typeof p === 'number') {\n    p = isSmallInt(p) ? encodeImmediate(p) : nonSmallIntOperand(p);\n  }\n\n  op(Op.Primitive, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function Call(\n  op: PushExpressionOp,\n  handle: number,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Helper, handle);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function CallDynamic(\n  op: PushExpressionOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  append?: () => void\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Dup, $fp, 1);\n  op(Op.DynamicHelper);\n  if (append) {\n    op(Op.Fetch, $v0);\n    append();\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n  } else {\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n    op(Op.Fetch, $v0);\n  }\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nexport function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void {\n  op(Op.PushDynamicScope);\n  op(Op.BindDynamicScope, names);\n  block();\n  op(Op.PopDynamicScope);\n}\n\nexport function Curry(\n  op: PushExpressionOp,\n  type: CurriedType,\n  definition: WireFormat.Expression,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.CaptureArgs);\n  expr(op, definition);\n  op(Op.Curry, type, isStrictMode());\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n","import type { BuilderOp, HighLevelOp, SexpOpcode, SexpOpcodeMap } from '@glimmer/interfaces';\nimport { assert, unwrap } from '@glimmer/util';\n\nexport type PushExpressionOp = (...op: BuilderOp | HighLevelOp) => void;\n\ndeclare const STATEMENT: unique symbol;\n\nexport type HighLevelStatementOp = [{ [STATEMENT]: undefined }];\n\nexport type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;\n\nexport type CompilerFunction<PushOp extends PushExpressionOp, TSexp> = (\n  op: PushOp,\n  sexp: TSexp\n) => void;\n\nexport class Compilers<PushOp extends PushExpressionOp, TSexpOpcodes extends SexpOpcode> {\n  private names: {\n    [name: number]: number;\n  } = {};\n\n  private funcs: CompilerFunction<PushOp, any>[] = [];\n\n  add<TSexpOpcode extends TSexpOpcodes>(\n    name: TSexpOpcode,\n    func: CompilerFunction<PushOp, SexpOpcodeMap[TSexpOpcode]>\n  ): void {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n\n  compile(op: PushOp, sexp: SexpOpcodeMap[TSexpOpcodes]): void {\n    let name = sexp[0];\n    let index = unwrap(this.names[name]);\n    let func = this.funcs[index];\n    assert(!!func, `expected an implementation for ${sexp[0]}`);\n\n    func(op, sexp);\n  }\n}\n","import type { ExpressionSexpOpcode } from '@glimmer/interfaces';\nimport { $v0, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushExpressionOp } from './compilers';\n\nimport { expr } from '../opcode-builder/helpers/expr';\nimport { isGetFreeHelper } from '../opcode-builder/helpers/resolution';\nimport { SimpleArgs } from '../opcode-builder/helpers/shared';\nimport { Call, CallDynamic, Curry, PushPrimitiveReference } from '../opcode-builder/helpers/vm';\nimport { HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { Compilers } from './compilers';\n\nexport const EXPRESSIONS = new Compilers<PushExpressionOp, ExpressionSexpOpcode>();\n\nEXPRESSIONS.add(SexpOpcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) {\n    expr(op, part);\n  }\n\n  op(Op.Concat, parts.length);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Call, (op, [, expression, positional, named]) => {\n  if (isGetFreeHelper(expression)) {\n    op(HighLevelResolutionOpcodes.Helper, expression, (handle: number) => {\n      Call(op, handle, positional, named);\n    });\n  } else {\n    expr(op, expression);\n    CallDynamic(op, positional, named);\n  }\n});\n\nEXPRESSIONS.add(SexpOpcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetSymbol, (op, [, sym, path]) => {\n  op(Op.GetVariable, sym);\n  withPath(op, path);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(HighLevelResolutionOpcodes.TemplateLocal, sym, (handle: number) => {\n    op(Op.ConstantReference, handle);\n    withPath(op, path);\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetStrictKeyword, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHead, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nfunction withPath(op: PushExpressionOp, path?: string[]) {\n  if (path === undefined || path.length === 0) return;\n\n  for (let i = 0; i < path.length; i++) {\n    op(Op.GetProperty, path[i]);\n  }\n}\n\nEXPRESSIONS.add(SexpOpcodes.Undefined, (op) => PushPrimitiveReference(op, undefined));\nEXPRESSIONS.add(SexpOpcodes.HasBlock, (op, [, block]) => {\n  expr(op, block);\n  op(Op.HasBlock);\n});\n\nEXPRESSIONS.add(SexpOpcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.HasBlockParams);\n});\n\nEXPRESSIONS.add(SexpOpcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy);\n  expr(op, truthy);\n  expr(op, condition);\n  op(Op.IfInline);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Not, (op, [, value]) => {\n  expr(op, value);\n  op(Op.Not);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression);\n  op(Op.GetDynamicVar);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Log, (op, [, positional]) => {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, null, false);\n  op(Op.Log);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n});\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp } from '../../syntax/compilers';\n\nimport { EXPRESSIONS } from '../../syntax/expressions';\nimport { PushPrimitive } from './vm';\n\nexport function expr(op: PushExpressionOp, expression: WireFormat.Expression): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(op, expression);\n  } else {\n    PushPrimitive(op, expression);\n    op(Op.PrimitiveReference);\n  }\n}\n","import type {\n  ContainingMetadata,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { EMPTY_ARRAY, EMPTY_STRING_ARRAY } from '@glimmer/util';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { PushYieldableBlock } from './blocks';\nimport { expr } from './expr';\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nexport function CompileArgs(\n  op: PushStatementOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  blocks: NamedBlocks,\n  atNames: boolean\n): void {\n  let blockNames: string[] = blocks.names;\n  for (const name of blockNames) {\n    PushYieldableBlock(op, blocks.get(name));\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  if (blocks) {\n    flags |= 0b111;\n  }\n\n  let names = EMPTY_ARRAY as readonly string[];\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names as string[], blockNames, flags);\n}\n\nexport function SimpleArgs(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>,\n  named: Nullable<WireFormat.Core.Hash>,\n  atNames: boolean\n): void {\n  if (positional === null && named === null) {\n    op(Op.PushEmptyArgs);\n    return;\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  let names = EMPTY_STRING_ARRAY;\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nexport function CompilePositional(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>\n): number {\n  if (positional === null) return 0;\n\n  for (let i = 0; i < positional.length; i++) {\n    expr(op, positional[i]);\n  }\n\n  return positional.length;\n}\n\nexport function meta(layout: LayoutWithContext): ContainingMetadata {\n  let [, symbols, , upvars] = layout.block;\n\n  return {\n    evalSymbols: evalSymbols(layout),\n    upvars: upvars,\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: symbols.length,\n  };\n}\n\nexport function evalSymbols(layout: LayoutWithContext): Nullable<string[]> {\n  let { block } = layout;\n  let [, symbols, hasEval] = block;\n\n  return hasEval ? symbols : null;\n}\n","import type { Nullable, WireFormat } from '@glimmer/interfaces';\nimport { $fp, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { blockOperand, symbolTableOperand } from '../operands';\nimport { SimpleArgs } from './shared';\nimport { PushPrimitive } from './vm';\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nexport function YieldBlock(\n  op: PushStatementOp,\n  to: number,\n  positional: Nullable<WireFormat.Core.Params>\n): void {\n  SimpleArgs(op, positional, null, true);\n  op(Op.GetBlock, to);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.InvokeYield);\n  op(Op.PopScope);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nexport function PushYieldableBlock(\n  op: PushStatementOp,\n  block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  PushSymbolTable(op, block && block[1]);\n  op(Op.PushBlockScope);\n  PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nexport function InvokeStaticBlock(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock\n): void {\n  op(MachineOp.PushFrame);\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nexport function InvokeStaticBlockWithStack(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock,\n  callerCount: number\n): void {\n  let parameters = block[1];\n  let calleeCount = parameters.length;\n  let count = Math.min(callerCount, calleeCount);\n\n  if (count === 0) {\n    InvokeStaticBlock(op, block);\n    return;\n  }\n\n  op(MachineOp.PushFrame);\n\n  if (count) {\n    op(Op.ChildScope);\n\n    for (let i = 0; i < count; i++) {\n      op(Op.Dup, $fp, callerCount - i);\n      op(Op.SetVariable, parameters[i]);\n    }\n  }\n\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n\n  if (count) {\n    op(Op.PopScope);\n  }\n\n  op(MachineOp.PopFrame);\n}\n\nexport function PushSymbolTable(op: PushExpressionOp, parameters: number[] | null): void {\n  if (parameters !== null) {\n    op(Op.PushSymbolTable, symbolTableOperand({ parameters }));\n  } else {\n    PushPrimitive(op, null);\n  }\n}\n\nexport function PushCompilable(\n  op: PushExpressionOp,\n  _block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  if (_block === null) {\n    PushPrimitive(op, null);\n  } else {\n    op(Op.Constant, blockOperand(_block));\n  }\n}\n","import { unwrap } from '@glimmer/util';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushStatementOp } from '../../syntax/compilers';\n\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { labelOperand } from '../operands';\n\nexport type When = (match: number, callback: () => void) => void;\n\nexport function SwitchCases(\n  op: PushStatementOp,\n  bootstrap: () => void,\n  matcher: (when: When) => void\n): void {\n  // Setup the switch DSL\n  let clauses: Array<{ match: number; label: string; callback: () => void }> = [];\n\n  let count = 0;\n\n  function when(match: number, callback: () => void): void {\n    clauses.push({ match, callback, label: `CLAUSE${count++}` });\n  }\n\n  // Call the callback\n  matcher(when);\n\n  // Emit the opcodes for the switch\n  op(Op.Enter, 1);\n  bootstrap();\n  op(HighLevelBuilderOpcodes.StartLabels);\n\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) {\n    op(Op.JumpEq, labelOperand(clause.label), clause.match);\n  }\n\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = unwrap(clauses[i]);\n\n    op(HighLevelBuilderOpcodes.Label, clause.label);\n    op(Op.Pop, 1);\n    clause.callback();\n\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    if (i !== 0) {\n      op(MachineOp.Jump, labelOperand('END'));\n    }\n  }\n\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(HighLevelBuilderOpcodes.StopLabels);\n  op(Op.Exit);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nexport function Replayable(op: PushStatementOp, args: () => number, body: () => void): void {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n\n  op(HighLevelBuilderOpcodes.StartLabels);\n  op(MachineOp.PushFrame);\n\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(MachineOp.ReturnTo, labelOperand('ENDINITIAL'));\n\n  // Push the arguments onto the stack. The args() function\n  // tells us how many stack elements to retain for re-execution\n  // when updating.\n  let count = args();\n\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  //\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(Op.Enter, count);\n\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body();\n\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(HighLevelBuilderOpcodes.Label, 'FINALLY');\n\n  // Finalize the DOM.\n  op(Op.Exit);\n\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(MachineOp.Return);\n\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(HighLevelBuilderOpcodes.Label, 'ENDINITIAL');\n  op(MachineOp.PopFrame);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nexport function ReplayableIf(\n  op: PushStatementOp,\n  args: () => number,\n  ifTrue: () => void,\n  ifFalse?: () => void\n): void {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(Op.JumpUnless, labelOperand('ELSE'));\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue();\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(MachineOp.Jump, labelOperand('FINALLY'));\n    op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    if (ifFalse !== undefined) {\n      ifFalse();\n    }\n  });\n}\n","import type {\n  CapabilityMask,\n  CompilableProgram,\n  CompileTimeComponent,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport type { SavedRegister } from '@glimmer/vm';\nimport { hasCapability } from '@glimmer/manager';\nimport { EMPTY_STRING_ARRAY, reverse, unwrap } from '@glimmer/util';\nimport { $s0, $s1, $sp, InternalComponentCapabilities, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { namedBlocks } from '../../utils';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { isStrictMode, labelOperand, layoutOperand, symbolTableOperand } from '../operands';\nimport { InvokeStaticBlock, PushYieldableBlock, YieldBlock } from './blocks';\nimport { Replayable } from './conditional';\nimport { expr } from './expr';\nimport { CompileArgs, CompilePositional } from './shared';\n\nexport const ATTRS_BLOCK = '&attrs';\n\ninterface AnyComponent {\n  elementBlock: Nullable<WireFormat.SerializedInlineBlock>;\n  positional: WireFormat.Core.Params;\n  named: WireFormat.Core.Hash;\n  blocks: NamedBlocks;\n}\n\n// {{component}}\nexport interface DynamicComponent extends AnyComponent {\n  definition: WireFormat.Expression;\n  atNames: boolean;\n  curried: boolean;\n}\n\n// <Component>\nexport interface StaticComponent extends AnyComponent {\n  capabilities: CapabilityMask;\n  layout: CompilableProgram;\n}\n\n// chokepoint\nexport interface Component extends AnyComponent {\n  // either we know the capabilities statically or we need to be conservative and assume\n  // that the component requires all capabilities\n  capabilities: CapabilityMask | true;\n\n  // are the arguments supplied as atNames?\n  atNames: boolean;\n\n  // do we have the layout statically or will we need to look it up at runtime?\n  layout?: CompilableProgram;\n}\n\nexport function InvokeComponent(\n  op: PushStatementOp,\n  component: CompileTimeComponent,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks\n): void {\n  let { compilable, capabilities, handle } = component;\n\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  if (compilable) {\n    op(Op.PushComponentDefinition, handle);\n    InvokeStaticComponent(op, {\n      capabilities: capabilities,\n      layout: compilable,\n      elementBlock,\n      positional,\n      named,\n      blocks,\n    });\n  } else {\n    op(Op.PushComponentDefinition, handle);\n    InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n    });\n  }\n}\n\nexport function InvokeDynamicComponent(\n  op: PushStatementOp,\n  definition: WireFormat.Core.Expression,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks,\n  atNames: boolean,\n  curried: boolean\n): void {\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  Replayable(\n    op,\n\n    () => {\n      expr(op, definition);\n      op(Op.Dup, $sp, 0);\n      return 2;\n    },\n\n    () => {\n      op(Op.JumpUnless, labelOperand('ELSE'));\n\n      if (curried) {\n        op(Op.ResolveCurriedComponent);\n      } else {\n        op(Op.ResolveDynamicComponent, isStrictMode());\n      }\n\n      op(Op.PushDynamicComponentInstance);\n      InvokeNonStaticComponent(op, {\n        capabilities: true,\n        elementBlock,\n        positional,\n        named,\n        atNames,\n        blocks,\n      });\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n    }\n  );\n}\n\nfunction InvokeStaticComponent(\n  op: PushStatementOp,\n  { capabilities, layout, elementBlock, positional, named, blocks }: StaticComponent\n): void {\n  let { symbolTable } = layout;\n\n  let bailOut =\n    symbolTable.hasEval || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs);\n\n  if (bailOut) {\n    InvokeNonStaticComponent(op, {\n      capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n      layout,\n    });\n\n    return;\n  }\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n  op(MachineOp.PushFrame);\n\n  // Setup arguments\n  let { symbols } = symbolTable;\n\n  // As we push values onto the stack, we store the symbols associated  with them\n  // so that we can set them on the scope later on with SetVariable and SetBlock\n  let blockSymbols: number[] = [];\n  let argSymbols: number[] = [];\n  let argNames: string[] = [];\n\n  // First we push the blocks onto the stack\n  let blockNames = blocks.names;\n\n  // Starting with the attrs block, if it exists and is referenced in the component\n  if (elementBlock !== null) {\n    let symbol = symbols.indexOf(ATTRS_BLOCK);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, elementBlock);\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Followed by the other blocks, if they exist and are referenced in the component.\n  // Also store the index of the associated symbol.\n  for (const name of blockNames) {\n    let symbol = symbols.indexOf(`&${name}`);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, blocks.get(name));\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Next up we have arguments. If the component has the `createArgs` capability,\n  // then it wants access to the arguments in JavaScript. We can't know whether\n  // or not an argument is used, so we have to give access to all of them.\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    // First we push positional arguments\n    let count = CompilePositional(op, positional);\n\n    // setup the flags with the count of positionals, and to indicate that atNames\n    // are used\n    let flags = count << 4;\n    flags |= 0b1000;\n\n    let names: string[] = EMPTY_STRING_ARRAY;\n\n    // Next, if named args exist, push them all. If they have an associated symbol\n    // in the invoked component (e.g. they are used within its template), we push\n    // that symbol. If not, we still push the expression as it may be used, and\n    // we store the symbol as -1 (this is used later).\n    if (named !== null) {\n      names = named[0];\n      let val = named[1];\n\n      for (let i = 0; i < val.length; i++) {\n        let symbol = symbols.indexOf(unwrap(names[i]));\n\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n      }\n    }\n\n    // Finally, push the VM arguments themselves. These args won't need access\n    // to blocks (they aren't accessible from userland anyways), so we push an\n    // empty array instead of the actual block names.\n    op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n\n    // And push an extra pop operation to remove the args before we begin setting\n    // variables on the local context\n    argSymbols.push(-1);\n  } else if (named !== null) {\n    // If the component does not have the `createArgs` capability, then the only\n    // expressions we need to push onto the stack are those that are actually\n    // referenced in the template of the invoked component (e.g. have symbols).\n    let names = named[0];\n    let val = named[1];\n\n    for (let i = 0; i < val.length; i++) {\n      let name = unwrap(names[i]);\n      let symbol = symbols.indexOf(name);\n\n      if (symbol !== -1) {\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n        argNames.push(name);\n      }\n    }\n  }\n\n  op(Op.BeginComponentTransaction, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PushDynamicScope);\n  }\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createInstance)) {\n    op(Op.CreateComponent, (blocks.has('default') as any) | 0, $s0);\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    op(Op.GetComponentSelf, $s0);\n  } else {\n    op(Op.GetComponentSelf, $s0, argNames);\n  }\n\n  // Setup the new root scope for the component\n  op(Op.RootScope, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0);\n\n  // Pop the self reference off the stack and set it to the symbol for `this`\n  // in the new scope. This is why all subsequent symbols are increased by one.\n  op(Op.SetVariable, 0);\n\n  // Going in reverse, now we pop the args/blocks off the stack, starting with\n  // arguments, and assign them to their symbols in the new scope.\n  for (const symbol of reverse(argSymbols)) {\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n\n    if (symbol === -1) {\n      // The expression was not bound to a local symbol, it was only pushed to be\n      // used with VM args in the javascript side\n      op(Op.Pop, 1);\n    } else {\n      op(Op.SetVariable, symbol + 1);\n    }\n  }\n\n  // if any positional params exist, pop them off the stack as well\n  if (positional !== null) {\n    op(Op.Pop, positional.length);\n  }\n\n  // Finish up by popping off and assigning blocks\n  for (const symbol of reverse(blockSymbols)) {\n    op(Op.SetBlock, symbol + 1);\n  }\n\n  op(Op.Constant, layoutOperand(layout));\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(Op.DidRenderLayout, $s0);\n\n  op(MachineOp.PopFrame);\n  op(Op.PopScope);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PopDynamicScope);\n  }\n\n  op(Op.CommitComponentTransaction);\n  op(Op.Load, $s0);\n}\n\nexport function InvokeNonStaticComponent(\n  op: PushStatementOp,\n  { capabilities, elementBlock, positional, named, atNames, blocks: namedBlocks, layout }: Component\n): void {\n  let bindableBlocks = !!namedBlocks;\n  let bindableAtNames =\n    capabilities === true ||\n    hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) ||\n    !!(named && named[0].length !== 0);\n\n  let blocks = namedBlocks.with('attrs', elementBlock);\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  CompileArgs(op, positional, named, blocks, atNames);\n  op(Op.PrepareArgs, $s0);\n\n  invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, () => {\n    if (layout) {\n      op(Op.PushSymbolTable, symbolTableOperand(layout.symbolTable));\n      op(Op.Constant, layoutOperand(layout));\n      op(Op.CompileBlock);\n    } else {\n      op(Op.GetComponentLayout, $s0);\n    }\n\n    op(Op.PopulateLayout, $s0);\n  });\n\n  op(Op.Load, $s0);\n}\n\nexport function WrappedComponent(\n  op: PushStatementOp,\n  layout: LayoutWithContext,\n  attrsBlockNumber: number\n): void {\n  op(HighLevelBuilderOpcodes.StartLabels);\n  WithSavedRegister(op, $s1, () => {\n    op(Op.GetComponentTagName, $s0);\n    op(Op.PrimitiveReference);\n    op(Op.Dup, $sp, 0);\n  });\n  op(Op.JumpUnless, labelOperand('BODY'));\n  op(Op.Fetch, $s1);\n  op(Op.PutComponentOperations);\n  op(Op.OpenDynamicElement);\n  op(Op.DidCreateElement, $s0);\n  YieldBlock(op, attrsBlockNumber, null);\n  op(Op.FlushElement);\n  op(HighLevelBuilderOpcodes.Label, 'BODY');\n  InvokeStaticBlock(op, [layout.block[0], []]);\n  op(Op.Fetch, $s1);\n  op(Op.JumpUnless, labelOperand('END'));\n  op(Op.CloseElement);\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(Op.Load, $s1);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\nexport function invokePreparedComponent(\n  op: PushStatementOp,\n  hasBlock: boolean,\n  bindableBlocks: boolean,\n  bindableAtNames: boolean,\n  populateLayout: Nullable<() => void> = null\n): void {\n  op(Op.BeginComponentTransaction, $s0);\n  op(Op.PushDynamicScope);\n\n  op(Op.CreateComponent, (hasBlock as any) | 0, $s0);\n\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  if (populateLayout) {\n    populateLayout();\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n  op(Op.GetComponentSelf, $s0);\n\n  op(Op.VirtualRootScope, $s0);\n  op(Op.SetVariable, 0);\n  op(Op.SetupForEval, $s0);\n\n  if (bindableAtNames) op(Op.SetNamedVariables, $s0);\n  if (bindableBlocks) op(Op.SetBlocks, $s0);\n\n  op(Op.Pop, 1);\n  op(Op.InvokeComponentLayout, $s0);\n  op(Op.DidRenderLayout, $s0);\n  op(MachineOp.PopFrame);\n\n  op(Op.PopScope);\n  op(Op.PopDynamicScope);\n  op(Op.CommitComponentTransaction);\n}\n\nexport function InvokeBareComponent(op: PushStatementOp): void {\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  op(Op.PushEmptyArgs);\n  op(Op.PrepareArgs, $s0);\n  invokePreparedComponent(op, false, false, true, () => {\n    op(Op.GetComponentLayout, $s0);\n    op(Op.PopulateLayout, $s0);\n  });\n  op(Op.Load, $s0);\n}\n\nexport function WithSavedRegister(\n  op: PushExpressionOp,\n  register: SavedRegister,\n  block: () => void\n): void {\n  op(Op.Fetch, register);\n  block();\n  op(Op.Load, register);\n}\n","import type {\n  BuilderOp,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HighLevelOp,\n} from '@glimmer/interfaces';\nimport { $s0, ContentType, MachineOp, Op } from '@glimmer/vm';\n\nimport type { HighLevelStatementOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { encodeOp, EncoderImpl } from '../encoder';\nimport { StdLib } from '../stdlib';\nimport { InvokeBareComponent, invokePreparedComponent } from './components';\nimport { SwitchCases } from './conditional';\nimport { CallDynamic } from './vm';\n\nexport function main(op: PushStatementOp): void {\n  op(Op.Main, $s0);\n  invokePreparedComponent(op, false, false, true);\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nexport function StdAppend(\n  op: PushStatementOp,\n  trusting: boolean,\n  nonDynamicAppend: number | null\n): void {\n  SwitchCases(\n    op,\n    () => op(Op.ContentType),\n    (when) => {\n      when(ContentType.String, () => {\n        if (trusting) {\n          op(Op.AssertSame);\n          op(Op.AppendHTML);\n        } else {\n          op(Op.AppendText);\n        }\n      });\n\n      if (typeof nonDynamicAppend === 'number') {\n        when(ContentType.Component, () => {\n          op(Op.ResolveCurriedComponent);\n          op(Op.PushDynamicComponentInstance);\n          InvokeBareComponent(op);\n        });\n\n        when(ContentType.Helper, () => {\n          CallDynamic(op, null, null, () => {\n            op(MachineOp.InvokeStatic, nonDynamicAppend);\n          });\n        });\n      } else {\n        // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n        when(ContentType.Component, () => {\n          op(Op.AppendText);\n        });\n\n        when(ContentType.Helper, () => {\n          op(Op.AppendText);\n        });\n      }\n\n      when(ContentType.SafeString, () => {\n        op(Op.AssertSame);\n        op(Op.AppendSafeHTML);\n      });\n\n      when(ContentType.Fragment, () => {\n        op(Op.AssertSame);\n        op(Op.AppendDocumentFragment);\n      });\n\n      when(ContentType.Node, () => {\n        op(Op.AssertSame);\n        op(Op.AppendNode);\n      });\n    }\n  );\n}\n\nexport function compileStd(context: CompileTimeCompilationContext): StdLib {\n  let mainHandle = build(context, (op) => main(op));\n  let trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null));\n  let cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null));\n\n  let trustingGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, true, trustingGuardedNonDynamicAppend)\n  );\n  let cautiousGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, false, cautiousGuardedNonDynamicAppend)\n  );\n\n  return new StdLib(\n    mainHandle,\n    trustingGuardedDynamicAppend,\n    cautiousGuardedDynamicAppend,\n    trustingGuardedNonDynamicAppend,\n    cautiousGuardedNonDynamicAppend\n  );\n}\n\nexport const STDLIB_META: ContainingMetadata = {\n  evalSymbols: null,\n  upvars: null,\n  moduleName: 'stdlib',\n\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0,\n};\n\nfunction build(\n  program: CompileTimeCompilationContext,\n  builder: (op: PushStatementOp) => void\n): number {\n  let { constants, heap, resolver } = program;\n  let encoder = new EncoderImpl(heap, STDLIB_META);\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, STDLIB_META, op as BuilderOp | HighLevelOp);\n  }\n\n  builder(pushOp);\n\n  let result = encoder.commit(0);\n\n  if (typeof result !== 'number') {\n    // This shouldn't be possible\n    throw new Error(`Unexpected errors compiling std`);\n  } else {\n    return result;\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  CreateRuntimeOp,\n  ResolutionTimeConstants,\n  STDLib,\n} from '@glimmer/interfaces';\n\nimport { compileStd } from './opcode-builder/helpers/stdlib';\n\nexport class CompileTimeCompilationContextImpl implements CompileTimeCompilationContext {\n  readonly constants: CompileTimeConstants & ResolutionTimeConstants;\n  readonly heap: CompileTimeHeap;\n  readonly stdlib: STDLib;\n\n  constructor(\n    { constants, heap }: CompileTimeArtifacts,\n    readonly resolver: CompileTimeResolver,\n    readonly createOp: CreateRuntimeOp\n  ) {\n    this.constants = constants;\n    this.heap = heap;\n    this.stdlib = compileStd(this);\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeResolver,\n  ContainingMetadata,\n  CreateRuntimeOp,\n  TemplateCompilationContext,\n} from '@glimmer/interfaces';\n\nimport { CompileTimeCompilationContextImpl } from '../program-context';\nimport { EncoderImpl } from './encoder';\n\nexport function programCompilationContext(\n  artifacts: CompileTimeArtifacts,\n  resolver: CompileTimeResolver,\n  createOp: CreateRuntimeOp\n): CompileTimeCompilationContext {\n  return new CompileTimeCompilationContextImpl(artifacts, resolver, createOp);\n}\n\nexport function templateCompilationContext(\n  program: CompileTimeCompilationContext,\n  meta: ContainingMetadata\n): TemplateCompilationContext {\n  let encoder = new EncoderImpl(program.heap, meta, program.stdlib);\n\n  return {\n    program,\n    encoder,\n    meta,\n  };\n}\n","import type {\n  CompileTimeComponent,\n  StatementSexpOpcode,\n  WellKnownAttrName,\n  WellKnownTagName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { $fp, $sp, ContentType, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushStatementOp } from './compilers';\n\nimport {\n  InvokeStaticBlock,\n  InvokeStaticBlockWithStack,\n  YieldBlock,\n} from '../opcode-builder/helpers/blocks';\nimport {\n  InvokeComponent,\n  InvokeDynamicComponent,\n  InvokeNonStaticComponent,\n} from '../opcode-builder/helpers/components';\nimport { Replayable, ReplayableIf, SwitchCases } from '../opcode-builder/helpers/conditional';\nimport { expr } from '../opcode-builder/helpers/expr';\nimport {\n  isGetFreeComponent,\n  isGetFreeComponentOrHelper,\n  isGetFreeModifier,\n} from '../opcode-builder/helpers/resolution';\nimport { CompilePositional, SimpleArgs } from '../opcode-builder/helpers/shared';\nimport {\n  Call,\n  CallDynamic,\n  DynamicScope,\n  PushPrimitiveReference,\n} from '../opcode-builder/helpers/vm';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { debugSymbolsOperand, labelOperand, stdlibOperand } from '../opcode-builder/operands';\nimport { namedBlocks } from '../utils';\nimport { Compilers } from './compilers';\n\nexport const STATEMENTS = new Compilers<PushStatementOp, StatementSexpOpcode>();\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n\nSTATEMENTS.add(SexpOpcodes.Comment, (op, sexp) => op(Op.Comment, sexp[1]));\nSTATEMENTS.add(SexpOpcodes.CloseElement, (op) => op(Op.CloseElement));\nSTATEMENTS.add(SexpOpcodes.FlushElement, (op) => op(Op.FlushElement));\n\nSTATEMENTS.add(SexpOpcodes.Modifier, (op, [, expression, positional, named]) => {\n  if (isGetFreeModifier(expression)) {\n    op(HighLevelResolutionOpcodes.Modifier, expression, (handle: number) => {\n      op(MachineOp.PushFrame);\n      SimpleArgs(op, positional, named, false);\n      op(Op.Modifier, handle);\n      op(MachineOp.PopFrame);\n    });\n  } else {\n    expr(op, expression);\n    op(MachineOp.PushFrame);\n    SimpleArgs(op, positional, named, false);\n    op(Op.Dup, $fp, 1);\n    op(Op.DynamicModifier);\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticComponentAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElement, (op, [, tag]) => {\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(Op.PutComponentOperations);\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, elementBlock, null, named, blocks);\n    });\n  } else {\n    // otherwise, the component name was an expression, so resolve the expression\n    // and invoke it as a dynamic component\n    InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params));\n\nSTATEMENTS.add(SexpOpcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null));\n\nSTATEMENTS.add(SexpOpcodes.Debugger, (op, [, debugInfo]) =>\n  op(Op.Debugger, debugSymbolsOperand(), debugInfo)\n);\n\nSTATEMENTS.add(SexpOpcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else if (isGetFreeComponentOrHelper(value)) {\n    op(HighLevelResolutionOpcodes.OptionalComponentOrHelper, value, {\n      ifComponent(component: CompileTimeComponent) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n\n      ifHelper(handle: number) {\n        op(MachineOp.PushFrame);\n        Call(op, handle, null, null);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n\n      ifValue(handle: number) {\n        op(MachineOp.PushFrame);\n        op(Op.ConstantReference, handle);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n    });\n  } else if (value[0] === SexpOpcodes.Call) {\n    let [, expression, positional, named] = value;\n\n    if (isGetFreeComponentOrHelper(expression)) {\n      op(HighLevelResolutionOpcodes.ComponentOrHelper, expression, {\n        ifComponent(component: CompileTimeComponent) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle: number) {\n          op(MachineOp.PushFrame);\n          Call(op, handle, positional, named);\n          op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n          op(MachineOp.PopFrame);\n        },\n      });\n    } else {\n      SwitchCases(\n        op,\n        () => {\n          expr(op, expression);\n          op(Op.DynamicContentType);\n        },\n        (when) => {\n          when(ContentType.Component, () => {\n            op(Op.ResolveCurriedComponent);\n            op(Op.PushDynamicComponentInstance);\n            InvokeNonStaticComponent(op, {\n              capabilities: true,\n              elementBlock: null,\n              positional,\n              named,\n              atNames: false,\n              blocks: namedBlocks(null),\n            });\n          });\n\n          when(ContentType.Helper, () => {\n            CallDynamic(op, positional, named, () => {\n              op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n            });\n          });\n        }\n      );\n    }\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('cautious-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingAppend, (op, [, value]) => {\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('trusting-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, guid);\n\n      if (insertBefore === undefined) {\n        PushPrimitiveReference(op, undefined);\n      } else {\n        expr(op, insertBefore);\n      }\n\n      expr(op, destination);\n      op(Op.Dup, $sp, 0);\n\n      return 4;\n    },\n\n    () => {\n      op(Op.PushRemoteElement);\n      InvokeStaticBlock(op, block);\n      op(Op.PopRemoteElement);\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.If, (op, [, condition, block, inverse]) =>\n  ReplayableIf(\n    op,\n    () => {\n      expr(op, condition);\n      op(Op.ToBoolean);\n\n      return 1;\n    },\n\n    () => {\n      InvokeStaticBlock(op, block);\n    },\n\n    inverse\n      ? () => {\n          InvokeStaticBlock(op, inverse);\n        }\n      : undefined\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Each, (op, [, value, key, block, inverse]) =>\n  Replayable(\n    op,\n\n    () => {\n      if (key) {\n        expr(op, key);\n      } else {\n        PushPrimitiveReference(op, null);\n      }\n\n      expr(op, value);\n\n      return 2;\n    },\n\n    () => {\n      op(Op.EnterList, labelOperand('BODY'), labelOperand('ELSE'));\n      op(MachineOp.PushFrame);\n      op(Op.Dup, $fp, 1);\n      op(MachineOp.ReturnTo, labelOperand('ITER'));\n      op(HighLevelBuilderOpcodes.Label, 'ITER');\n      op(Op.Iterate, labelOperand('BREAK'));\n      op(HighLevelBuilderOpcodes.Label, 'BODY');\n      InvokeStaticBlockWithStack(op, block, 2);\n      op(Op.Pop, 2);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'BREAK');\n      op(MachineOp.PopFrame);\n      op(Op.ExitList);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Let, (op, [, positional, block]) => {\n  let count = CompilePositional(op, positional);\n  InvokeStaticBlockWithStack(op, block, count);\n});\n\nSTATEMENTS.add(SexpOpcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n\n    CompilePositional(op, expressions);\n    DynamicScope(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else {\n    InvokeStaticBlock(op, block);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nfunction hashToArgs(hash: WireFormat.Core.Hash | null): WireFormat.Core.Hash | null {\n  if (hash === null) return null;\n  let names = hash[0].map((key) => `@${key}`);\n  return [names as [string, ...string[]], hash[1]];\n}\n","import type {\n  CompileTimeComponent,\n  InternalComponentCapabilities,\n  Nullable,\n} from '@glimmer/interfaces';\n\nexport const DEFAULT_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: true,\n  dynamicTag: true,\n  prepareArgs: true,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: true,\n  createCaller: false,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport const MINIMAL_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: false,\n  createCaller: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport interface ResolverDelegate<R = unknown> {\n  lookupHelper?(name: string, referrer: R): Nullable<number> | void;\n  lookupModifier?(name: string, referrer: R): Nullable<number> | void;\n  lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;\n\n  // For debugging\n  resolve?(handle: number): R;\n}\n","import type {\n  BuilderOp,\n  CompilableProgram,\n  CompileTimeCompilationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  ProgramSymbolTable,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';\nimport { meta } from './opcode-builder/helpers/shared';\n\nexport class WrappedBuilder implements CompilableProgram {\n  public symbolTable: ProgramSymbolTable;\n  private compiled: Nullable<number> = null;\n  private attrsBlockNumber: number;\n\n  constructor(\n    private layout: LayoutWithContext,\n    public moduleName: string\n  ) {\n    let { block } = layout;\n    let [, symbols, hasEval] = block;\n\n    symbols = symbols.slice();\n\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);\n    if (attrsBlockIndex === -1) {\n      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);\n    } else {\n      this.attrsBlockNumber = attrsBlockIndex + 1;\n    }\n\n    this.symbolTable = {\n      hasEval,\n      symbols,\n    };\n  }\n\n  compile(syntax: CompileTimeCompilationContext): HandleResult {\n    if (this.compiled !== null) return this.compiled;\n\n    let m = meta(this.layout);\n    let context = templateCompilationContext(syntax, m);\n\n    let {\n      encoder,\n      program: { constants, resolver },\n    } = context;\n\n    function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n      encodeOp(encoder, constants, resolver, m, op as BuilderOp | HighLevelOp);\n    }\n\n    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);\n\n    let handle = context.encoder.commit(m.size);\n\n    if (typeof handle !== 'number') {\n      return handle;\n    }\n\n    this.compiled = handle;\n\n    if (LOCAL_SHOULD_LOG) {\n      debugCompiler(context, handle);\n    }\n\n    return handle;\n  }\n}\n","import type {\n  CompilableProgram,\n  LayoutWithContext,\n  Nullable,\n  Owner,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  Template,\n  TemplateFactory,\n  TemplateOk,\n} from '@glimmer/interfaces';\nimport { assign } from '@glimmer/util';\n\nimport { compilable } from './compilable-template';\nimport { WrappedBuilder } from './wrapped-component';\n\nlet clientId = 0;\n\nexport let templateCacheCounters = {\n  cacheHit: 0,\n  cacheMiss: 0,\n};\n\n// These interfaces are for backwards compatibility, some addons use these intimate APIs\nexport interface TemplateFactoryWithIdAndMeta extends TemplateFactory {\n  __id?: string;\n  __meta?: { moduleName: string };\n}\n\nexport interface TemplateWithIdAndReferrer extends TemplateOk {\n  id: string;\n  referrer: {\n    moduleName: string;\n    owner: Owner | null;\n  };\n}\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nexport default function templateFactory({\n  id: templateId,\n  moduleName,\n  block,\n  scope,\n  isStrictMode,\n}: SerializedTemplateWithLazyBlock): TemplateFactory {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let id = templateId || `client-${clientId++}`;\n\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  let parsedBlock: SerializedTemplateBlock;\n\n  let ownerlessTemplate: Template | null = null;\n  let templateCache = new WeakMap<object, Template>();\n\n  let factory: TemplateFactoryWithIdAndMeta = (owner?: Owner) => {\n    if (parsedBlock === undefined) {\n      parsedBlock = JSON.parse(block);\n    }\n\n    if (owner === undefined) {\n      if (ownerlessTemplate === null) {\n        templateCacheCounters.cacheMiss++;\n        ownerlessTemplate = new TemplateImpl({\n          id,\n          block: parsedBlock,\n          moduleName,\n          owner: null,\n          scope,\n          isStrictMode,\n        });\n      } else {\n        templateCacheCounters.cacheHit++;\n      }\n\n      return ownerlessTemplate;\n    }\n\n    let result = templateCache.get(owner) as Template;\n\n    if (result === undefined) {\n      templateCacheCounters.cacheMiss++;\n      result = new TemplateImpl({ id, block: parsedBlock, moduleName, owner, scope, isStrictMode });\n      templateCache.set(owner, result);\n    } else {\n      templateCacheCounters.cacheHit++;\n    }\n\n    return result;\n  };\n\n  factory.__id = id;\n  factory.__meta = { moduleName };\n\n  return factory;\n}\n\nclass TemplateImpl implements TemplateWithIdAndReferrer {\n  readonly result = 'ok';\n\n  private layout: Nullable<CompilableProgram> = null;\n  private wrappedLayout: Nullable<CompilableProgram> = null;\n\n  constructor(private parsedLayout: LayoutWithContext) {}\n\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n\n  get id() {\n    return this.parsedLayout.id;\n  }\n\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner,\n    };\n  }\n\n  asLayout(): CompilableProgram {\n    if (this.layout) return this.layout;\n    return (this.layout = compilable(assign({}, this.parsedLayout), this.moduleName));\n  }\n\n  asWrappedLayout(): CompilableProgram {\n    if (this.wrappedLayout) return this.wrappedLayout;\n    return (this.wrappedLayout = new WrappedBuilder(\n      assign({}, this.parsedLayout),\n      this.moduleName\n    ));\n  }\n}\n"],"names":["LOCAL_SHOULD_LOG","window","location","test","search","debugCompiler","makeResolutionTypeVerifier","typeToVerify","opcode","Array","isArray","length","isGetLikeTuple","type","SexpOpcodes","GetStrictKeyword","GetLexicalSymbol","context","result","handle","extractHandle","heap","program","start","getaddr","end","sizeof","debugSlice","isGetFreeComponent","GetFreeAsComponentHead","isGetFreeModifier","GetFreeAsModifierHead","isGetFreeHelper","GetFreeAsHelperHead","isGetFreeComponentOrHelper","GetFreeAsComponentOrHelperHead","assertResolverInvariants","meta","upvars","Error","owner","lookupBuiltInHelper","expr","resolver","constants","name","unwrap","helper","assert","isStrictMode","HighLevelResolutionOpcodes","Modifier","Component","Helper","ComponentOrHelper","OptionalComponentOrHelper","Local","TemplateLocal","HighLevelBuilderOpcodes","Label","StartLabels","StopLabels","Start","End","HighLevelOperands","IsStrictMode","DebugSymbols","Block","StdLib","NonSmallInt","SymbolTable","Layout","labelOperand","value","undefined","stdlibOperand","symbolTableOperand","layoutOperand","Labels","labels","dict","targets","label","index","this","target","at","push","patch","address","getbyaddr","setbyaddr","encodeOp","encoder","op","isBuilderOpcode","operands","startLabels","stopLabels","then","scopeValues","definition","expect","component","lookupComponent","resolvedComponent","resolveComponent","modifier","lookupBuiltInModifier","lookupModifier","resolveModifier","lookupHelper","resolveHelper","ifComponent","ifHelper","debugToString","resolveComponentOrHelper","ifValue","resolveOptionalComponentOrHelper","freeVar","andThen","moduleName","valueIndex","EncoderImpl","labelsStack","Stack","InstructionEncoderImpl","errors","constructor","stdlib","malloc","error","encode","Op","Primitive","commit","size","pushMachine","MachineOp","Return","finishMalloc","isPresentArray","args","TYPE_SIZE","first","isMachineOp","MACHINE_MASK","ARG_SHIFT","pushRaw","i","operand","encodeHandle","array","currentLabels","offset","evalSymbols","EMPTY_STRING_ARRAY","block","containing","CompilableTemplateImpl","parameters","EMPTY_ARRAY","current","pop","main","trustingGuardedAppend","cautiousGuardedAppend","trustingNonDynamicAppend","cautiousNonDynamicAppend","getAppend","trusting","NamedBlocksImpl","names","blocks","Object","keys","get","has","with","assign","hasAny","EMPTY_BLOCKS","namedBlocks","out","values","key","enumerate","PushPrimitiveReference","PushPrimitive","PrimitiveReference","primitive","p","isSmallInt","encodeImmediate","Call","positional","named","PushFrame","SimpleArgs","PopFrame","Fetch","$v0","CallDynamic","append","Dup","$fp","DynamicHelper","Pop","Curry","CaptureArgs","Compilers","funcs","add","func","compile","sexp","EXPRESSIONS","withPath","path","GetProperty","expression","atNames","PushEmptyArgs","flags","CompilePositional","val","PushArgs","layout","symbols","scope","hasEval","YieldBlock","to","GetBlock","SpreadBlock","CompileBlock","InvokeYield","PopScope","PushYieldableBlock","PushSymbolTable","PushBlockScope","PushCompilable","InvokeStaticBlock","InvokeVirtual","InvokeStaticBlockWithStack","callerCount","calleeCount","count","Math","min","ChildScope","SetVariable","_block","Constant","SwitchCases","bootstrap","matcher","clauses","match","callback","Enter","clause","slice","JumpEq","Jump","Exit","Replayable","body","ReturnTo","ReplayableIf","ifTrue","ifFalse","JumpUnless","Concat","parts","part","GetSymbol","sym","GetVariable","ConstantReference","_name","Undefined","HasBlock","HasBlockParams","IfInline","condition","truthy","falsy","Not","GetDynamicVar","Log","ATTRS_BLOCK","InvokeComponent","_elementBlock","_blocks","compilable","capabilities","elementBlock","PushComponentDefinition","symbolTable","bailOut","hasCapability","InternalComponentCapabilities","prepareArgs","InvokeNonStaticComponent","$s0","$sp","Load","blockSymbols","argSymbols","argNames","blockNames","symbol","indexOf","createArgs","BeginComponentTransaction","dynamicScope","PushDynamicScope","createInstance","CreateComponent","RegisterComponentDestructor","GetComponentSelf","RootScope","reverse","SetBlock","DidRenderLayout","PopDynamicScope","CommitComponentTransaction","InvokeStaticComponent","InvokeDynamicComponent","curried","ResolveCurriedComponent","ResolveDynamicComponent","PushDynamicComponentInstance","bindableBlocks","bindableAtNames","CompileArgs","PrepareArgs","invokePreparedComponent","GetComponentLayout","PopulateLayout","WrappedComponent","attrsBlockNumber","register","WithSavedRegister","$s1","GetComponentTagName","PutComponentOperations","OpenDynamicElement","DidCreateElement","FlushElement","CloseElement","hasBlock","populateLayout","VirtualRootScope","SetupForEval","SetNamedVariables","SetBlocks","InvokeComponentLayout","StdAppend","nonDynamicAppend","ContentType","when","String","AssertSame","AppendHTML","AppendText","InvokeBareComponent","InvokeStatic","SafeString","AppendSafeHTML","Fragment","AppendDocumentFragment","Node","AppendNode","compileStd","mainHandle","build","Main","trustingGuardedNonDynamicAppend","cautiousGuardedNonDynamicAppend","trustingGuardedDynamicAppend","cautiousGuardedDynamicAppend","STDLIB_META","builder","CompileTimeCompilationContextImpl","createOp","programCompilationContext","artifacts","templateCompilationContext","STATEMENTS","INFLATE_ATTR_TABLE","INFLATE_TAG_TABLE","inflateTagName","tagName","inflateAttrName","attrName","hashToArgs","hash","map","Comment","DynamicModifier","StaticAttr","namespace","StaticComponentAttr","DynamicAttr","TrustingDynamicAttr","ComponentAttr","TrustingComponentAttr","OpenElement","tag","OpenElementWithSplat","Yield","params","AttrSplat","Debugger","debugInfo","Append","DynamicContentType","Text","TrustingAppend","InElement","guid","destination","insertBefore","PushRemoteElement","PopRemoteElement","If","inverse","ToBoolean","Each","EnterList","Iterate","ExitList","Let","WithDynamicVars","expressions","BindDynamicScope","DynamicScope","compiled","statements","compileStatements","maybeCompile","syntaxContext","sCompiler","pushOp","statement","DEFAULT_CAPABILITIES","dynamicLayout","dynamicTag","attributeHook","elementHook","createCaller","updateHook","wrapped","willDestroy","hasSubOwner","MINIMAL_CAPABILITIES","WrappedBuilder","attrsBlockIndex","syntax","m","clientId","templateCacheCounters","cacheHit","cacheMiss","templateFactory","id","templateId","parsedBlock","ownerlessTemplate","templateCache","WeakMap","factory","JSON","parse","TemplateImpl","set","__id","__meta","wrappedLayout","parsedLayout","referrer","asLayout","asWrappedLayout"],"mappings":"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"}
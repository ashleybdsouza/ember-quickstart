import{assertNever as e,dict as t,expect as r,isPresentArray as n,values as s,assert as a,NS_XMLNS as o,NS_XML as l,NS_XLINK as i,exhausted as c,mapPresentArray as u,getLast as p,LOCAL_LOGGER as m,assertPresentArray as d}from"@glimmer/util";import{VariableResolutionContext as h,SexpOpcodes as f,WellKnownTagNames as k,WellKnownAttrNames as y}from"@glimmer/wire-format";import{node as g,KEYWORDS_TYPES as A,ASTv2 as w,isKeyword as v,generateSyntaxError as x,SourceSlice as b,src as E,maybeLoc as C,loc as B,normalize as S}from"@glimmer/syntax";import{CurriedTypes as O}from"@glimmer/vm";let H=function(e){return e.Block="Block",e.Call="Call",e.Element="Element",e.AppendPath="AppendPath",e.AppendExpr="AppendExpr",e.Literal="Literal",e.Modifier="Modifier",e.DynamicComponent="DynamicComponent",e.Comment="Comment",e.Splat="Splat",e.Keyword="Keyword",e}({}),T=function(e){return e.Local="Local",e.Free="Free",e.Arg="Arg",e.Block="Block",e.This="This",e}({});function P(n){if(Array.isArray(n))return function(e){if(!Array.isArray(e))return!1;const t=e[0];if("number"==typeof t)switch(t){case z.Literal:case z.Get:case z.Concat:case z.HasBlock:case z.HasBlockParams:return!0;default:return!1}if("("===t[0])return!0;return!1}(n)?W(n):function(e){if(Array.isArray(e)&&"string"==typeof e[0])switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(n)?function(e){const n=e[0];switch(n[0]){case"(":{let t=null,r=null;return 3===e.length?(t=J(e[1]),r=X(e[2])):2===e.length&&(Array.isArray(e[1])?t=J(e[1]):r=X(e[1])),{kind:H.Call,head:I(n),params:t,hash:r,trusted:!1}}case"#":{const{head:t,params:r,hash:n,blocks:s,blockParams:a}=D(e);return{kind:H.Block,head:t,params:r,hash:n,blocks:s,blockParams:a}}case"!":{const t=e[0].slice(1),{params:r,hash:n,blocks:s,blockParams:a}=D(e);return{kind:H.Keyword,name:t,params:r,hash:n,blocks:s,blockParams:a}}case"<":{let s=t(),a=[];return 3===e.length?(s=q(e[1]),a=_(e[2])):2===e.length&&(Array.isArray(e[1])?a=_(e[1]):s=q(e[1])),{kind:H.Element,name:r(j(n),`BUG: expected ${n} to look like a tag name`),attrs:s,block:a}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(n):function(e){switch(e[0]){case z.Literal:return{kind:H.Literal,value:e[1]};case z.Append:return W(e[1],e[2]);case z.Modifier:return{kind:H.Modifier,params:J(e[1]),hash:X(e[2])};case z.DynamicComponent:return{kind:H.DynamicComponent,expr:R(e[1]),hash:X(e[2]),block:_(e[3])};case z.Comment:return{kind:H.Comment,value:e[1]}}}(n);if("string"==typeof n)return N(G(n),!1);throw e(n)}function N(e,t){return e.type===U.GetPath?{kind:H.AppendPath,path:e,trusted:t}:{kind:H.AppendExpr,expr:e,trusted:t}}function L(e){const t=/^(#|!)(.*)$/u.exec(e);if(null===t)throw new Error("Unexpected missing # in block head");return G(t[2])}function I(e){const t=/^\((.*)\)$/u.exec(e);if(null===t)throw new Error("Unexpected missing () in call head");return G(t[1])}function $(e,t=[]){const r=M(e);return n(t)?{type:U.GetPath,path:{head:r,tail:t}}:{type:U.GetVar,variable:r}}function G(e){const{kind:t,name:r}=M(e),[s,...a]=r.split("."),o={kind:t,name:s,mode:"loose"};return n(a)?{type:U.GetPath,path:{head:o,tail:a}}:{type:U.GetVar,variable:o}}function M(e){let t,r;if(/^this(?:\.|$)/u.test(e))return{kind:T.This,name:e,mode:"loose"};switch(e[0]){case"^":t=T.Free,r=e.slice(1);break;case"@":t=T.Arg,r=e.slice(1);break;case"&":t=T.Block,r=e.slice(1);break;default:t=T.Local,r=e}return{kind:t,name:r,mode:"loose"}}function D(e){const r=e[0];let n=t(),s=null,a=null,o=null;return 2===e.length?n=F(e[1]):3===e.length?(Array.isArray(e[1])?s=J(e[1]):({hash:a,blockParams:o}=V(e[1])),n=F(e[2])):4===e.length&&(s=J(e[1]),({hash:a,blockParams:o}=V(e[2])),n=F(e[3])),{head:L(r),params:s,hash:a,blockParams:o,blocks:n}}function V(e){if(null===e)return{hash:null,blockParams:null};let r=null,n=null;return function(e,t){Object.keys(e).forEach((r=>{const n=e[r];t(r,n)}))}(e,((e,s)=>{"as"===e?n=Array.isArray(s)?s:[s]:(r=r||t(),r[e]=R(s))})),{hash:r,blockParams:n}}function F(e){return Array.isArray(e)?{default:_(e)}:K(e,_)}function _(e){return e.map((e=>P(e)))}function q(e){return K(e,(e=>function(e){if("splat"===e)return{expr:H.Splat,trusted:!1};return{expr:R(e),trusted:!1}}(e).expr))}function K(e,r){const n=t();return Object.keys(e).forEach((t=>{n[t]=r(e[t],t)})),n}function j(e){const t=/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(e);return t?.[1]??null}let z=function(e){return e[e.Literal=0]="Literal",e[e.Comment=1]="Comment",e[e.Append=2]="Append",e[e.Modifier=3]="Modifier",e[e.DynamicComponent=4]="DynamicComponent",e[e.Get=5]="Get",e[e.Concat=6]="Concat",e[e.HasBlock=7]="HasBlock",e[e.HasBlockParams=8]="HasBlockParams",e}({}),U=function(e){return e.Literal="Literal",e.Call="Call",e.GetPath="GetPath",e.GetVar="GetVar",e.Concat="Concat",e.HasBlock="HasBlock",e.HasBlockParams="HasBlockParams",e}({});function W(t,r=!1){if(null==t)return{expr:{type:U.Literal,value:t},kind:H.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case z.Literal:return{expr:{type:U.Literal,value:t[1]},kind:H.AppendExpr,trusted:!1};case z.Get:return N($(t[1],t[2]),r);case z.Concat:return{expr:{type:U.Concat,params:J(t.slice(1))},kind:H.AppendExpr,trusted:r};case z.HasBlock:return{expr:{type:U.HasBlock,name:t[1]},kind:H.AppendExpr,trusted:r};case z.HasBlockParams:return{expr:{type:U.HasBlockParams,name:t[1]},kind:H.AppendExpr,trusted:r};default:if(Y(t))return{expr:Z(t),kind:H.AppendExpr,trusted:r};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return N(G(t),r);case"boolean":case"number":return{expr:{type:U.Literal,value:t},kind:H.AppendExpr,trusted:!0};default:throw e(t)}}}function R(t){if(null==t)return{type:U.Literal,value:t};if(Array.isArray(t))switch(t[0]){case z.Literal:return{type:U.Literal,value:t[1]};case z.Get:return $(t[1],t[2]);case z.Concat:return{type:U.Concat,params:J(t.slice(1))};case z.HasBlock:return{type:U.HasBlock,name:t[1]};case z.HasBlockParams:return{type:U.HasBlockParams,name:t[1]};default:if(Y(t))return Z(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return G(t);case"boolean":case"number":return{type:U.Literal,value:t};default:throw e(t)}}}function Y(e){return"string"==typeof e[0]&&"("===e[0][0]}function J(e){return e.map(R)}function X(e){return null===e?null:K(e,R)}function Z(e){switch(e.length){case 1:return{type:U.Call,head:I(e[0]),params:null,hash:null};case 2:return Array.isArray(e[1])?{type:U.Call,head:I(e[0]),params:J(e[1]),hash:null}:{type:U.Call,head:I(e[0]),params:null,hash:X(e[1])};case 3:return{type:U.Call,head:I(e[0]),params:J(e[1]),hash:X(e[2])}}}class Q{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return te(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return te(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return te(this._symbols,e)}child(e){return new ee(this,e)}}class ee{locals=t();constructor(e,t){this.parent=e;for(let r of t)this.locals[r]=e.top.symbol(r)}get paramSymbols(){return s(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new ee(this,e)}}function te(e,t){let r=e.indexOf(t);return-1===r?(r=e.length,e.push(t),r):r}function re(e){return new Error(`unimplemented ${e}`)}function ne(e,t){let r=[];return e.forEach((e=>r.push(...ae(P(e),t)))),r}function se(e,t){let r=[];return e.forEach((e=>r.push(...ae(e,t)))),r}function ae(t,r=new Q){switch(t.kind){case H.AppendPath:return[[t.trusted?f.TrustingAppend:f.Append,ye(t.path,r)]];case H.AppendExpr:return[[t.trusted?f.TrustingAppend:f.Append,fe(t.expr,t.trusted?"TrustedAppend":"Append",r)]];case H.Call:{let{head:e,params:n,hash:s,trusted:a}=t,o=n?Ae(n,r):null,l=s?ve(s,r):null,i=ke(e,a?h.ResolveAsHelperHead:h.ResolveAsComponentOrHelperHead,r);return[[a?f.TrustingAppend:f.Append,[f.Call,i,o,l]]]}case H.Literal:return[[f.Append,t.value]];case H.Comment:return[[f.Comment,t.value]];case H.Block:{let e=function(e,t,r){let n=[],s=[];for(const[a,o]of Object.entries(e))if(n.push(a),"default"===a){let e=r.child(t||[]);s.push(xe(o,e,e.paramSymbols))}else s.push(xe(o,r,[]));return[n,s]}(t.blocks,t.blockParams,r),n=ve(t.hash,r),s=Ae(t.params,r),a=ke(t.head,h.ResolveAsComponentHead,r);return[[f.Block,a,s,n,e]]}case H.Keyword:return[ue(t,r)];case H.Element:return function({name:t,attrs:r,block:s},o){let l=[pe(r)?[f.OpenElementWithSplat,t]:[f.OpenElement,t]];if(r){let{params:e,args:t}=function(e,t){let r=[],s=[],a=[];for(const[n,o]of Object.entries(e))o===H.Splat?r.push([f.AttrSplat,t.block("&attrs")]):"@"===n[0]?(s.push(n),a.push(fe(o,"Strict",t))):r.push(...de(n,o,me(n),t));return{params:r,args:n(s)&&n(a)?[s,a]:null}}(r,o);l.push(...e),a(null===t,"Can't pass args to a simple element")}if(l.push([f.FlushElement]),Array.isArray(s))s.forEach((e=>l.push(...ae(e,o))));else if(null!==s)throw e(s);return l.push([f.CloseElement]),l}(t,r);case H.Modifier:throw re("modifier");case H.DynamicComponent:throw re("dynamic component");default:throw e(t)}}function oe(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[z.Literal,r]}function le(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[z.Comment,r]}function ie(e){return String.fromCharCode(parseInt(e,16))}const ce="\n";function ue(e,t){let{name:n}=e,s=Ae(e.params,t),a=t.child(e.blockParams||[]),o=xe(e.blocks.default,a,a.paramSymbols),l=e.blocks.else?xe(e.blocks.else,t,[]):null;switch(n){case"let":return[f.Let,r(s,"let requires params"),o];case"if":return[f.If,r(s,"if requires params")[0],o,l];case"each":{let n=e.hash?e.hash.key:null,a=n?fe(n,"Strict",t):null;return[f.Each,r(s,"if requires params")[0],a,o,l]}default:throw new Error("unimplemented keyword")}}function pe(e){return null!==e&&Object.keys(e).some((t=>e[t]===H.Splat))}function me(e){if("xmlns"===e)return o;let t=/^([^:]*):([^:]*)$/u.exec(e);if(null===t)return null;switch(t[1]){case"xlink":return i;case"xml":return l;case"xmlns":return o}return null}function de(e,t,r,n){if(t.type===U.Literal){let n=t.value;if(!1===n)return[];if(!0===n)return[[f.StaticAttr,e,"",r??void 0]];if("string"==typeof n)return[[f.StaticAttr,e,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[f.DynamicAttr,e,fe(t,"AttrValue",n),r??void 0]]}function he(e,t){switch(e){case"Append":return t?"AppendBare":"AppendInvoke";case"TrustedAppend":return t?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return t?"AttrValueBare":"AttrValueInvoke";default:return e}}function fe(t,r,n){switch(t.type){case U.GetPath:return ye(t,n);case U.GetVar:return ge(t.variable,he(r,!0),n);case U.Concat:return[f.Concat,we(t.params,n)];case U.Call:{let e=Ae(t.params,n),s=ve(t.hash,n),a=ke(t.head,"Strict"===r?"SubExpression":he(r,!1),n);return[f.Call,a,e,s]}case U.HasBlock:return[f.HasBlock,ge({kind:T.Block,name:t.name,mode:"loose"},h.Strict,n)];case U.HasBlockParams:return[f.HasBlockParams,ge({kind:T.Block,name:t.name,mode:"loose"},h.Strict,n)];case U.Literal:return void 0===t.value?[f.Undefined]:t.value;default:e(t)}}function ke(e,t,r){return e.type===U.GetVar?ge(e.variable,t,r):ye(e,r)}function ye(e,t){return ge(e.path.head,h.Strict,t,e.path.tail)}function ge(e,t,r,n){let s,o=f.GetSymbol;if(e.kind===T.Free)o="Strict"===t?f.GetStrictKeyword:"AppendBare"===t||"AppendInvoke"===t?f.GetFreeAsComponentOrHelperHead:"TrustedAppendBare"===t||"TrustedAppendInvoke"===t||"AttrValueBare"===t||"AttrValueInvoke"===t||"SubExpression"===t?f.GetFreeAsHelperHead:function(e){switch(e){case h.Strict:return f.GetStrictKeyword;case h.ResolveAsComponentOrHelperHead:return f.GetFreeAsComponentOrHelperHead;case h.ResolveAsHelperHead:return f.GetFreeAsHelperHead;case h.ResolveAsModifierHead:return f.GetFreeAsModifierHead;case h.ResolveAsComponentHead:return f.GetFreeAsComponentHead;default:return c(e)}}(t),s=r.freeVar(e.name);else o=f.GetSymbol,s=function(e,t,r){switch(e){case T.Arg:return t.arg(r);case T.Block:return t.block(r);case T.Local:return t.local(r);case T.This:return t.this();default:return c(e)}}(e.kind,r,e.name);return void 0===n||0===n.length?[o,s]:(a(o!==f.GetStrictKeyword,"[BUG] keyword with a path"),[o,s,n])}function Ae(e,t){return null!==e&&n(e)?e.map((e=>fe(e,"Strict",t))):null}function we(e,t){return e.map((e=>fe(e,"AttrValue",t)))}function ve(e,t){if(null===e)return null;let r=[[],[]];for(const[n,s]of Object.entries(e))r[0].push(n),r[1].push(fe(s,"Strict",t));return r}function xe(e,t,r=[]){return[se(e,t),r]}const be=!("undefined"==typeof window||!window.location||!/[&?]enable_local_should_log/u.test(window.location.search));class Ee extends(g("Template").fields()){}class Ce extends(g("InElement").fields()){}class Be extends(g("Not").fields()){}class Se extends(g("If").fields()){}class Oe extends(g("IfInline").fields()){}class He extends(g("Each").fields()){}class Te extends(g("Let").fields()){}class Pe extends(g("WithDynamicVars").fields()){}class Ne extends(g("GetDynamicVar").fields()){}class Le extends(g("Log").fields()){}class Ie extends(g("InvokeComponent").fields()){}class $e extends(g("NamedBlocks").fields()){}class Ge extends(g("NamedBlock").fields()){}class Me extends(g("AppendTrustedHTML").fields()){}class De extends(g("AppendTextNode").fields()){}class Ve extends(g("AppendComment").fields()){}class Fe extends(g("Component").fields()){}class _e extends(g("StaticAttr").fields()){}class qe extends(g("DynamicAttr").fields()){}class Ke extends(g("SimpleElement").fields()){}class je extends(g("ElementParameters").fields()){}class ze extends(g("Yield").fields()){}class Ue extends(g("Debugger").fields()){}class We extends(g("CallExpression").fields()){}class Re extends(g("Modifier").fields()){}class Ye extends(g("InvokeBlock").fields()){}class Je extends(g("SplatAttr").fields()){}class Xe extends(g("PathExpression").fields()){}class Ze extends(g("Missing").fields()){}class Qe extends(g("InterpolateExpression").fields()){}class et extends(g("HasBlock").fields()){}class tt extends(g("HasBlockParams").fields()){}class rt extends(g("Curry").fields()){}class nt extends(g("Positional").fields()){}class st extends(g("NamedArguments").fields()){}class at extends(g("NamedArgument").fields()){}class ot extends(g("Args").fields()){}class lt extends(g("Tail").fields()){}class it{constructor(e){this.list=e}toArray(){return this.list}map(e){let t=u(this.list,e);return new it(t)}filter(e){let t=[];for(let r of this.list)e(r)&&t.push(r);return ut(t)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class ct{list=[];map(e){return new ct}filter(e){return new ct}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function ut(e){return n(e)?new it(e):new ct}class pt{static all(...e){let t=[];for(let r of e){if(r.isErr)return r.cast();t.push(r.value)}return ft(t)}}const mt=pt;class dt extends pt{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return ft(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class ht extends pt{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return kt(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function ft(e){return new dt(e)}function kt(e){return new ht(e)}class yt{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter((e=>e instanceof ht))[0];return void 0!==e?e.cast():ft(this.items.map((e=>e.value)))}toOptionalList(){return this.toArray().mapOk((e=>ut(e)))}}function gt(e){return"Path"===e.type&&"Free"===e.ref.type&&e.ref.name in A?new w.CallExpression({callee:e,args:w.Args.empty(e.loc),loc:e.loc}):e}const At=new class{visit(e,t){switch(e.type){case"Literal":return ft(this.Literal(e));case"Keyword":return ft(this.Keyword(e));case"Interpolate":return this.Interpolate(e,t);case"Path":return this.PathExpression(e);case"Call":{let r=_t.translate(e,t);return null!==r?r:this.CallExpression(e,t)}}}visitList(e,t){return new yt(e.map((e=>At.visit(e,t)))).toOptionalList()}PathExpression(e){let t=this.VariableReference(e.ref),{tail:r}=e;if(n(r)){let n=r[0].loc.extend(p(r).loc);return ft(new Xe({loc:e.loc,head:t,tail:new lt({loc:n,members:r})}))}return ft(t)}VariableReference(e){return e}Literal(e){return e}Keyword(e){return e}Interpolate(e,t){let r=e.parts.map(gt);return At.visitList(r,t).mapOk((t=>new Qe({loc:e.loc,parts:t})))}CallExpression(e,t){if("Call"===e.callee.type)throw new Error("unimplemented: subexpression at the head of a subexpression");return mt.all(At.visit(e.callee,t),At.Args(e.args,t)).mapOk((([t,r])=>new We({loc:e.loc,callee:t,args:r})))}Args({positional:e,named:t,loc:r},n){return mt.all(this.Positional(e,n),this.NamedArguments(t,n)).mapOk((([e,t])=>new ot({loc:r,positional:e,named:t})))}Positional(e,t){return At.visitList(e.exprs,t).mapOk((t=>new nt({loc:e.loc,list:t})))}NamedArguments(e,t){let r=e.entries.map((e=>{let r=gt(e.value);return At.visit(r,t).mapOk((t=>new at({loc:e.loc,key:e.name,value:t})))}));return new yt(r).toOptionalList().mapOk((t=>new st({loc:e.loc,entries:t})))}};class wt{types;constructor(e,t,r){this.keyword=e,this.delegate=r;let n=new Set;for(let e of vt[t])n.add(e);this.types=n}match(e){if(!this.types.has(e.type))return!1;let t=xt(e);return null!==t&&"Path"===t.type&&"Free"===t.ref.type&&t.ref.name===this.keyword}translate(e,t){if(this.match(e)){let r=xt(e);return null!==r&&"Path"===r.type&&r.tail.length>0?kt(x(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${r.loc.asString()}\`, but it cannot be used with additional path segments. \n\nError caused by`,e.loc)):this.delegate.assert(e,t).andThen((r=>this.delegate.translate({node:e,state:t},r)))}return null}}const vt={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function xt(e){switch(e.type){case"Path":return e;case"AppendContent":return xt(e.value);case"Call":case"InvokeBlock":case"ElementModifier":return e.callee;default:return null}}class bt{_keywords=[];_type;constructor(e){this._type=e}kw(e,t){return this._keywords.push(function(e,t,r){return new wt(e,t,r)}(e,this._type,t)),this}translate(e,t){for(let r of this._keywords){let n=r.translate(e,t);if(null!==n)return n}let r=xt(e);if(r&&"Path"===r.type&&"Free"===r.ref.type&&v(r.ref.name)){let{name:t}=r.ref,n=this._type,s=A[t];if(!s.includes(n))return kt(x(`The \`${t}\` keyword was used incorrectly. It was used as ${Et[n]}, but its valid usages are:\n\n${function(e,t){return t.map((t=>{switch(t){case"Append":return`- As an append statement, as in: {{${e}}}`;case"Block":return`- As a block statement, as in: {{#${e}}}{{/${e}}}`;case"Call":return`- As an expression, as in: (${e})`;case"Modifier":return`- As a modifier, as in: <div {{${e}}}></div>`;default:return c(t)}})).join("\n\n")}(t,s)}\n\nError caused by`,e.loc))}return null}}const Et={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function Ct(e){return new bt(e)}function Bt({assert:e,translate:t}){return{assert:e,translate:({node:e,state:r},n)=>t({node:e,state:r},n).mapOk((t=>new De({text:t,loc:e.loc})))}}const St={[O.Component]:"component",[O.Helper]:"helper",[O.Modifier]:"modifier"};function Ot(e){return(t,r)=>{let n=St[e],s=e===O.Component,{args:a}=t,o=a.nth(0);if(null===o)return kt(x(`(${n}) requires a ${n} definition or identifier as its first positional parameter, did not receive any parameters.`,a.loc));if("Literal"===o.type){if(s&&r.isStrict)return kt(x(`(${n}) cannot resolve string values in strict mode templates`,t.loc));if(!s)return kt(x(`(${n}) cannot resolve string values, you must pass a ${n} definition directly`,t.loc))}return a=new w.Args({positional:new w.PositionalArguments({exprs:a.positional.exprs.slice(1),loc:a.positional.loc}),named:a.named,loc:a.loc}),ft({definition:o,args:a})}}function Ht(e){return({node:t,state:r},{definition:n,args:s})=>{let a=At.visit(n,r),o=At.Args(s,r);return mt.all(a,o).mapOk((([r,n])=>new rt({loc:t.loc,curriedType:e,definition:r,args:n})))}}function Tt(e){return{assert:Ot(e),translate:Ht(e)}}const Pt={assert:function(e){let t="AppendContent"===e.type?e.value:e,r="Call"===t.type?t.args.named:null,n="Call"===t.type?t.args.positional:null;if(r&&!r.isEmpty())return kt(x("(-get-dynamic-vars) does not take any named arguments",e.loc));let s=n?.nth(0);return s?n&&n.size>1?kt(x("(-get-dynamic-vars) only receives one positional arg",e.loc)):ft(s):kt(x("(-get-dynamic-vars) requires a var name to get",e.loc))},translate:function({node:e,state:t},r){return At.visit(r,t).mapOk((t=>new Ne({name:t,loc:e.loc})))}};function Nt(e){return t=>{let r="AppendContent"===t.type?t.value:t,n="Call"===r.type?r.args.named:null,s="Call"===r.type?r.args.positional:null;if(n&&!n.isEmpty())return kt(x(`(${e}) does not take any named arguments`,r.loc));if(!s||s.isEmpty())return ft(b.synthetic("default"));if(1===s.exprs.length){let t=s.exprs[0];return w.isLiteral(t,"string")?ft(t.toSlice()):kt(x(`(${e}) can only receive a string literal as its first argument`,r.loc))}return kt(x(`(${e}) only takes a single positional argument`,r.loc))}}function Lt(e){return({node:t,state:{scope:r}},n)=>ft("has-block"===e?new et({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}):new tt({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}))}function It(e){return{assert:Nt(e),translate:Lt(e)}}function $t(e){return t=>{let r="unless"===e,n="AppendContent"===t.type?t.value:t,s="Call"===n.type?n.args.named:null,a="Call"===n.type?n.args.positional:null;if(s&&!s.isEmpty())return kt(x(`(${e}) cannot receive named parameters, received ${s.entries.map((e=>e.name.chars)).join(", ")}`,t.loc));let o=a?.nth(0);if(!a||!o)return kt(x(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,t.loc));let l=a.nth(1),i=a.nth(2);return null===l?kt(x(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,t.loc)):a.size>3?kt(x(`When used inline, (${e}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${e}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${a?.size??0} parameters`,t.loc)):ft({condition:o,truthy:l,falsy:i})}}function Gt(e){let t="unless"===e;return({node:e,state:r},{condition:n,truthy:s,falsy:a})=>{let o=At.visit(n,r),l=At.visit(s,r),i=a?At.visit(a,r):ft(null);return mt.all(o,l,i).mapOk((([r,n,s])=>(t&&(r=new Be({value:r,loc:e.loc})),new Oe({loc:e.loc,condition:r,truthy:n,falsy:s}))))}}function Mt(e){return{assert:$t(e),translate:Gt(e)}}const Dt={assert:function(e){let{args:{named:t,positional:r}}=e;return t&&!t.isEmpty()?kt(x("(log) does not take any named arguments",e.loc)):ft(r)},translate:function({node:e,state:t},r){return At.Positional(r,t).mapOk((t=>new Le({positional:t,loc:e.loc})))}},Vt=Ct("Append").kw("has-block",Bt(It("has-block"))).kw("has-block-params",Bt(It("has-block-params"))).kw("-get-dynamic-var",Bt(Pt)).kw("log",Bt(Dt)).kw("if",Bt(Mt("if"))).kw("unless",Bt(Mt("unless"))).kw("yield",{assert(e){let{args:t}=e;if(t.named.isEmpty())return ft({target:E.SourceSpan.synthetic("default").toSlice(),positional:t.positional});{let e=t.named.get("to");return t.named.size>1||null===e?kt(x("yield only takes a single named argument: 'to'",t.named.loc)):w.isLiteral(e,"string")?ft({target:e.toSlice(),positional:t.positional}):kt(x("you can only yield to a literal string value",e.loc))}},translate:({node:e,state:t},{target:r,positional:n})=>At.Positional(n,t).mapOk((n=>new ze({loc:e.loc,target:r,to:t.scope.allocateBlock(r.chars),positional:n})))}).kw("debugger",{assert(e){let{args:t}=e,{positional:r}=t;return t.isEmpty()?ft(void 0):r.isEmpty()?kt(x("debugger does not take any named arguments",e.loc)):kt(x("debugger does not take any positional arguments",e.loc))},translate:({node:e,state:{scope:t}})=>(t.setHasDebugger(),ft(new Ue({loc:e.loc,scope:t})))}).kw("component",{assert:Ot(O.Component),translate({node:e,state:t},{definition:r,args:n}){let s=At.visit(r,t),a=At.Args(n,t);return mt.all(s,a).mapOk((([t,r])=>new Ie({loc:e.loc,definition:t,args:r,blocks:null})))}}).kw("helper",{assert:Ot(O.Helper),translate({node:e,state:t},{definition:r,args:n}){let s=At.visit(r,t),a=At.Args(n,t);return mt.all(s,a).mapOk((([t,r])=>{let n=new We({callee:t,args:r,loc:e.loc});return new De({loc:e.loc,text:n})}))}}),Ft=Ct("Block").kw("in-element",{assert(e){let{args:t}=e,r=t.get("guid");if(r)return kt(x("Cannot pass `guid` to `{{#in-element}}`",r.loc));let n=t.get("insertBefore"),s=t.nth(0);return null===s?kt(x("{{#in-element}} requires a target element as its first positional parameter",t.loc)):ft({insertBefore:n,destination:s})},translate({node:e,state:t},{insertBefore:r,destination:n}){let s=e.blocks.get("default"),a=nr.NamedBlock(s,t),o=At.visit(n,t);return mt.all(a,o).andThen((([n,s])=>r?At.visit(r,t).mapOk((e=>({body:n,destination:s,insertBefore:e}))):ft({body:n,destination:s,insertBefore:new Ze({loc:e.callee.loc.collapse("end")})}))).mapOk((({body:r,destination:n,insertBefore:s})=>new Ce({loc:e.loc,block:r,insertBefore:s,guid:t.generateUniqueCursor(),destination:n})))}}).kw("if",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return kt(x(`{{#if}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return kt(x(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?kt(x("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):ft({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),s=e.blocks.get("else"),a=At.visit(r,t),o=nr.NamedBlock(n,t),l=s?nr.NamedBlock(s,t):ft(null);return mt.all(a,o,l).mapOk((([t,r,n])=>new Se({loc:e.loc,condition:t,block:r,inverse:n})))}}).kw("unless",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return kt(x(`{{#unless}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return kt(x(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?kt(x("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):ft({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),s=e.blocks.get("else"),a=At.visit(r,t),o=nr.NamedBlock(n,t),l=s?nr.NamedBlock(s,t):ft(null);return mt.all(a,o,l).mapOk((([t,r,n])=>new Se({loc:e.loc,condition:new Be({value:t,loc:e.loc}),block:r,inverse:n})))}}).kw("each",{assert(e){let{args:t}=e;if(!t.named.entries.every((e=>"key"===e.name.chars)))return kt(x(`{{#each}} can only receive the 'key' named parameter, received ${t.named.entries.filter((e=>"key"!==e.name.chars)).map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return kt(x(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0),n=t.get("key");return null===r?kt(x("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",t.loc)):ft({value:r,key:n})},translate({node:e,state:t},{value:r,key:n}){let s=e.blocks.get("default"),a=e.blocks.get("else"),o=At.visit(r,t),l=n?At.visit(n,t):ft(null),i=nr.NamedBlock(s,t),c=a?nr.NamedBlock(a,t):ft(null);return mt.all(o,l,i,c).mapOk((([t,r,n,s])=>new He({loc:e.loc,value:t,key:r,block:n,inverse:s})))}}).kw("let",{assert(e){let{args:t}=e;return t.named.isEmpty()?0===t.positional.size?kt(x("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",t.positional.loc)):e.blocks.get("else")?kt(x("{{#let}} cannot receive an {{else}} block",t.positional.loc)):ft({positional:t.positional}):kt(x(`{{#let}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc))},translate({node:e,state:t},{positional:r}){let n=e.blocks.get("default"),s=At.Positional(r,t),a=nr.NamedBlock(n,t);return mt.all(s,a).mapOk((([t,r])=>new Te({loc:e.loc,positional:t,block:r})))}}).kw("-with-dynamic-vars",{assert:e=>ft({named:e.args.named}),translate({node:e,state:t},{named:r}){let n=e.blocks.get("default"),s=At.NamedArguments(r,t),a=nr.NamedBlock(n,t);return mt.all(s,a).mapOk((([t,r])=>new Pe({loc:e.loc,named:t,block:r})))}}).kw("component",{assert:Ot(O.Component),translate({node:e,state:t},{definition:r,args:n}){let s=At.visit(r,t),a=At.Args(n,t),o=nr.NamedBlocks(e.blocks,t);return mt.all(s,a,o).mapOk((([t,r,n])=>new Ie({loc:e.loc,definition:t,args:r,blocks:n})))}}),_t=Ct("Call").kw("has-block",It("has-block")).kw("has-block-params",It("has-block-params")).kw("-get-dynamic-var",Pt).kw("log",Dt).kw("if",Mt("if")).kw("unless",Mt("unless")).kw("component",Tt(O.Component)).kw("helper",Tt(O.Helper)).kw("modifier",Tt(O.Modifier)),qt=Ct("Modifier"),Kt="http://www.w3.org/1999/xlink",jt="http://www.w3.org/XML/1998/namespace",zt="http://www.w3.org/2000/xmlns/",Ut={"xlink:actuate":Kt,"xlink:arcrole":Kt,"xlink:href":Kt,"xlink:role":Kt,"xlink:show":Kt,"xlink:title":Kt,"xlink:type":Kt,"xml:base":jt,"xml:lang":jt,"xml:space":jt,xmlns:zt,"xmlns:xlink":zt};const Wt={div:k.div,span:k.span,p:k.p,a:k.a},Rt=["div","span","p","a"];function Yt(e){return"string"==typeof e?e:Rt[e]}const Jt={class:y.class,id:y.id,value:y.value,name:y.name,type:y.type,style:y.style,href:y.href},Xt=["class","id","value","name","type","style","href"];function Zt(e){return Jt[e]??e}function Qt(e){return"string"==typeof e?e:Xt[e]}class er{delegate;constructor(e,t,r){this.element=e,this.state=r,this.delegate=t}toStatement(){return this.prepare().andThen((e=>this.delegate.toStatement(this,e)))}attr(e){let t=e.name,r=e.value,n=(s=t.chars,Ut[s]||void 0);var s;return w.isLiteral(r,"string")?ft(new _e({loc:e.loc,name:t,value:r.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):At.visit(gt(r),this.state).mapOk((r=>{let s=e.trusting;return new qe({loc:e.loc,name:t,value:r,namespace:n,kind:{trusting:s,component:this.delegate.dynamicFeatures}})}))}modifier(e){let t=qt.translate(e,this.state);if(null!==t)return t;let r=At.visit(e.callee,this.state),n=At.Args(e.args,this.state);return mt.all(r,n).mapOk((([t,r])=>new Re({loc:e.loc,callee:t,args:r})))}attrs(){let e=new yt,t=new yt,r=null,n=0===this.element.attrs.filter((e=>"SplatAttr"===e.type)).length;for(let t of this.element.attrs)"SplatAttr"===t.type?e.add(ft(new Je({loc:t.loc,symbol:this.state.scope.allocateBlock("attrs")}))):"type"===t.name.chars&&n?r=t:e.add(this.attr(t));for(let e of this.element.componentArgs)t.add(this.delegate.arg(e,this));return r&&e.add(this.attr(r)),mt.all(t.toArray(),e.toArray()).mapOk((([e,t])=>({attrs:t,args:new st({loc:C(e,E.SourceSpan.NON_EXISTENT),entries:ut(e)})})))}prepare(){let e=this.attrs(),t=new yt(this.element.modifiers.map((e=>this.modifier(e)))).toArray();return mt.all(e,t).mapOk((([e,t])=>{let{attrs:r,args:n}=e,s=[...r,...t];return{args:n,params:new je({loc:C(s,E.SourceSpan.NON_EXISTENT),body:ut(s)})}}))}}class tr{dynamicFeatures=!0;constructor(e,t){this.tag=e,this.element=t}arg(e,{state:t}){let r=e.name;return At.visit(gt(e.value),t).mapOk((t=>new at({loc:e.loc,key:r,value:t})))}toStatement(e,{args:t,params:r}){let{element:n,state:s}=e;return this.blocks(s).mapOk((e=>new Fe({loc:n.loc,tag:this.tag,params:r,args:t,blocks:e})))}blocks(e){return nr.NamedBlocks(this.element.blocks,e)}}class rr{constructor(e,t,r){this.tag=e,this.element=t,this.dynamicFeatures=r}isComponent=!1;arg(e){return kt(x(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:t}){let{state:r,element:n}=e;return nr.visitList(this.element.body,r).mapOk((e=>new Ke({loc:n.loc,tag:this.tag,params:t,body:e.toArray(),dynamicFeatures:this.dynamicFeatures})))}}const nr=new class{visitList(e,t){return new yt(e.map((e=>nr.visit(e,t)))).toOptionalList().mapOk((e=>e.filter((e=>null!==e))))}visit(e,t){switch(e.type){case"GlimmerComment":return ft(null);case"AppendContent":return this.AppendContent(e,t);case"HtmlText":return ft(this.TextNode(e));case"HtmlComment":return ft(this.HtmlComment(e));case"InvokeBlock":return this.InvokeBlock(e,t);case"InvokeComponent":return this.Component(e,t);case"SimpleElement":return this.SimpleElement(e,t)}}InvokeBlock(e,t){let r=Ft.translate(e,t);if(null!==r)return r;let n=At.visit(e.callee,t),s=At.Args(e.args,t);return mt.all(n,s).andThen((([r,n])=>this.NamedBlocks(e.blocks,t).mapOk((t=>new Ye({loc:e.loc,head:r,args:n,blocks:t})))))}NamedBlocks(e,t){return new yt(e.blocks.map((e=>this.NamedBlock(e,t)))).toArray().mapOk((t=>new $e({loc:e.loc,blocks:ut(t)})))}NamedBlock(e,t){return t.visitBlock(e.block).mapOk((t=>new Ge({loc:e.loc,name:e.name,body:t.toArray(),scope:e.block.scope})))}SimpleElement(e,t){return new er(e,new rr(e.tag,e,function({attrs:e,modifiers:t}){return t.length>0||!!e.filter((e=>"SplatAttr"===e.type))[0]}(e)),t).toStatement()}Component(e,t){return At.visit(e.callee,t).andThen((r=>new er(e,new tr(r,e),t).toStatement()))}AppendContent(e,t){let r=Vt.translate(e,t);return null!==r?r:At.visit(e.value,t).mapOk((t=>e.trusting?new Me({loc:e.loc,html:t}):new De({loc:e.loc,text:t})))}TextNode(e){return new De({loc:e.loc,text:new w.LiteralExpression({loc:e.loc,value:e.chars})})}HtmlComment(e){return new Ve({loc:e.loc,value:e.text})}};class sr{_currentScope;_cursorCount=0;constructor(e,t){this.isStrict=t,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let t=this._currentScope;this._currentScope=e.scope;try{return nr.visitList(e.body,this)}finally{this._currentScope=t}}}var ar=function(e){return e.Value="value",e.Component="component",e.Helper="helper",e.Modifier="modifier",e.ComponentOrHelper="component or helper",e}(ar||{});class or{static validate(e){return new this(e).validate()}constructor(e){this.template=e}validate(){return this.Statements(this.template.body).mapOk((()=>this.template))}Statements(e){let t=ft(null);for(let r of e)t=t.andThen((()=>this.Statement(r)));return t}NamedBlocks({blocks:e}){let t=ft(null);for(let r of e.toArray())t=t.andThen((()=>this.NamedBlock(r)));return t}NamedBlock(e){return this.Statements(e.body)}Statement(e){switch(e.type){case"InElement":return this.InElement(e);case"Debugger":case"AppendComment":return ft(null);case"Yield":return this.Yield(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"AppendTextNode":return this.AppendTextNode(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e)}}Expressions(e){let t=ft(null);for(let r of e)t=t.andThen((()=>this.Expression(r)));return t}Expression(e,t=e,r){switch(e.type){case"Literal":case"Keyword":case"Missing":case"This":case"Arg":case"Local":case"HasBlock":case"HasBlockParams":case"GetDynamicVar":return ft(null);case"PathExpression":return this.Expression(e.head,t,r);case"Free":return this.errorFor(e.name,t,r);case"InterpolateExpression":return this.InterpolateExpression(e,t,r);case"CallExpression":return this.CallExpression(e,t,r??ar.Helper);case"Not":return this.Expression(e.value,t,r);case"IfInline":return this.IfInline(e);case"Curry":return this.Curry(e);case"Log":return this.Log(e)}}Args(e){return this.Positional(e.positional).andThen((()=>this.NamedArguments(e.named)))}Positional(e,t){let r=ft(null),n=e.list.toArray();return r=1===n.length?this.Expression(n[0],t):this.Expressions(n),r}NamedArguments({entries:e}){let t=ft(null);for(let r of e.toArray())t=t.andThen((()=>this.NamedArgument(r)));return t}NamedArgument(e){return"CallExpression"===e.value.type?this.Expression(e.value,e,ar.Helper):this.Expression(e.value,e)}ElementParameters({body:e}){let t=ft(null);for(let r of e.toArray())t=t.andThen((()=>this.ElementParameter(r)));return t}ElementParameter(e){switch(e.type){case"StaticAttr":case"SplatAttr":return ft(null);case"DynamicAttr":return this.DynamicAttr(e);case"Modifier":return this.Modifier(e)}}DynamicAttr(e){return"CallExpression"===e.value.type?this.Expression(e.value,e,ar.Helper):this.Expression(e.value,e)}Modifier(e){return this.Expression(e.callee,e,ar.Modifier).andThen((()=>this.Args(e.args)))}InElement(e){return this.Expression(e.destination).andThen((()=>this.Expression(e.insertBefore))).andThen((()=>this.NamedBlock(e.block)))}Yield(e){return this.Positional(e.positional,e)}AppendTrustedHTML(e){return this.Expression(e.html,e)}AppendTextNode(e){return"CallExpression"===e.text.type?this.Expression(e.text,e,ar.ComponentOrHelper):this.Expression(e.text,e)}Component(e){return this.Expression(e.tag,e,ar.Component).andThen((()=>this.ElementParameters(e.params))).andThen((()=>this.NamedArguments(e.args))).andThen((()=>this.NamedBlocks(e.blocks)))}SimpleElement(e){return this.ElementParameters(e.params).andThen((()=>this.Statements(e.body)))}InvokeBlock(e){return this.Expression(e.head,e.head,ar.Component).andThen((()=>this.Args(e.args))).andThen((()=>this.NamedBlocks(e.blocks)))}If(e){return this.Expression(e.condition,e).andThen((()=>this.NamedBlock(e.block))).andThen((()=>e.inverse?this.NamedBlock(e.inverse):ft(null)))}Each(e){return this.Expression(e.value,e).andThen((()=>e.key?this.Expression(e.key,e):ft(null))).andThen((()=>this.NamedBlock(e.block))).andThen((()=>e.inverse?this.NamedBlock(e.inverse):ft(null)))}Let(e){return this.Positional(e.positional).andThen((()=>this.NamedBlock(e.block)))}WithDynamicVars(e){return this.NamedArguments(e.named).andThen((()=>this.NamedBlock(e.block)))}InvokeComponent(e){return this.Expression(e.definition,e,ar.Component).andThen((()=>this.Args(e.args))).andThen((()=>e.blocks?this.NamedBlocks(e.blocks):ft(null)))}InterpolateExpression(e,t,r){let n=e.parts.toArray();return 1===n.length?this.Expression(n[0],t,r):this.Expressions(n)}CallExpression(e,t,r){return this.Expression(e.callee,t,r).andThen((()=>this.Args(e.args)))}IfInline(e){return this.Expression(e.condition).andThen((()=>this.Expression(e.truthy))).andThen((()=>e.falsy?this.Expression(e.falsy):ft(null)))}Curry(e){let t;return t=e.curriedType===O.Component?ar.Component:e.curriedType===O.Helper?ar.Helper:ar.Modifier,this.Expression(e.definition,e,t).andThen((()=>this.Args(e.args)))}Log(e){return this.Positional(e.positional,e)}errorFor(e,t,r=ar.Value){return kt(x(`Attempted to resolve a ${r} in a strict mode template, but that value was not in scope: ${e}`,B(t)))}}class lr{upvars;symbols;constructor([e,t,r,n]){this.upvars=n,this.symbols=t}format(e){let t=[];for(let r of e[0])t.push(this.formatOpcode(r));return t}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case f.Append:return["append",this.formatOpcode(e[1])];case f.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case f.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case f.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case f.OpenElement:return["open-element",Yt(e[1])];case f.OpenElementWithSplat:return["open-element-with-splat",Yt(e[1])];case f.CloseElement:return["close-element"];case f.FlushElement:return["flush-element"];case f.StaticAttr:return["static-attr",Qt(e[1]),e[2],e[3]];case f.StaticComponentAttr:return["static-component-attr",Qt(e[1]),e[2],e[3]];case f.DynamicAttr:return["dynamic-attr",Qt(e[1]),this.formatOpcode(e[2]),e[3]];case f.ComponentAttr:return["component-attr",Qt(e[1]),this.formatOpcode(e[2]),e[3]];case f.AttrSplat:return["attr-splat"];case f.Yield:return["yield",e[1],this.formatParams(e[2])];case f.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case f.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case f.TrustingDynamicAttr:return["trusting-dynamic-attr",Qt(e[1]),this.formatOpcode(e[2]),e[3]];case f.TrustingComponentAttr:return["trusting-component-attr",Qt(e[1]),this.formatOpcode(e[2]),e[3]];case f.Debugger:return["debugger",e[1]];case f.Comment:return["comment",e[1]];case f.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case f.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case f.HasBlock:return["has-block",this.formatOpcode(e[1])];case f.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case f.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case f.Undefined:return["undefined"];case f.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case f.Concat:return["concat",this.formatParams(e[1])];case f.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]]];case f.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case f.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case f.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case f.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case f.GetSymbol:return 0===e[1]?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case f.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case f.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case f.IfInline:return["if-inline"];case f.Not:return["not"];case f.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case f.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case f.Log:return["log",this.formatParams(e[1])];case f.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case f.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case f.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case O.Component:return"component";case O.Helper:return"helper";case O.Modifier:return"modifier";default:throw c(e)}}formatElementParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatHash(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatOpcode(e[1][n]),t)),t())}formatBlocks(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatBlock(e[1][n]),t)),t())}formatBlock(e){return{statements:e[0].map((e=>this.formatOpcode(e))),parameters:e[1]}}}const ir=new class{expr(e){switch(e.type){case"Missing":return;case"Literal":return this.Literal(e);case"Keyword":return this.Keyword(e);case"CallExpression":return this.CallExpression(e);case"PathExpression":return this.PathExpression(e);case"Arg":return[f.GetSymbol,e.symbol];case"Local":return this.Local(e);case"This":return[f.GetSymbol,0];case"Free":return[e.resolution.resolution(),e.symbol];case"HasBlock":return this.HasBlock(e);case"HasBlockParams":return this.HasBlockParams(e);case"Curry":return this.Curry(e);case"Not":return this.Not(e);case"IfInline":return this.IfInline(e);case"InterpolateExpression":return this.InterpolateExpression(e);case"GetDynamicVar":return this.GetDynamicVar(e);case"Log":return this.Log(e)}}Literal({value:e}){return void 0===e?[f.Undefined]:e}Missing(){}HasBlock({symbol:e}){return[f.HasBlock,[f.GetSymbol,e]]}HasBlockParams({symbol:e}){return[f.HasBlockParams,[f.GetSymbol,e]]}Curry({definition:e,curriedType:t,args:r}){return[f.Curry,ir.expr(e),t,ir.Positional(r.positional),ir.NamedArguments(r.named)]}Local({isTemplateLocal:e,symbol:t}){return[e?f.GetLexicalSymbol:f.GetSymbol,t]}Keyword({symbol:e}){return[f.GetStrictKeyword,e]}PathExpression({head:e,tail:t}){let r=ir.expr(e);return a(r[0]!==f.GetStrictKeyword,"[BUG] keyword in a PathExpression"),[...r,ir.Tail(t)]}InterpolateExpression({parts:e}){return[f.Concat,e.map((e=>ir.expr(e))).toArray()]}CallExpression({callee:e,args:t}){return[f.Call,ir.expr(e),...ir.Args(t)]}Tail({members:e}){return u(e,(e=>e.chars))}Args({positional:e,named:t}){return[this.Positional(e),this.NamedArguments(t)]}Positional({list:e}){return e.map((e=>ir.expr(e))).toPresentArray()}NamedArgument({key:e,value:t}){return[e.chars,ir.expr(t)]}NamedArguments({entries:e}){let t=e.toArray();if(n(t)){let e=[],r=[];for(let n of t){let[t,s]=ir.NamedArgument(n);e.push(t),r.push(s)}return d(e),d(r),[e,r]}return null}Not({value:e}){return[f.Not,ir.expr(e)]}IfInline({condition:e,truthy:t,falsy:r}){let n=[f.IfInline,ir.expr(e),ir.expr(t)];return r&&n.push(ir.expr(r)),n}GetDynamicVar({name:e}){return[f.GetDynamicVar,ir.expr(e)]}Log({positional:e}){return[f.Log,this.Positional(e)]}};class cr{constructor(e){this.statements=e}toArray(){return this.statements}}const ur=new class{list(e){let t=[];for(let r of e){let e=ur.content(r);e&&e instanceof cr?t.push(...e.toArray()):t.push(e)}return t}content(e){return be&&m.log("encoding",e),this.visitContent(e)}visitContent(e){switch(e.type){case"Debugger":return[f.Debugger,e.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(e);case"AppendTextNode":return this.AppendTextNode(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"Yield":return this.Yield(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InElement":return this.InElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e);default:return c(e)}}Yield({to:e,positional:t}){return[f.Yield,e,ir.Positional(t)]}InElement({guid:e,insertBefore:t,destination:r,block:n}){let s=ur.NamedBlock(n)[1],a=ir.expr(r),o=ir.expr(t);return void 0===o?[f.InElement,s,e,a]:[f.InElement,s,e,a,o]}InvokeBlock({head:e,args:t,blocks:r}){return[f.Block,ir.expr(e),...ir.Args(t),ur.NamedBlocks(r)]}AppendTrustedHTML({html:e}){return[f.TrustingAppend,ir.expr(e)]}AppendTextNode({text:e}){return[f.Append,ir.expr(e)]}AppendComment({value:e}){return[f.Comment,e.chars]}SimpleElement({tag:e,params:t,body:r,dynamicFeatures:n}){let s=n?f.OpenElementWithSplat:f.OpenElement;return new cr([[s,(a=e.chars,Wt[a]??a)],...ur.ElementParameters(t).toArray(),[f.FlushElement],...ur.list(r),[f.CloseElement]]);var a}Component({tag:e,params:t,args:r,blocks:n}){let s=ir.expr(e),a=ur.ElementParameters(t),o=ir.NamedArguments(r),l=ur.NamedBlocks(n);return[f.Component,s,a.toPresentArray(),o,l]}ElementParameters({body:e}){return e.map((e=>ur.ElementParameter(e)))}ElementParameter(e){switch(e.type){case"SplatAttr":return[f.AttrSplat,e.symbol];case"DynamicAttr":return[hr(e.kind),...mr(e)];case"StaticAttr":return[dr(e.kind),...pr(e)];case"Modifier":return[f.Modifier,ir.expr(e.callee),...ir.Args(e.args)]}}NamedBlocks({blocks:e}){let t=[],r=[];for(let n of e.toArray()){let[e,s]=ur.NamedBlock(n);t.push(e),r.push(s)}return t.length>0?[t,r]:null}NamedBlock({name:e,body:t,scope:r}){let n=e.chars;return"inverse"===n&&(n="else"),[n,[ur.list(t),r.slots]]}If({condition:e,block:t,inverse:r}){return[f.If,ir.expr(e),ur.NamedBlock(t)[1],r?ur.NamedBlock(r)[1]:null]}Each({value:e,key:t,block:r,inverse:n}){return[f.Each,ir.expr(e),t?ir.expr(t):null,ur.NamedBlock(r)[1],n?ur.NamedBlock(n)[1]:null]}Let({positional:e,block:t}){return[f.Let,ir.Positional(e),ur.NamedBlock(t)[1]]}WithDynamicVars({named:e,block:t}){return[f.WithDynamicVars,ir.NamedArguments(e),ur.NamedBlock(t)[1]]}InvokeComponent({definition:e,args:t,blocks:r}){return[f.InvokeComponent,ir.expr(e),ir.Positional(t.positional),ir.NamedArguments(t.named),r?ur.NamedBlocks(r):null]}};function pr({name:e,value:t,namespace:r}){let n=[Zt(e.chars),t.chars];return r&&n.push(r),n}function mr({name:e,value:t,namespace:r}){let n=[Zt(e.chars),ir.expr(t)];return r&&n.push(r),n}function dr(e){return e.component?f.StaticComponentAttr:f.StaticAttr}function hr(e){return e.component?e.trusting?f.TrustingComponentAttr:f.ComponentAttr:e.trusting?f.TrustingDynamicAttr:f.DynamicAttr}const fr=(()=>{const e="object"==typeof module&&"function"==typeof module.require?module.require:globalThis.require;if(e)try{const t=e("crypto"),r=e=>{const r=t.createHash("sha1");return r.update(e,"utf8"),r.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),kr={id:fr};function yr(e,t=kr){const r=new E.Source(e??"",t.meta?.moduleName),[n,s]=S(r,{lexicalScope:()=>!1,...t}),a=function(e,t,r){let n=new sr(t.table,r);be&&(m.groupCollapsed("pass0: visiting"),m.log("symbols",t.table),m.log("source",e),m.groupEnd());let s=nr.visitList(t.body,n);be&&(s.isOk?m.log("-> pass0: out",s.value):m.log("-> pass0: error",s.reason));let a=s.mapOk((e=>new Ee({loc:t.loc,scope:t.table,body:e.toArray()})));return r&&(a=a.andThen((e=>or.validate(e)))),a}(r,n,t.strictMode??!1).mapOk((e=>function(e){let t=ur.list(e.body),r=e.scope,n=[t,r.symbols,r.hasEval,r.upvars];if(be){let e=new lr(n);m.log("-> ",t.map((t=>e.formatOpcode(t))))}return n}(e)));if(be&&m.log("Template ->",a),a.isOk)return[a.value,s];throw a.reason}const gr="796d24e6-2450-4fb0-8cdf-b65638b5ef70";function Ar(e,t=kr){const[r,n]=yr(e,t),s=t.meta?.moduleName,a=t.id||fr,o=JSON.stringify(r),l={id:a(JSON.stringify(t.meta)+o),block:o,moduleName:s??"(unknown template module)",scope:gr,isStrictMode:t.strictMode??!1};0===n.length&&delete l.scope;let i=JSON.stringify(l);if(n.length>0){const e=`()=>[${n.join(",")}]`;i=i.replace(`"${gr}"`,e)}return i}export{z as Builder,ce as NEWLINE,Q as ProgramSymbols,lr as WireFormatDebugger,ae as buildStatement,ne as buildStatements,le as c,fr as defaultId,Ar as precompile,yr as precompileJSON,oe as s,ie as unicode};
//# sourceMappingURL=index.js.map

{"version":3,"file":"index.js","sources":["../../lib/builder/builder-interface.ts","../../lib/builder/builder.ts","../../../local-debug-flags/index.ts","../../lib/passes/2-encoding/mir.ts","../../lib/shared/list.ts","../../lib/shared/result.ts","../../lib/passes/1-normalization/visitors/expressions.ts","../../lib/passes/1-normalization/keywords/impl.ts","../../lib/passes/1-normalization/keywords/utils/call-to-append.ts","../../lib/passes/1-normalization/keywords/utils/curry.ts","../../lib/passes/1-normalization/keywords/utils/dynamic-vars.ts","../../lib/passes/1-normalization/keywords/utils/has-block.ts","../../lib/passes/1-normalization/keywords/utils/if-unless.ts","../../lib/passes/1-normalization/keywords/utils/log.ts","../../lib/passes/1-normalization/keywords/append.ts","../../lib/passes/1-normalization/keywords/block.ts","../../lib/passes/1-normalization/keywords/call.ts","../../lib/passes/1-normalization/keywords/modifier.ts","../../lib/utils.ts","../../lib/passes/1-normalization/visitors/element/classified.ts","../../lib/passes/1-normalization/visitors/element/component.ts","../../lib/passes/1-normalization/visitors/element/simple-element.ts","../../lib/passes/1-normalization/visitors/statements.ts","../../lib/passes/1-normalization/context.ts","../../lib/passes/1-normalization/visitors/strict-mode.ts","../../lib/wire-format-debug.ts","../../lib/passes/2-encoding/expressions.ts","../../lib/passes/2-encoding/content.ts","../../lib/compiler.ts","../../lib/passes/1-normalization/index.ts","../../lib/passes/2-encoding/index.ts"],"sourcesContent":["import type { Dict, DictValue, Nullable, PresentArray } from '@glimmer/interfaces';\nimport { assertNever, dict, expect, isPresentArray } from '@glimmer/util';\n\nexport type BuilderParams = BuilderExpression[];\nexport type BuilderHash = Nullable<Dict<BuilderExpression>>;\nexport type BuilderBlockHash = BuilderHash | { as: string | string[] };\nexport type BuilderBlocks = Dict<BuilderBlock>;\nexport type BuilderAttrs = Dict<BuilderAttr>;\n\nexport type NormalizedParams = NormalizedExpression[];\nexport type NormalizedHash = Dict<NormalizedExpression>;\nexport type NormalizedBlock = NormalizedStatement[];\nexport type NormalizedBlocks = Dict<NormalizedBlock>;\nexport type NormalizedAttrs = Dict<NormalizedAttr>;\nexport type NormalizedAttr = HeadKind.Splat | NormalizedExpression;\n\nexport interface NormalizedElement {\n  name: string;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport interface NormalizedAngleInvocation {\n  head: NormalizedExpression;\n  attrs: Nullable<NormalizedAttrs>;\n  block: Nullable<NormalizedBlock>;\n}\n\nexport enum HeadKind {\n  Block = 'Block',\n  Call = 'Call',\n  Element = 'Element',\n  AppendPath = 'AppendPath',\n  AppendExpr = 'AppendExpr',\n  Literal = 'Literal',\n  Modifier = 'Modifier',\n  DynamicComponent = 'DynamicComponent',\n  Comment = 'Comment',\n  Splat = 'Splat',\n  Keyword = 'Keyword',\n}\n\nexport enum VariableKind {\n  Local = 'Local',\n  Free = 'Free',\n  Arg = 'Arg',\n  Block = 'Block',\n  This = 'This',\n}\n\nexport interface Variable {\n  kind: VariableKind;\n  name: string;\n  /**\n   * Differences:\n   *\n   * - strict mode variables always refer to in-scope variables\n   * - loose mode variables use this algorithm:\n   *   1. otherwise, fall back to `this.<name>`\n   */\n  mode: 'loose' | 'strict';\n}\n\nexport interface Path {\n  head: Variable;\n  tail: PresentArray<string>;\n}\n\nexport interface AppendExpr {\n  kind: HeadKind.AppendExpr;\n  expr: NormalizedExpression;\n  trusted: boolean;\n}\n\nexport interface AppendPath {\n  kind: HeadKind.AppendPath;\n  path: NormalizedPath;\n  trusted: boolean;\n}\n\nexport interface NormalizedKeywordStatement {\n  kind: HeadKind.Keyword;\n  name: string;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport type NormalizedStatement =\n  | {\n      kind: HeadKind.Call;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      trusted: boolean;\n    }\n  | {\n      kind: HeadKind.Block;\n      head: NormalizedHead;\n      params: Nullable<NormalizedParams>;\n      hash: Nullable<NormalizedHash>;\n      blockParams: Nullable<string[]>;\n      blocks: NormalizedBlocks;\n    }\n  | NormalizedKeywordStatement\n  | {\n      kind: HeadKind.Element;\n      name: string;\n      attrs: NormalizedAttrs;\n      block: NormalizedBlock;\n    }\n  | { kind: HeadKind.Comment; value: string }\n  | { kind: HeadKind.Literal; value: string }\n  | AppendPath\n  | AppendExpr\n  | { kind: HeadKind.Modifier; params: NormalizedParams; hash: Nullable<NormalizedHash> }\n  | {\n      kind: HeadKind.DynamicComponent;\n      expr: NormalizedExpression;\n      hash: Nullable<NormalizedHash>;\n      block: NormalizedBlock;\n    };\n\nexport function normalizeStatement(statement: BuilderStatement): NormalizedStatement {\n  if (Array.isArray(statement)) {\n    if (statementIsExpression(statement)) {\n      return normalizeAppendExpression(statement);\n    } else if (isSugaryArrayStatement(statement)) {\n      return normalizeSugaryArrayStatement(statement);\n    } else {\n      return normalizeVerboseStatement(statement);\n    }\n  } else if (typeof statement === 'string') {\n    return normalizeAppendHead(normalizeDottedPath(statement), false);\n  } else {\n    throw assertNever(statement);\n  }\n}\n\nexport function normalizeAppendHead(\n  head: NormalizedHead,\n  trusted: boolean\n): AppendExpr | AppendPath {\n  if (head.type === ExpressionKind.GetPath) {\n    return {\n      kind: HeadKind.AppendPath,\n      path: head,\n      trusted,\n    };\n  } else {\n    return {\n      kind: HeadKind.AppendExpr,\n      expr: head,\n      trusted,\n    };\n  }\n}\n\nfunction isSugaryArrayStatement(statement: BuilderStatement): statement is SugaryArrayStatement {\n  if (Array.isArray(statement) && typeof statement[0] === 'string') {\n    switch (statement[0][0]) {\n      case '(':\n      case '#':\n      case '<':\n      case '!':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}\n\nexport type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;\n\nexport function normalizeSugaryArrayStatement(\n  statement: SugaryArrayStatement\n): NormalizedStatement {\n  const name = statement[0];\n\n  switch (name[0]) {\n    case '(': {\n      let params: Nullable<NormalizedParams> = null;\n      let hash: Nullable<NormalizedHash> = null;\n\n      if (statement.length === 3) {\n        params = normalizeParams(statement[1] as Params);\n        hash = normalizeHash(statement[2] as Hash);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          params = normalizeParams(statement[1] as Params);\n        } else {\n          hash = normalizeHash(statement[1] as Hash);\n        }\n      }\n\n      return {\n        kind: HeadKind.Call,\n        head: normalizeCallHead(name),\n        params,\n        hash,\n        trusted: false,\n      };\n    }\n\n    case '#': {\n      const {\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      } = normalizeBuilderBlockStatement(statement as BuilderBlockStatement);\n\n      return {\n        kind: HeadKind.Block,\n        head: path,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '!': {\n      const name = statement[0].slice(1);\n      const { params, hash, blocks, blockParams } = normalizeBuilderBlockStatement(\n        statement as BuilderBlockStatement\n      );\n\n      return {\n        kind: HeadKind.Keyword,\n        name,\n        params,\n        hash,\n        blocks,\n        blockParams,\n      };\n    }\n\n    case '<': {\n      let attrs: NormalizedAttrs = dict();\n      let block: NormalizedBlock = [];\n\n      if (statement.length === 3) {\n        attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        block = normalizeBlock(statement[2] as BuilderBlock);\n      } else if (statement.length === 2) {\n        if (Array.isArray(statement[1])) {\n          block = normalizeBlock(statement[1] as BuilderBlock);\n        } else {\n          attrs = normalizeAttrs(statement[1] as BuilderAttrs);\n        }\n      }\n\n      return {\n        kind: HeadKind.Element,\n        name: expect(extractElement(name), `BUG: expected ${name} to look like a tag name`),\n        attrs,\n        block,\n      };\n    }\n\n    default:\n      throw new Error(`Unreachable ${JSON.stringify(statement)} in normalizeSugaryArrayStatement`);\n  }\n}\n\nfunction normalizeVerboseStatement(statement: VerboseStatement): NormalizedStatement {\n  switch (statement[0]) {\n    case Builder.Literal: {\n      return {\n        kind: HeadKind.Literal,\n        value: statement[1],\n      };\n    }\n\n    case Builder.Append: {\n      return normalizeAppendExpression(statement[1], statement[2]);\n    }\n\n    case Builder.Modifier: {\n      return {\n        kind: HeadKind.Modifier,\n        params: normalizeParams(statement[1]),\n        hash: normalizeHash(statement[2]),\n      };\n    }\n\n    case Builder.DynamicComponent: {\n      return {\n        kind: HeadKind.DynamicComponent,\n        expr: normalizeExpression(statement[1]),\n        hash: normalizeHash(statement[2]),\n        block: normalizeBlock(statement[3]),\n      };\n    }\n\n    case Builder.Comment: {\n      return {\n        kind: HeadKind.Comment,\n        value: statement[1],\n      };\n    }\n  }\n}\n\nfunction extractBlockHead(name: string): NormalizedHead {\n  const result = /^(#|!)(.*)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing # in block head`);\n  }\n\n  return normalizeDottedPath(result[2] as string);\n}\n\nfunction normalizeCallHead(name: string): NormalizedHead {\n  const result = /^\\((.*)\\)$/u.exec(name);\n\n  if (result === null) {\n    throw new Error(`Unexpected missing () in call head`);\n  }\n\n  return normalizeDottedPath(result[1] as string);\n}\n\nfunction normalizePath(head: string, tail: string[] = []): NormalizedHead {\n  const pathHead = normalizePathHead(head);\n\n  if (isPresentArray(tail)) {\n    return {\n      type: ExpressionKind.GetPath,\n      path: {\n        head: pathHead,\n        tail,\n      },\n    };\n  } else {\n    return {\n      type: ExpressionKind.GetVar,\n      variable: pathHead,\n    };\n  }\n}\n\nfunction normalizeDottedPath(whole: string): NormalizedHead {\n  const { kind, name: rest } = normalizePathHead(whole);\n\n  const [name, ...tail] = rest.split('.') as [string, ...string[]];\n\n  const variable: Variable = { kind, name, mode: 'loose' };\n\n  if (isPresentArray(tail)) {\n    return { type: ExpressionKind.GetPath, path: { head: variable, tail } };\n  } else {\n    return { type: ExpressionKind.GetVar, variable };\n  }\n}\n\nexport function normalizePathHead(whole: string): Variable {\n  let kind: VariableKind;\n  let name: string;\n\n  if (/^this(?:\\.|$)/u.test(whole)) {\n    return {\n      kind: VariableKind.This,\n      name: whole,\n      mode: 'loose',\n    };\n  }\n\n  switch (whole[0]) {\n    case '^':\n      kind = VariableKind.Free;\n      name = whole.slice(1);\n      break;\n\n    case '@':\n      kind = VariableKind.Arg;\n      name = whole.slice(1);\n      break;\n\n    case '&':\n      kind = VariableKind.Block;\n      name = whole.slice(1);\n      break;\n\n    default:\n      kind = VariableKind.Local;\n      name = whole;\n  }\n\n  return { kind, name, mode: 'loose' };\n}\n\nexport type BuilderBlockStatement =\n  | [string, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks]\n  | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];\n\nexport interface NormalizedBuilderBlockStatement {\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n  blocks: NormalizedBlocks;\n}\n\nexport function normalizeBuilderBlockStatement(\n  statement: BuilderBlockStatement\n): NormalizedBuilderBlockStatement {\n  const head = statement[0];\n  let blocks: NormalizedBlocks = dict();\n  let params: Nullable<NormalizedParams> = null;\n  let hash: Nullable<NormalizedHash> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  if (statement.length === 2) {\n    blocks = normalizeBlocks(statement[1]);\n  } else if (statement.length === 3) {\n    if (Array.isArray(statement[1])) {\n      params = normalizeParams(statement[1]);\n    } else {\n      ({ hash, blockParams } = normalizeBlockHash(statement[1]));\n    }\n\n    blocks = normalizeBlocks(statement[2]);\n  } else if (statement.length === 4) {\n    params = normalizeParams(statement[1]);\n    ({ hash, blockParams } = normalizeBlockHash(statement[2]));\n    blocks = normalizeBlocks(statement[3]);\n  }\n\n  return {\n    head: extractBlockHead(head),\n    params,\n    hash,\n    blockParams,\n    blocks,\n  };\n}\n\nfunction normalizeBlockHash(hash: BuilderBlockHash): {\n  hash: Nullable<NormalizedHash>;\n  blockParams: Nullable<string[]>;\n} {\n  if (hash === null) {\n    return { hash: null, blockParams: null };\n  }\n\n  let out: Nullable<Dict<NormalizedExpression>> = null;\n  let blockParams: Nullable<string[]> = null;\n\n  entries(hash, (key, value) => {\n    if (key === 'as') {\n      blockParams = Array.isArray(value) ? (value as string[]) : [value as string];\n    } else {\n      out = out || dict();\n      out[key] = normalizeExpression(value as BuilderExpression);\n    }\n  });\n\n  return { hash: out, blockParams };\n}\n\nexport function entries<D extends Dict>(\n  dict: D,\n  callback: <K extends keyof D>(key: K, value: D[K]) => void\n): void {\n  Object.keys(dict).forEach((key) => {\n    const value = dict[key];\n    callback(key, value as D[keyof D]);\n  });\n}\n\nfunction normalizeBlocks(value: BuilderBlock | BuilderBlocks): NormalizedBlocks {\n  if (Array.isArray(value)) {\n    return { default: normalizeBlock(value) };\n  } else {\n    return mapObject(value, normalizeBlock);\n  }\n}\n\nfunction normalizeBlock(block: BuilderBlock): NormalizedBlock {\n  return block.map((s) => normalizeStatement(s));\n}\n\nfunction normalizeAttrs(attrs: BuilderAttrs): NormalizedAttrs {\n  return mapObject(attrs, (a) => normalizeAttr(a).expr);\n}\n\nfunction normalizeAttr(attr: BuilderAttr): { expr: NormalizedAttr; trusted: boolean } {\n  if (attr === 'splat') {\n    return { expr: HeadKind.Splat, trusted: false };\n  } else {\n    const expr = normalizeExpression(attr);\n    return { expr, trusted: false };\n  }\n}\n\nfunction mapObject<T extends Dict<unknown>, Out>(\n  object: T,\n  mapper: (value: DictValue<T>, key: keyof T) => Out\n): { [P in keyof T]: Out } {\n  const out = dict() as { [P in keyof T]?: Out };\n\n  Object.keys(object).forEach(<K extends keyof T>(k: K) => {\n    out[k] = mapper(object[k] as DictValue<T>, k);\n  });\n\n  return out as { [P in keyof T]: Out };\n}\n\nexport type BuilderElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport type BuilderComment = [Builder.Comment, string];\n\nexport type InvocationElement =\n  | [string]\n  | [string, BuilderAttrs, BuilderBlock]\n  | [string, BuilderBlock]\n  | [string, BuilderAttrs];\n\nexport function isElement(input: [string, ...unknown[]]): input is BuilderElement {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function extractElement(input: string): Nullable<string> {\n  const match = /^<([\\d\\-a-z][\\d\\-A-Za-z]*)>$/u.exec(input);\n\n  return match?.[1] ?? null;\n}\n\nexport function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement {\n  // TODO Paths\n  const match = /^<(@[\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)>$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement {\n  // TODO Paths\n  const match = /^#[\\s\\S]?([\\dA-Za-z]*|[A-Z][\\d\\-A-Za-z]*)$/u.exec(input[0]);\n\n  return !!match && !!match[1];\n}\n\nexport enum Builder {\n  Literal,\n  Comment,\n  Append,\n  Modifier,\n  DynamicComponent,\n  Get,\n  Concat,\n  HasBlock,\n  HasBlockParams,\n}\n\nexport type VerboseStatement =\n  | [Builder.Literal, string]\n  | [Builder.Comment, string]\n  | [Builder.Append, BuilderExpression, true]\n  | [Builder.Append, BuilderExpression]\n  | [Builder.Modifier, Params, Hash]\n  | [Builder.DynamicComponent, BuilderExpression, Hash, BuilderBlock];\n\nexport type BuilderStatement =\n  | VerboseStatement\n  | SugaryArrayStatement\n  | TupleBuilderExpression\n  | string;\n\nexport type BuilderAttr = 'splat' | BuilderExpression;\n\nexport type TupleBuilderExpression =\n  | [Builder.Literal, string | boolean | null | undefined]\n  | [Builder.Get, string]\n  | [Builder.Get, string, string[]]\n  | [Builder.Concat, ...BuilderExpression[]]\n  | [Builder.HasBlock, string]\n  | [Builder.HasBlockParams, string]\n  | BuilderCallExpression;\n\ntype Params = BuilderParams;\ntype Hash = Dict<BuilderExpression>;\n\nexport enum ExpressionKind {\n  Literal = 'Literal',\n  Call = 'Call',\n  GetPath = 'GetPath',\n  GetVar = 'GetVar',\n  Concat = 'Concat',\n  HasBlock = 'HasBlock',\n  HasBlockParams = 'HasBlockParams',\n}\n\nexport interface NormalizedCallExpression {\n  type: ExpressionKind.Call;\n  head: NormalizedHead;\n  params: Nullable<NormalizedParams>;\n  hash: Nullable<NormalizedHash>;\n}\n\nexport interface NormalizedPath {\n  type: ExpressionKind.GetPath;\n  path: Path;\n}\n\nexport interface NormalizedVar {\n  type: ExpressionKind.GetVar;\n  variable: Variable;\n}\n\nexport type NormalizedHead = NormalizedPath | NormalizedVar;\n\nexport interface NormalizedConcat {\n  type: ExpressionKind.Concat;\n  params: [NormalizedExpression, ...NormalizedExpression[]];\n}\n\nexport type NormalizedExpression =\n  | {\n      type: ExpressionKind.Literal;\n      value: null | undefined | boolean | string | number;\n    }\n  | NormalizedCallExpression\n  | NormalizedPath\n  | NormalizedVar\n  | NormalizedConcat\n  | {\n      type: ExpressionKind.HasBlock;\n      name: string;\n    }\n  | {\n      type: ExpressionKind.HasBlockParams;\n      name: string;\n    };\n\nexport function normalizeAppendExpression(\n  expression: BuilderExpression,\n  forceTrusted = false\n): AppendExpr | AppendPath {\n  if (expression === null || expression === undefined) {\n    return {\n      expr: {\n        type: ExpressionKind.Literal,\n        value: expression,\n      },\n      kind: HeadKind.AppendExpr,\n      trusted: false,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression[1] },\n          kind: HeadKind.AppendExpr,\n          trusted: false,\n        };\n\n      case Builder.Get: {\n        return normalizeAppendHead(normalizePath(expression[1], expression[2]), forceTrusted);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return {\n          expr,\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n      }\n\n      case Builder.HasBlock:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlock,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          expr: {\n            type: ExpressionKind.HasBlockParams,\n            name: expression[1],\n          },\n          kind: HeadKind.AppendExpr,\n          trusted: forceTrusted,\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return {\n            expr: normalizeCallExpression(expression),\n            kind: HeadKind.AppendExpr,\n            trusted: forceTrusted,\n          };\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeAppendHead(normalizeDottedPath(expression), forceTrusted);\n      }\n      case 'boolean':\n      case 'number':\n        return {\n          expr: { type: ExpressionKind.Literal, value: expression },\n          kind: HeadKind.AppendExpr,\n          trusted: true,\n        };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\nexport function normalizeExpression(expression: BuilderExpression): NormalizedExpression {\n  if (expression === null || expression === undefined) {\n    return {\n      type: ExpressionKind.Literal,\n      value: expression,\n    };\n  } else if (Array.isArray(expression)) {\n    switch (expression[0]) {\n      case Builder.Literal:\n        return { type: ExpressionKind.Literal, value: expression[1] };\n\n      case Builder.Get: {\n        return normalizePath(expression[1], expression[2]);\n      }\n      case Builder.Concat: {\n        const expr: NormalizedConcat = {\n          type: ExpressionKind.Concat,\n          params: normalizeParams(expression.slice(1)) as [\n            NormalizedExpression,\n            ...NormalizedExpression[],\n          ],\n        };\n\n        return expr;\n      }\n\n      case Builder.HasBlock:\n        return {\n          type: ExpressionKind.HasBlock,\n          name: expression[1],\n        };\n\n      case Builder.HasBlockParams:\n        return {\n          type: ExpressionKind.HasBlockParams,\n          name: expression[1],\n        };\n\n      default: {\n        if (isBuilderCallExpression(expression)) {\n          return normalizeCallExpression(expression);\n        } else {\n          throw new Error(\n            `Unexpected array in expression position (wasn't a tuple expression and ${\n              expression[0] as string\n            } isn't wrapped in parens, so it isn't a call): ${JSON.stringify(expression)}`\n          );\n        }\n      }\n      // BuilderCallExpression\n    }\n  } else if (typeof expression !== 'object') {\n    switch (typeof expression) {\n      case 'string': {\n        return normalizeDottedPath(expression);\n      }\n      case 'boolean':\n      case 'number':\n        return { type: ExpressionKind.Literal, value: expression };\n\n      default:\n        throw assertNever(expression);\n    }\n  } else {\n    throw assertNever(expression);\n  }\n}\n\n// | [Builder.Get, string]\n// | [Builder.Get, string, string[]]\n// | [Builder.Concat, Params]\n// | [Builder.HasBlock, string]\n// | [Builder.HasBlockParams, string]\n\nexport type BuilderExpression =\n  | TupleBuilderExpression\n  | BuilderCallExpression\n  | null\n  | undefined\n  | boolean\n  | string\n  | number;\n\nexport function isBuilderExpression(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is TupleBuilderExpression | BuilderCallExpression {\n  return Array.isArray(expr);\n}\n\nexport function isLiteral(\n  expr: BuilderExpression | BuilderCallExpression\n): expr is [Builder.Literal, string | boolean | undefined] {\n  return Array.isArray(expr) && expr[0] === 'literal';\n}\n\nexport function statementIsExpression(\n  statement: BuilderStatement\n): statement is TupleBuilderExpression {\n  if (!Array.isArray(statement)) {\n    return false;\n  }\n\n  const name = statement[0];\n\n  if (typeof name === 'number') {\n    switch (name) {\n      case Builder.Literal:\n      case Builder.Get:\n      case Builder.Concat:\n      case Builder.HasBlock:\n      case Builder.HasBlockParams:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  if (name[0] === '(') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isBuilderCallExpression(\n  value: TupleBuilderExpression | BuilderCallExpression\n): value is BuilderCallExpression {\n  return typeof value[0] === 'string' && value[0][0] === '(';\n}\n\nexport type MiniBuilderBlock = BuilderStatement[];\n\nexport type BuilderBlock = MiniBuilderBlock;\n\nexport type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];\n\nexport function normalizeParams(input: Params): NormalizedParams {\n  return input.map(normalizeExpression);\n}\n\nexport function normalizeHash(input: Nullable<Hash>): Nullable<NormalizedHash> {\n  if (input === null) return null;\n  return mapObject(input, normalizeExpression);\n}\n\nexport function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression {\n  switch (expr.length) {\n    case 1:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: null,\n        hash: null,\n      };\n    case 2: {\n      if (Array.isArray(expr[1])) {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: normalizeParams(expr[1]),\n          hash: null,\n        };\n      } else {\n        return {\n          type: ExpressionKind.Call,\n          head: normalizeCallHead(expr[0]),\n          params: null,\n          hash: normalizeHash(expr[1]),\n        };\n      }\n    }\n\n    case 3:\n      return {\n        type: ExpressionKind.Call,\n        head: normalizeCallHead(expr[0]),\n        params: normalizeParams(expr[1]),\n        hash: normalizeHash(expr[2]),\n      };\n  }\n}\n","import type {\n  AttrNamespace,\n  Dict,\n  Expressions,\n  GetContextualFreeOpcode,\n  Nullable,\n  PresentArray,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport {\n  assert,\n  assertNever,\n  dict,\n  exhausted,\n  expect,\n  isPresentArray,\n  NS_XLINK,\n  NS_XML,\n  NS_XMLNS,\n  values,\n} from '@glimmer/util';\nimport { SexpOpcodes as Op, VariableResolutionContext } from '@glimmer/wire-format';\n\nimport type {\n  BuilderComment,\n  BuilderStatement,\n  NormalizedAngleInvocation,\n  NormalizedAttrs,\n  NormalizedBlock,\n  NormalizedBlocks,\n  NormalizedElement,\n  NormalizedExpression,\n  NormalizedHash,\n  NormalizedHead,\n  NormalizedKeywordStatement,\n  NormalizedParams,\n  NormalizedPath,\n  NormalizedStatement,\n  Variable,\n} from './builder-interface';\n\nimport {\n  Builder,\n  ExpressionKind,\n  HeadKind,\n  normalizeStatement,\n  VariableKind,\n} from './builder-interface';\n\ninterface Symbols {\n  top: ProgramSymbols;\n  freeVar(name: string): number;\n  arg(name: string): number;\n  block(name: string): number;\n  local(name: string): number;\n  this(): number;\n\n  hasLocal(name: string): boolean;\n\n  child(params: string[]): LocalSymbols;\n}\n\nexport class ProgramSymbols implements Symbols {\n  _freeVariables: string[] = [];\n  _symbols: string[] = ['this'];\n\n  top = this;\n\n  toSymbols(): string[] {\n    return this._symbols.slice(1);\n  }\n\n  toUpvars(): string[] {\n    return this._freeVariables;\n  }\n\n  freeVar(name: string): number {\n    return addString(this._freeVariables, name);\n  }\n\n  block(name: string): number {\n    return this.symbol(name);\n  }\n\n  arg(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  local(name: string): never {\n    throw new Error(\n      `No local ${name} was found. Maybe you meant ^${name} for upvar, or !${name} for keyword?`\n    );\n  }\n\n  this(): number {\n    return 0;\n  }\n\n  hasLocal(_name: string): false {\n    return false;\n  }\n\n  // any symbol\n  symbol(name: string): number {\n    return addString(this._symbols, name);\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nclass LocalSymbols implements Symbols {\n  private locals: Dict<number> = dict();\n\n  constructor(\n    private parent: Symbols,\n    locals: string[]\n  ) {\n    for (let local of locals) {\n      this.locals[local] = parent.top.symbol(local);\n    }\n  }\n\n  get paramSymbols(): number[] {\n    return values(this.locals);\n  }\n\n  get top(): ProgramSymbols {\n    return this.parent.top;\n  }\n\n  freeVar(name: string): number {\n    return this.parent.freeVar(name);\n  }\n\n  arg(name: string): number {\n    return this.parent.arg(name);\n  }\n\n  block(name: string): number {\n    return this.parent.block(name);\n  }\n\n  local(name: string): number {\n    if (name in this.locals) {\n      return this.locals[name] as number;\n    } else {\n      return this.parent.local(name);\n    }\n  }\n\n  this(): number {\n    return this.parent.this();\n  }\n\n  hasLocal(name: string): boolean {\n    if (name in this.locals) {\n      return true;\n    } else {\n      return this.parent.hasLocal(name);\n    }\n  }\n\n  child(locals: string[]): LocalSymbols {\n    return new LocalSymbols(this, locals);\n  }\n}\n\nfunction addString(array: string[], item: string): number {\n  let index = array.indexOf(item);\n\n  if (index === -1) {\n    index = array.length;\n    array.push(item);\n    return index;\n  } else {\n    return index;\n  }\n}\n\nexport interface BuilderGetFree {\n  type: 'GetFree';\n  head: string;\n  tail: string[];\n}\n\nfunction unimpl(message: string): Error {\n  return new Error(`unimplemented ${message}`);\n}\n\nexport function buildStatements(\n  statements: BuilderStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(normalizeStatement(s), symbols)));\n\n  return out;\n}\n\nexport function buildNormalizedStatements(\n  statements: NormalizedStatement[],\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [];\n\n  statements.forEach((s) => out.push(...buildStatement(s, symbols)));\n\n  return out;\n}\n\nexport function buildStatement(\n  normalized: NormalizedStatement,\n  symbols: Symbols = new ProgramSymbols()\n): WireFormat.Statement[] {\n  switch (normalized.kind) {\n    case HeadKind.AppendPath: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildGetPath(normalized.path, symbols),\n        ],\n      ];\n    }\n\n    case HeadKind.AppendExpr: {\n      return [\n        [\n          normalized.trusted ? Op.TrustingAppend : Op.Append,\n          buildExpression(\n            normalized.expr,\n            normalized.trusted ? 'TrustedAppend' : 'Append',\n            symbols\n          ),\n        ],\n      ];\n    }\n\n    case HeadKind.Call: {\n      let { head: path, params, hash, trusted } = normalized;\n      let builtParams: Nullable<WireFormat.Core.Params> = params\n        ? buildParams(params, symbols)\n        : null;\n      let builtHash: WireFormat.Core.Hash = hash ? buildHash(hash, symbols) : null;\n      let builtExpr: WireFormat.Expression = buildCallHead(\n        path,\n        trusted\n          ? VariableResolutionContext.ResolveAsHelperHead\n          : VariableResolutionContext.ResolveAsComponentOrHelperHead,\n        symbols\n      );\n\n      return [\n        [trusted ? Op.TrustingAppend : Op.Append, [Op.Call, builtExpr, builtParams, builtHash]],\n      ];\n    }\n\n    case HeadKind.Literal: {\n      return [[Op.Append, normalized.value]];\n    }\n\n    case HeadKind.Comment: {\n      return [[Op.Comment, normalized.value]];\n    }\n\n    case HeadKind.Block: {\n      let blocks = buildBlocks(normalized.blocks, normalized.blockParams, symbols);\n      let hash = buildHash(normalized.hash, symbols);\n      let params = buildParams(normalized.params, symbols);\n      let path = buildCallHead(\n        normalized.head,\n        VariableResolutionContext.ResolveAsComponentHead,\n        symbols\n      );\n\n      return [[Op.Block, path, params, hash, blocks]];\n    }\n\n    case HeadKind.Keyword: {\n      return [buildKeyword(normalized, symbols)];\n    }\n\n    case HeadKind.Element:\n      return buildElement(normalized, symbols);\n\n    case HeadKind.Modifier:\n      throw unimpl('modifier');\n\n    case HeadKind.DynamicComponent:\n      throw unimpl('dynamic component');\n\n    default:\n      throw assertNever(normalized);\n  }\n}\n\nexport function s(\n  arr: TemplateStringsArray,\n  ...interpolated: unknown[]\n): [Builder.Literal, string] {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Literal, result];\n}\n\nexport function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment {\n  let result = arr.reduce(\n    (result, string, i) => result + `${string}${interpolated[i] ? String(interpolated[i]) : ''}`,\n    ''\n  );\n\n  return [Builder.Comment, result];\n}\n\nexport function unicode(charCode: string): string {\n  return String.fromCharCode(parseInt(charCode, 16));\n}\n\nexport const NEWLINE = '\\n';\n\nfunction buildKeyword(\n  normalized: NormalizedKeywordStatement,\n  symbols: Symbols\n): WireFormat.Statement {\n  let { name } = normalized;\n  let params = buildParams(normalized.params, symbols);\n  let childSymbols = symbols.child(normalized.blockParams || []);\n\n  let block = buildBlock(\n    normalized.blocks['default'] as NormalizedBlock,\n    childSymbols,\n    childSymbols.paramSymbols\n  );\n  let inverse = normalized.blocks['else']\n    ? buildBlock(normalized.blocks['else'], symbols, [])\n    : null;\n\n  switch (name) {\n    case 'let':\n      return [Op.Let, expect(params, 'let requires params'), block];\n    case 'if':\n      return [Op.If, expect(params, 'if requires params')[0], block, inverse];\n    case 'each': {\n      let keyExpr = normalized.hash ? normalized.hash['key'] : null;\n      let key = keyExpr ? buildExpression(keyExpr, 'Strict', symbols) : null;\n      return [Op.Each, expect(params, 'if requires params')[0], key, block, inverse];\n    }\n\n    default:\n      throw new Error('unimplemented keyword');\n  }\n}\n\nfunction buildElement(\n  { name, attrs, block }: NormalizedElement,\n  symbols: Symbols\n): WireFormat.Statement[] {\n  let out: WireFormat.Statement[] = [\n    hasSplat(attrs) ? [Op.OpenElementWithSplat, name] : [Op.OpenElement, name],\n  ];\n  if (attrs) {\n    let { params, args } = buildElementParams(attrs, symbols);\n    out.push(...params);\n    assert(args === null, `Can't pass args to a simple element`);\n  }\n  out.push([Op.FlushElement]);\n\n  if (Array.isArray(block)) {\n    block.forEach((s) => out.push(...buildStatement(s, symbols)));\n  } else if (block === null) {\n    // do nothing\n  } else {\n    throw assertNever(block);\n  }\n\n  out.push([Op.CloseElement]);\n\n  return out;\n}\n\nfunction hasSplat(attrs: Nullable<NormalizedAttrs>): boolean {\n  if (attrs === null) return false;\n\n  return Object.keys(attrs).some((a) => attrs[a] === HeadKind.Splat);\n}\n\nexport function buildAngleInvocation(\n  { attrs, block, head }: NormalizedAngleInvocation,\n  symbols: Symbols\n): WireFormat.Statements.Component {\n  let paramList: WireFormat.ElementParameter[] = [];\n  let args: WireFormat.Core.Hash = null;\n  let blockList: WireFormat.Statement[] = [];\n\n  if (attrs) {\n    let built = buildElementParams(attrs, symbols);\n    paramList = built.params;\n    args = built.args;\n  }\n\n  if (block) blockList = buildNormalizedStatements(block, symbols);\n\n  return [\n    Op.Component,\n    buildExpression(head, VariableResolutionContext.ResolveAsComponentHead, symbols),\n    isPresentArray(paramList) ? paramList : null,\n    args,\n    [['default'], [[blockList, []]]],\n  ];\n}\n\nexport function buildElementParams(\n  attrs: NormalizedAttrs,\n  symbols: Symbols\n): { params: WireFormat.ElementParameter[]; args: WireFormat.Core.Hash } {\n  let params: WireFormat.ElementParameter[] = [];\n  let keys: string[] = [];\n  let values: WireFormat.Expression[] = [];\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === HeadKind.Splat) {\n      params.push([Op.AttrSplat, symbols.block('&attrs')]);\n    } else if (key[0] === '@') {\n      keys.push(key);\n      values.push(buildExpression(value, 'Strict', symbols));\n    } else {\n      params.push(\n        ...buildAttributeValue(\n          key,\n          value,\n          // TODO: extract namespace from key\n          extractNamespace(key),\n          symbols\n        )\n      );\n    }\n  }\n\n  return { params, args: isPresentArray(keys) && isPresentArray(values) ? [keys, values] : null };\n}\n\nexport function extractNamespace(name: string): Nullable<AttrNamespace> {\n  if (name === 'xmlns') {\n    return NS_XMLNS;\n  }\n\n  let match = /^([^:]*):([^:]*)$/u.exec(name);\n\n  if (match === null) {\n    return null;\n  }\n\n  let namespace = match[1];\n\n  switch (namespace) {\n    case 'xlink':\n      return NS_XLINK;\n    case 'xml':\n      return NS_XML;\n    case 'xmlns':\n      return NS_XMLNS;\n  }\n\n  return null;\n}\n\nexport function buildAttributeValue(\n  name: string,\n  value: NormalizedExpression,\n  namespace: Nullable<AttrNamespace>,\n  symbols: Symbols\n): WireFormat.Attribute[] {\n  switch (value.type) {\n    case ExpressionKind.Literal: {\n      let val = value.value;\n\n      if (val === false) {\n        return [];\n      } else if (val === true) {\n        return [[Op.StaticAttr, name, '', namespace ?? undefined]];\n      } else if (typeof val === 'string') {\n        return [[Op.StaticAttr, name, val, namespace ?? undefined]];\n      } else {\n        throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(val)}`);\n      }\n    }\n\n    default:\n      return [\n        [\n          Op.DynamicAttr,\n          name,\n          buildExpression(value, 'AttrValue', symbols),\n          namespace ?? undefined,\n        ],\n      ];\n  }\n}\n\ntype ExprResolution =\n  | VariableResolutionContext\n  | 'Append'\n  | 'TrustedAppend'\n  | 'AttrValue'\n  | 'SubExpression'\n  | 'Strict';\n\nfunction varContext(context: ExprResolution, bare: boolean): VarResolution {\n  switch (context) {\n    case 'Append':\n      return bare ? 'AppendBare' : 'AppendInvoke';\n    case 'TrustedAppend':\n      return bare ? 'TrustedAppendBare' : 'TrustedAppendInvoke';\n    case 'AttrValue':\n      return bare ? 'AttrValueBare' : 'AttrValueInvoke';\n    default:\n      return context;\n  }\n}\n\nexport function buildExpression(\n  expr: NormalizedExpression,\n  context: ExprResolution,\n  symbols: Symbols\n): WireFormat.Expression {\n  switch (expr.type) {\n    case ExpressionKind.GetPath: {\n      return buildGetPath(expr, symbols);\n    }\n\n    case ExpressionKind.GetVar: {\n      return buildVar(expr.variable, varContext(context, true), symbols);\n    }\n\n    case ExpressionKind.Concat: {\n      return [Op.Concat, buildConcat(expr.params, symbols)];\n    }\n\n    case ExpressionKind.Call: {\n      let builtParams = buildParams(expr.params, symbols);\n      let builtHash = buildHash(expr.hash, symbols);\n      let builtExpr = buildCallHead(\n        expr.head,\n        context === 'Strict' ? 'SubExpression' : varContext(context, false),\n        symbols\n      );\n\n      return [Op.Call, builtExpr, builtParams, builtHash];\n    }\n\n    case ExpressionKind.HasBlock: {\n      return [\n        Op.HasBlock,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.HasBlockParams: {\n      return [\n        Op.HasBlockParams,\n        buildVar(\n          { kind: VariableKind.Block, name: expr.name, mode: 'loose' },\n          VariableResolutionContext.Strict,\n          symbols\n        ),\n      ];\n    }\n\n    case ExpressionKind.Literal: {\n      if (expr.value === undefined) {\n        return [Op.Undefined];\n      } else {\n        return expr.value;\n      }\n    }\n\n    default:\n      assertNever(expr);\n  }\n}\n\nexport function buildCallHead(\n  callHead: NormalizedHead,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar | Expressions.GetPath {\n  if (callHead.type === ExpressionKind.GetVar) {\n    return buildVar(callHead.variable, context, symbols);\n  } else {\n    return buildGetPath(callHead, symbols);\n  }\n}\n\nexport function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath {\n  return buildVar(head.path.head, VariableResolutionContext.Strict, symbols, head.path.tail);\n}\n\ntype VarResolution =\n  | VariableResolutionContext\n  | 'AppendBare'\n  | 'AppendInvoke'\n  | 'TrustedAppendBare'\n  | 'TrustedAppendInvoke'\n  | 'AttrValueBare'\n  | 'AttrValueInvoke'\n  | 'SubExpression'\n  | 'Strict';\n\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path: PresentArray<string>\n): Expressions.GetPath;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols\n): Expressions.GetVar;\nexport function buildVar(\n  head: Variable,\n  context: VarResolution,\n  symbols: Symbols,\n  path?: PresentArray<string>\n): Expressions.GetPath | Expressions.GetVar {\n  let op: Expressions.GetPath[0] | Expressions.GetVar[0] = Op.GetSymbol;\n  let sym: number;\n  switch (head.kind) {\n    case VariableKind.Free:\n      if (context === 'Strict') {\n        op = Op.GetStrictKeyword;\n      } else if (context === 'AppendBare') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'AppendInvoke') {\n        op = Op.GetFreeAsComponentOrHelperHead;\n      } else if (context === 'TrustedAppendBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'TrustedAppendInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueBare') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'AttrValueInvoke') {\n        op = Op.GetFreeAsHelperHead;\n      } else if (context === 'SubExpression') {\n        op = Op.GetFreeAsHelperHead;\n      } else {\n        op = expressionContextOp(context);\n      }\n      sym = symbols.freeVar(head.name);\n      break;\n    default:\n      op = Op.GetSymbol;\n      sym = getSymbolForVar(head.kind, symbols, head.name);\n  }\n\n  if (path === undefined || path.length === 0) {\n    return [op, sym];\n  } else {\n    assert(op !== Op.GetStrictKeyword, '[BUG] keyword with a path');\n    return [op, sym, path];\n  }\n}\n\nfunction getSymbolForVar(\n  kind: Exclude<VariableKind, VariableKind.Free>,\n  symbols: Symbols,\n  name: string\n) {\n  switch (kind) {\n    case VariableKind.Arg:\n      return symbols.arg(name);\n    case VariableKind.Block:\n      return symbols.block(name);\n    case VariableKind.Local:\n      return symbols.local(name);\n    case VariableKind.This:\n      return symbols.this();\n    default:\n      return exhausted(kind);\n  }\n}\n\nexport function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOpcode {\n  switch (context) {\n    case VariableResolutionContext.Strict:\n      return Op.GetStrictKeyword;\n    case VariableResolutionContext.ResolveAsComponentOrHelperHead:\n      return Op.GetFreeAsComponentOrHelperHead;\n    case VariableResolutionContext.ResolveAsHelperHead:\n      return Op.GetFreeAsHelperHead;\n    case VariableResolutionContext.ResolveAsModifierHead:\n      return Op.GetFreeAsModifierHead;\n    case VariableResolutionContext.ResolveAsComponentHead:\n      return Op.GetFreeAsComponentHead;\n    default:\n      return exhausted(context);\n  }\n}\n\nexport function buildParams(\n  exprs: Nullable<NormalizedParams>,\n  symbols: Symbols\n): Nullable<WireFormat.Core.Params> {\n  if (exprs === null || !isPresentArray(exprs)) return null;\n\n  return exprs.map((e) => buildExpression(e, 'Strict', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildConcat(\n  exprs: [NormalizedExpression, ...NormalizedExpression[]],\n  symbols: Symbols\n): WireFormat.Core.ConcatParams {\n  return exprs.map((e) => buildExpression(e, 'AttrValue', symbols)) as WireFormat.Core.ConcatParams;\n}\n\nexport function buildHash(exprs: Nullable<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash {\n  if (exprs === null) return null;\n\n  let out: [string[], WireFormat.Expression[]] = [[], []];\n\n  for (const [key, value] of Object.entries(exprs)) {\n    out[0].push(key);\n    out[1].push(buildExpression(value, 'Strict', symbols));\n  }\n\n  return out as WireFormat.Core.Hash;\n}\n\nexport function buildBlocks(\n  blocks: NormalizedBlocks,\n  blockParams: Nullable<string[]>,\n  parent: Symbols\n): WireFormat.Core.Blocks {\n  let keys: string[] = [];\n  let values: WireFormat.SerializedInlineBlock[] = [];\n\n  for (const [name, block] of Object.entries(blocks)) {\n    keys.push(name);\n\n    if (name === 'default') {\n      let symbols = parent.child(blockParams || []);\n\n      values.push(buildBlock(block, symbols, symbols.paramSymbols));\n    } else {\n      values.push(buildBlock(block, parent, []));\n    }\n  }\n\n  return [keys, values];\n}\n\nfunction buildBlock(\n  block: NormalizedBlock,\n  symbols: Symbols,\n  locals: number[] = []\n): WireFormat.SerializedInlineBlock {\n  return [buildNormalizedStatements(block, symbols), locals];\n}\n","export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import type { CurriedType, PresentArray } from '@glimmer/interfaces';\nimport type {\n  ASTv2,\n  BlockSymbolTable,\n  ProgramSymbolTable,\n  SourceSlice,\n  SymbolTable,\n} from '@glimmer/syntax';\nimport { node } from '@glimmer/syntax';\n\nimport type { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';\n\nexport class Template extends node('Template').fields<{\n  scope: ProgramSymbolTable;\n  body: Statement[];\n}>() {}\n\nexport class InElement extends node('InElement').fields<{\n  guid: string;\n  insertBefore: ExpressionNode | Missing;\n  destination: ExpressionNode;\n  block: NamedBlock;\n}>() {}\n\nexport class Not extends node('Not').fields<{ value: ExpressionNode }>() {}\n\nexport class If extends node('If').fields<{\n  condition: ExpressionNode;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class IfInline extends node('IfInline').fields<{\n  condition: ExpressionNode;\n  truthy: ExpressionNode;\n  falsy: ExpressionNode | null;\n}>() {}\n\nexport class Each extends node('Each').fields<{\n  value: ExpressionNode;\n  key: ExpressionNode | null;\n  block: NamedBlock;\n  inverse: NamedBlock | null;\n}>() {}\n\nexport class Let extends node('Let').fields<{\n  positional: Positional;\n  block: NamedBlock;\n}>() {}\n\nexport class WithDynamicVars extends node('WithDynamicVars').fields<{\n  named: NamedArguments;\n  block: NamedBlock;\n}>() {}\n\nexport class GetDynamicVar extends node('GetDynamicVar').fields<{\n  name: ExpressionNode;\n}>() {}\n\nexport class Log extends node('Log').fields<{\n  positional: Positional;\n}>() {}\n\nexport class InvokeComponent extends node('InvokeComponent').fields<{\n  definition: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks | null;\n}>() {}\n\nexport class NamedBlocks extends node('NamedBlocks').fields<{\n  blocks: OptionalList<NamedBlock>;\n}>() {}\n\nexport class NamedBlock extends node('NamedBlock').fields<{\n  scope: BlockSymbolTable;\n  name: SourceSlice;\n  body: Statement[];\n}>() {}\nexport class AppendTrustedHTML extends node('AppendTrustedHTML').fields<{\n  html: ExpressionNode;\n}>() {}\nexport class AppendTextNode extends node('AppendTextNode').fields<{ text: ExpressionNode }>() {}\nexport class AppendComment extends node('AppendComment').fields<{ value: SourceSlice }>() {}\n\nexport class Component extends node('Component').fields<{\n  tag: ExpressionNode;\n  params: ElementParameters;\n  args: NamedArguments;\n  blocks: NamedBlocks;\n}>() {}\n\nexport interface AttrKind {\n  // triple-curly\n  trusting: boolean;\n  // this attribute is on an element with component features:\n  //   - <CapCase ...>\n  //   - modifiers\n  //   - <dynamic.tag ...>\n  component: boolean;\n}\n\nexport class StaticAttr extends node('StaticAttr').fields<{\n  kind: { component: boolean };\n  name: SourceSlice;\n  value: SourceSlice;\n  namespace?: string | undefined;\n}>() {}\n\nexport class DynamicAttr extends node('DynamicAttr').fields<{\n  kind: AttrKind;\n  name: SourceSlice;\n  value: ExpressionNode;\n  namespace?: string | undefined;\n}>() {}\n\nexport class SimpleElement extends node('SimpleElement').fields<{\n  tag: SourceSlice;\n  params: ElementParameters;\n  body: Statement[];\n  dynamicFeatures: boolean;\n}>() {}\n\nexport class ElementParameters extends node('ElementParameters').fields<{\n  body: AnyOptionalList<ElementParameter>;\n}>() {}\n\nexport class Yield extends node('Yield').fields<{\n  target: SourceSlice;\n  to: number;\n  positional: Positional;\n}>() {}\nexport class Debugger extends node('Debugger').fields<{ scope: SymbolTable }>() {}\n\nexport class CallExpression extends node('CallExpression').fields<{\n  callee: ExpressionNode;\n  args: Args;\n}>() {}\n\nexport class Modifier extends node('Modifier').fields<{ callee: ExpressionNode; args: Args }>() {}\nexport class InvokeBlock extends node('InvokeBlock').fields<{\n  head: ExpressionNode;\n  args: Args;\n  blocks: NamedBlocks;\n}>() {}\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\nexport class PathExpression extends node('PathExpression').fields<{\n  head: ExpressionNode;\n  tail: Tail;\n}>() {}\n\nexport class Missing extends node('Missing').fields() {}\nexport class InterpolateExpression extends node('InterpolateExpression').fields<{\n  parts: PresentList<ExpressionNode>;\n}>() {}\nexport class HasBlock extends node('HasBlock').fields<{ target: SourceSlice; symbol: number }>() {}\nexport class HasBlockParams extends node('HasBlockParams').fields<{\n  target: SourceSlice;\n  symbol: number;\n}>() {}\nexport class Curry extends node('Curry').fields<{\n  definition: ExpressionNode;\n  curriedType: CurriedType;\n  args: Args;\n}>() {}\nexport class Positional extends node('Positional').fields<{\n  list: OptionalList<ExpressionNode>;\n}>() {}\nexport class NamedArguments extends node('NamedArguments').fields<{\n  entries: OptionalList<NamedArgument>;\n}>() {}\nexport class NamedArgument extends node('NamedArgument').fields<{\n  key: SourceSlice;\n  value: ExpressionNode;\n}>() {}\nexport class Args extends node('Args').fields<{\n  positional: Positional;\n  named: NamedArguments;\n}>() {}\nexport class Tail extends node('Tail').fields<{ members: PresentArray<SourceSlice> }>() {}\n\nexport type ExpressionNode =\n  | ASTv2.LiteralExpression\n  | ASTv2.KeywordExpression\n  | ASTv2.VariableReference\n  | Missing\n  | PathExpression\n  | InterpolateExpression\n  | CallExpression\n  | Not\n  | IfInline\n  | HasBlock\n  | HasBlockParams\n  | Curry\n  | GetDynamicVar\n  | Log;\n\nexport type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;\n\nexport type Internal =\n  | Args\n  | Positional\n  | NamedArguments\n  | NamedArgument\n  | Tail\n  | NamedBlock\n  | NamedBlocks\n  | ElementParameters;\nexport type ExprLike = ExpressionNode | Internal;\nexport type Statement =\n  | InElement\n  | Debugger\n  | Yield\n  | AppendTrustedHTML\n  | AppendTextNode\n  | Component\n  | SimpleElement\n  | InvokeBlock\n  | AppendComment\n  | If\n  | Each\n  | Let\n  | WithDynamicVars\n  | InvokeComponent;\n","import type { Nullable, PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray, mapPresentArray } from '@glimmer/util';\n\nexport interface OptionalList<T> {\n  map<U>(callback: (input: T) => U): MapList<T, U, AnyOptionalList<T>>;\n  filter<S extends T>(\n    predicate: (value: T, index: number, array: T[]) => value is S\n  ): AnyOptionalList<S>;\n  toArray(): T[];\n  toPresentArray(): Nullable<PresentArray<T>>;\n  into<U, V>(options: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V;\n}\n\nexport class PresentList<T> implements OptionalList<T> {\n  constructor(readonly list: PresentArray<T>) {}\n\n  toArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  map<U>(callback: (input: T) => U): MapList<T, U, PresentList<T>> {\n    let result = mapPresentArray(this.list, callback);\n    return new PresentList(result) as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(predicate: (value: T) => value is S): AnyOptionalList<S> {\n    let out: S[] = [];\n\n    for (let item of this.list) {\n      if (predicate(item)) {\n        out.push(item);\n      }\n    }\n\n    return OptionalList(out);\n  }\n\n  toPresentArray(): PresentArray<T> {\n    return this.list;\n  }\n\n  into<U, V>({ ifPresent }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifPresent(this);\n  }\n}\n\nexport class EmptyList<T> implements OptionalList<T> {\n  readonly list: T[] = [];\n\n  map<U>(_callback: (input: T) => U): MapList<T, U, EmptyList<T>> {\n    return new EmptyList() as MapList<T, U, this>;\n  }\n\n  filter<S extends T>(_predicate: (value: T) => value is S): AnyOptionalList<S> {\n    return new EmptyList();\n  }\n\n  toArray(): T[] {\n    return this.list;\n  }\n\n  toPresentArray(): Nullable<PresentArray<T>> {\n    return null;\n  }\n\n  into<U, V>({ ifEmpty }: { ifPresent: (array: PresentList<T>) => U; ifEmpty: () => V }): U | V {\n    return ifEmpty();\n  }\n}\n\n// export type OptionalList<T> = PresentList<T> | EmptyList<T>;\n\nexport function OptionalList<T>(value: readonly T[]): AnyOptionalList<T> {\n  if (isPresentArray(value)) {\n    return new PresentList(value);\n  } else {\n    return new EmptyList<T>();\n  }\n}\n\nexport type AnyOptionalList<T> = (PresentList<T> | EmptyList<T>) & OptionalList<T>;\n\nexport type MapList<T, U, L extends OptionalList<T>> = L extends PresentList<T>\n  ? PresentList<U>\n  : L extends EmptyList<T>\n    ? EmptyList<U>\n    : never;\n","import type { GlimmerSyntaxError } from '@glimmer/syntax';\n\nimport type { AnyOptionalList } from './list';\n\nimport { OptionalList } from './list';\n\nabstract class ResultImpl<T> {\n  static all<T extends Result<unknown>[]>(...results: T): MapAll<T> {\n    let out: unknown[] = [];\n\n    for (let result of results) {\n      if (result.isErr) {\n        return result.cast();\n      } else {\n        out.push(result.value);\n      }\n    }\n\n    return Ok(out as MapAllOk<T>);\n  }\n\n  abstract mapOk<U>(callback: (value: T) => U): Result<U>;\n  abstract readonly isOk: boolean;\n  abstract readonly isErr: boolean;\n}\n\nexport const Result = ResultImpl;\n\nclass OkImpl<T> extends ResultImpl<T> {\n  readonly isOk = true;\n  readonly isErr = false;\n\n  constructor(readonly value: T) {\n    super();\n  }\n\n  expect(_message?: string): T {\n    return this.value;\n  }\n\n  ifOk(callback: (value: T) => void): this {\n    callback(this.value);\n    return this;\n  }\n\n  andThen<U>(callback: (value: T) => Result<U>): Result<U> {\n    return callback(this.value);\n  }\n\n  mapOk<U>(callback: (value: T) => U): Result<U> {\n    return Ok(callback(this.value));\n  }\n\n  ifErr(_callback: (value: GlimmerSyntaxError) => void): this {\n    return this;\n  }\n\n  mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return this;\n  }\n}\n\nclass ErrImpl<T> extends ResultImpl<T> {\n  readonly isOk = false;\n  readonly isErr = true;\n\n  constructor(readonly reason: GlimmerSyntaxError) {\n    super();\n  }\n\n  expect(message?: string): T {\n    throw new Error(message || 'expected an Ok, got Err');\n  }\n\n  andThen<U>(_callback: (value: T) => Result<U>): Result<U> {\n    return this.cast<U>();\n  }\n\n  mapOk<U>(_callback: (value: T) => U): Result<U> {\n    return this.cast<U>();\n  }\n\n  ifOk(_callback: (value: T) => void): this {\n    return this;\n  }\n\n  mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T> {\n    return Err(callback(this.reason));\n  }\n\n  ifErr(callback: (value: GlimmerSyntaxError) => void): this {\n    callback(this.reason);\n    return this;\n  }\n\n  cast<U>(): Result<U> {\n    return this as unknown as Result<U>;\n  }\n}\n\nexport function isResult<T>(input: MaybeResult<T>): input is Result<T> {\n  return input instanceof ResultImpl;\n}\n\nexport function intoResult<T>(input: MaybeResult<T>): Result<T> {\n  if (isResult(input)) {\n    return input;\n  } else {\n    return Ok(input);\n  }\n}\n\nexport type Result<T> = OkImpl<T> | ErrImpl<T>;\n\ntype MapAllOk<T extends Result<unknown>[]> = {\n  [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;\n};\n\ntype MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;\n\nexport function Ok<T>(value: T): Result<T> {\n  return new OkImpl(value);\n}\n\nexport type Ok<T> = OkImpl<T>;\n\nexport function Err<T>(reason: GlimmerSyntaxError): Result<T> {\n  return new ErrImpl(reason);\n}\n\nexport type Err<T> = ErrImpl<T>;\n\nexport type MaybeResult<T> = T | Result<T>;\n\nexport class MapIntoResultArray<T> {\n  constructor(private items: T[]) {}\n\n  map<U>(mapper: (item: T) => Result<U>): Result<U[]> {\n    let out = new ResultArray<U>();\n\n    for (let item of this.items) {\n      out.add(mapper(item));\n    }\n\n    return out.toArray();\n  }\n}\n\nexport class ResultArray<T> {\n  constructor(private items: Result<T>[] = []) {}\n\n  add(item: Result<T>): void {\n    this.items.push(item);\n  }\n\n  toArray(): Result<T[]> {\n    let err = this.items.filter((item): item is ErrImpl<T> => item instanceof ErrImpl)[0];\n\n    if (err !== undefined) {\n      return err.cast<T[]>();\n    } else {\n      return Ok((this.items as OkImpl<T>[]).map((item) => item.value));\n    }\n  }\n\n  toOptionalList(): Result<AnyOptionalList<T>> {\n    return this.toArray().mapOk((arr) => OptionalList(arr));\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { getLast, isPresentArray } from '@glimmer/util';\n\nimport type { AnyOptionalList, PresentList } from '../../../shared/list';\nimport type { NormalizationState } from '../context';\n\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { CALL_KEYWORDS } from '../keywords';\n\nexport class NormalizeExpressions {\n  visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode> {\n    switch (node.type) {\n      case 'Literal':\n        return Ok(this.Literal(node));\n      case 'Keyword':\n        return Ok(this.Keyword(node));\n      case 'Interpolate':\n        return this.Interpolate(node, state);\n      case 'Path':\n        return this.PathExpression(node);\n      case 'Call': {\n        let translated = CALL_KEYWORDS.translate(node, state);\n\n        if (translated !== null) {\n          return translated;\n        }\n\n        return this.CallExpression(node, state);\n      }\n    }\n  }\n\n  visitList(\n    nodes: PresentArray<ASTv2.ExpressionNode>,\n    state: NormalizationState\n  ): Result<PresentList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>>;\n  visitList(\n    nodes: readonly ASTv2.ExpressionNode[],\n    state: NormalizationState\n  ): Result<AnyOptionalList<mir.ExpressionNode>> {\n    return new ResultArray(nodes.map((e) => VISIT_EXPRS.visit(e, state))).toOptionalList();\n  }\n\n  /**\n   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.\n   *\n   * TODO since keywords don't support tails anyway, distinguish PathExpression from\n   * VariableReference in ASTv2.\n   */\n  PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode> {\n    let ref = this.VariableReference(path.ref);\n    let { tail } = path;\n\n    if (isPresentArray(tail)) {\n      let tailLoc = tail[0].loc.extend(getLast(tail).loc);\n      return Ok(\n        new mir.PathExpression({\n          loc: path.loc,\n          head: ref,\n          tail: new mir.Tail({ loc: tailLoc, members: tail }),\n        })\n      );\n    } else {\n      return Ok(ref);\n    }\n  }\n\n  VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference {\n    return ref;\n  }\n\n  Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression {\n    return literal;\n  }\n\n  Keyword(keyword: ASTv2.KeywordExpression): ASTv2.KeywordExpression {\n    return keyword;\n  }\n\n  Interpolate(\n    expr: ASTv2.InterpolateExpression,\n    state: NormalizationState\n  ): Result<mir.InterpolateExpression> {\n    let parts = expr.parts.map(convertPathToCallIfKeyword) as PresentArray<ASTv2.ExpressionNode>;\n\n    return VISIT_EXPRS.visitList(parts, state).mapOk(\n      (parts) => new mir.InterpolateExpression({ loc: expr.loc, parts: parts })\n    );\n  }\n\n  CallExpression(\n    expr: ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<mir.ExpressionNode> {\n    if (expr.callee.type === 'Call') {\n      throw new Error(`unimplemented: subexpression at the head of a subexpression`);\n    } else {\n      return Result.all(\n        VISIT_EXPRS.visit(expr.callee, state),\n        VISIT_EXPRS.Args(expr.args, state)\n      ).mapOk(\n        ([callee, args]) =>\n          new mir.CallExpression({\n            loc: expr.loc,\n            callee,\n            args,\n          })\n      );\n    }\n  }\n\n  Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args> {\n    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(\n      ([positional, named]) =>\n        new mir.Args({\n          loc,\n          positional,\n          named,\n        })\n    );\n  }\n\n  Positional(\n    positional: ASTv2.PositionalArguments,\n    state: NormalizationState\n  ): Result<mir.Positional> {\n    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(\n      (list) =>\n        new mir.Positional({\n          loc: positional.loc,\n          list,\n        })\n    );\n  }\n\n  NamedArguments(\n    named: ASTv2.NamedArguments,\n    state: NormalizationState\n  ): Result<mir.NamedArguments> {\n    let pairs = named.entries.map((arg) => {\n      let value = convertPathToCallIfKeyword(arg.value);\n\n      return VISIT_EXPRS.visit(value, state).mapOk(\n        (value) =>\n          new mir.NamedArgument({\n            loc: arg.loc,\n            key: arg.name,\n            value,\n          })\n      );\n    });\n\n    return new ResultArray(pairs)\n      .toOptionalList()\n      .mapOk((pairs) => new mir.NamedArguments({ loc: named.loc, entries: pairs }));\n  }\n}\n\nexport function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode {\n  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {\n    return new ASTv2.CallExpression({\n      callee: path,\n      args: ASTv2.Args.empty(path.loc),\n      loc: path.loc,\n    });\n  }\n\n  return path;\n}\n\nexport const VISIT_EXPRS = new NormalizeExpressions();\n","import type { ASTv2, KeywordType } from '@glimmer/syntax';\nimport { generateSyntaxError, isKeyword, KEYWORDS_TYPES } from '@glimmer/syntax';\nimport { exhausted } from '@glimmer/util';\n\nimport type { Result } from '../../../shared/result';\nimport type { NormalizationState } from '../context';\n\nimport { Err } from '../../../shared/result';\n\nexport interface KeywordDelegate<Match extends KeywordMatch, V, Out> {\n  assert(options: Match, state: NormalizationState): Result<V>;\n  translate(options: { node: Match; state: NormalizationState }, param: V): Result<Out>;\n}\n\nexport interface Keyword<K extends KeywordType = KeywordType, Out = unknown> {\n  translate(node: KeywordCandidates[K], state: NormalizationState): Result<Out> | null;\n}\n\nexport interface BlockKeyword<Out = unknown> {\n  translate(node: ASTv2.InvokeBlock, state: NormalizationState): Result<Out> | null;\n}\n\nclass KeywordImpl<\n  K extends KeywordType,\n  S extends string = string,\n  Param = unknown,\n  Out = unknown,\n> {\n  protected types: Set<KeywordCandidates[K]['type']>;\n\n  constructor(\n    protected keyword: S,\n    type: KeywordType,\n    private delegate: KeywordDelegate<KeywordMatches[K], Param, Out>\n  ) {\n    let nodes = new Set<KeywordNode['type']>();\n    for (let nodeType of KEYWORD_NODES[type]) {\n      nodes.add(nodeType);\n    }\n\n    this.types = nodes;\n  }\n\n  protected match(node: KeywordCandidates[K]): node is KeywordMatches[K] {\n    if (!this.types.has(node.type)) {\n      return false;\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path !== null && path.type === 'Path' && path.ref.type === 'Free') {\n      return path.ref.name === this.keyword;\n    } else {\n      return false;\n    }\n  }\n\n  translate(node: KeywordMatches[K], state: NormalizationState): Result<Out> | null {\n    if (this.match(node)) {\n      let path = getCalleeExpression(node);\n\n      if (path !== null && path.type === 'Path' && path.tail.length > 0) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${\n              this.keyword\n            }\\` keyword was used incorrectly. It was used as \\`${path.loc.asString()}\\`, but it cannot be used with additional path segments. \\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n\n      let param = this.delegate.assert(node, state);\n      return param.andThen((param) => this.delegate.translate({ node, state }, param));\n    } else {\n      return null;\n    }\n  }\n}\n\nexport const KEYWORD_NODES = {\n  Call: ['Call'],\n  Block: ['InvokeBlock'],\n  Append: ['AppendContent'],\n  Modifier: ['ElementModifier'],\n} as const;\n\nexport interface KeywordCandidates {\n  Call: ASTv2.ExpressionNode;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordCandidate = KeywordCandidates[keyof KeywordCandidates];\n\nexport interface KeywordMatches {\n  Call: ASTv2.CallExpression;\n  Block: ASTv2.InvokeBlock;\n  Append: ASTv2.AppendContent;\n  Modifier: ASTv2.ElementModifier;\n}\n\nexport type KeywordMatch = KeywordMatches[keyof KeywordMatches];\n\n/**\n * A \"generic\" keyword is something like `has-block`, which makes sense in the context\n * of sub-expression or append\n */\nexport type GenericKeywordNode = ASTv2.AppendContent | ASTv2.CallExpression;\n\nexport type KeywordNode =\n  | GenericKeywordNode\n  | ASTv2.CallExpression\n  | ASTv2.InvokeBlock\n  | ASTv2.ElementModifier;\n\nexport function keyword<\n  K extends KeywordType,\n  D extends KeywordDelegate<KeywordMatches[K], unknown, Out>,\n  Out = unknown,\n>(keyword: string, type: K, delegate: D): Keyword<K, Out> {\n  return new KeywordImpl(keyword, type, delegate as KeywordDelegate<KeywordMatch, unknown, Out>);\n}\n\nexport type PossibleKeyword = KeywordNode;\ntype OutFor<K extends Keyword | BlockKeyword> = K extends BlockKeyword<infer Out>\n  ? Out\n  : K extends Keyword<KeywordType, infer Out>\n    ? Out\n    : never;\n\nfunction getCalleeExpression(\n  node: KeywordNode | ASTv2.ExpressionNode\n): ASTv2.ExpressionNode | null {\n  switch (node.type) {\n    // This covers the inside of attributes and expressions, as well as the callee\n    // of call nodes\n    case 'Path':\n      return node;\n    case 'AppendContent':\n      return getCalleeExpression(node.value);\n    case 'Call':\n    case 'InvokeBlock':\n    case 'ElementModifier':\n      return node.callee;\n    default:\n      return null;\n  }\n}\n\nexport class Keywords<K extends KeywordType, KeywordList extends Keyword<K> = never>\n  implements Keyword<K, OutFor<KeywordList>>\n{\n  _keywords: Keyword[] = [];\n  _type: K;\n\n  constructor(type: K) {\n    this._type = type;\n  }\n\n  kw<S extends string = string, Out = unknown>(\n    name: S,\n    delegate: KeywordDelegate<KeywordMatches[K], unknown, Out>\n  ): Keywords<K, KeywordList | Keyword<K, Out>> {\n    this._keywords.push(keyword(name, this._type, delegate));\n\n    return this;\n  }\n\n  translate(\n    node: KeywordCandidates[K],\n    state: NormalizationState\n  ): Result<OutFor<KeywordList>> | null {\n    for (let keyword of this._keywords) {\n      let result = keyword.translate(node, state) as Result<OutFor<KeywordList>>;\n      if (result !== null) {\n        return result;\n      }\n    }\n\n    let path = getCalleeExpression(node);\n\n    if (path && path.type === 'Path' && path.ref.type === 'Free' && isKeyword(path.ref.name)) {\n      let { name } = path.ref as { name: keyof typeof KEYWORDS_TYPES };\n\n      let usedType = this._type;\n      let validTypes: readonly KeywordType[] = KEYWORDS_TYPES[name];\n\n      if (!validTypes.includes(usedType)) {\n        return Err(\n          generateSyntaxError(\n            `The \\`${name}\\` keyword was used incorrectly. It was used as ${\n              typesToReadableName[usedType]\n            }, but its valid usages are:\\n\\n${generateTypesMessage(\n              name,\n              validTypes\n            )}\\n\\nError caused by`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    return null;\n  }\n}\n\nconst typesToReadableName = {\n  Append: 'an append statement',\n  Block: 'a block statement',\n  Call: 'a call expression',\n  Modifier: 'a modifier',\n};\n\nfunction generateTypesMessage(name: string, types: readonly KeywordType[]): string {\n  return types\n    .map((type) => {\n      switch (type) {\n        case 'Append':\n          return `- As an append statement, as in: {{${name}}}`;\n        case 'Block':\n          return `- As a block statement, as in: {{#${name}}}{{/${name}}}`;\n        case 'Call':\n          return `- As an expression, as in: (${name})`;\n        case 'Modifier':\n          return `- As a modifier, as in: <div {{${name}}}></div>`;\n        default:\n          return exhausted(type);\n      }\n    })\n    .join('\\n\\n');\n}\n\n/**\n * This function builds keyword definitions for a particular type of AST node (`KeywordType`).\n *\n * You can build keyword definitions for:\n *\n * - `Expr`: A `SubExpression` or `PathExpression`\n * - `Block`: A `BlockStatement`\n *   - A `BlockStatement` is a keyword candidate if its head is a\n *     `PathExpression`\n * - `Append`: An `AppendStatement`\n *\n * A node is a keyword candidate if:\n *\n * - A `PathExpression` is a keyword candidate if it has no tail, and its\n *   head expression is a `LocalVarHead` or `FreeVarHead` whose name is\n *   the keyword's name.\n * - A `SubExpression`, `AppendStatement`, or `BlockStatement` is a keyword\n *   candidate if its head is a keyword candidate.\n *\n * The keyword infrastructure guarantees that:\n *\n * - If a node is not a keyword candidate, it is never passed to any keyword's\n *   `assert` method.\n * - If a node is not the `KeywordType` for a particular keyword, it will not\n *   be passed to the keyword's `assert` method.\n *\n * `Expr` keywords are used in expression positions and should return HIR\n * expressions. `Block` and `Append` keywords are used in statement\n * positions and should return HIR statements.\n *\n * A keyword definition has two parts:\n *\n * - `match`, which determines whether an AST node matches the keyword, and can\n *   optionally return some information extracted from the AST node.\n * - `translate`, which takes a matching AST node as well as the extracted\n *   information and returns an appropriate HIR instruction.\n *\n * # Example\n *\n * This keyword:\n *\n * - turns `(hello)` into `\"hello\"`\n *   - as long as `hello` is not in scope\n * - makes it an error to pass any arguments (such as `(hello world)`)\n *\n * ```ts\n * keywords('SubExpr').kw('hello', {\n *   assert(node: ExprKeywordNode): Result<void> | false {\n *     // we don't want to transform `hello` as a `PathExpression`\n *     if (node.type !== 'SubExpression') {\n *       return false;\n *     }\n *\n *     // node.head would be `LocalVarHead` if `hello` was in scope\n *     if (node.head.type !== 'FreeVarHead') {\n *       return false;\n *     }\n *\n *     if (node.params.length || node.hash) {\n *       return Err(generateSyntaxError(`(hello) does not take any arguments`), node.loc);\n *     } else {\n *       return Ok();\n *     }\n *   },\n *\n *   translate(node: ASTv2.SubExpression): hir.Expression {\n *     return ASTv2.builders.literal(\"hello\", node.loc)\n *   }\n * })\n * ```\n *\n * The keyword infrastructure checks to make sure that the node is the right\n * type before calling `assert`, so you only need to consider `SubExpression`\n * and `PathExpression` here. It also checks to make sure that the node passed\n * to `assert` has the keyword name in the right place.\n *\n * Note the important difference between returning `false` from `assert`,\n * which just means that the node didn't match, and returning `Err`, which\n * means that the node matched, but there was a keyword-specific syntax\n * error.\n */\nexport function keywords<K extends KeywordType>(type: K): Keywords<K> {\n  return new Keywords(type);\n}\n","import type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport * as mir from '../../../2-encoding/mir';\n\nexport function toAppend<T>({\n  assert,\n  translate,\n}: KeywordDelegate<GenericKeywordNode, T, mir.ExpressionNode>): KeywordDelegate<\n  GenericKeywordNode,\n  T,\n  mir.AppendTextNode\n> {\n  return {\n    assert,\n    translate(\n      { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n      value: T\n    ): Result<mir.AppendTextNode> {\n      let result = translate({ node, state }, value);\n\n      return result.mapOk((text) => new mir.AppendTextNode({ text, loc: node.loc }));\n    },\n  };\n}\n","import type { CurriedType } from '@glimmer/interfaces';\nimport { ASTv2, generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nconst CurriedTypeToReadableType = {\n  [CurriedTypes.Component]: 'component',\n  [CurriedTypes.Helper]: 'helper',\n  [CurriedTypes.Modifier]: 'modifier',\n} as const;\n\nexport function assertCurryKeyword(curriedType: CurriedType) {\n  return (\n    node: ASTv2.AppendContent | ASTv2.InvokeBlock | ASTv2.CallExpression,\n    state: NormalizationState\n  ): Result<{\n    definition: ASTv2.ExpressionNode;\n    args: ASTv2.Args;\n  }> => {\n    let readableType = CurriedTypeToReadableType[curriedType];\n    let stringsAllowed = curriedType === CurriedTypes.Component;\n\n    let { args } = node;\n\n    let definition = args.nth(0);\n\n    if (definition === null) {\n      return Err(\n        generateSyntaxError(\n          `(${readableType}) requires a ${readableType} definition or identifier as its first positional parameter, did not receive any parameters.`,\n          args.loc\n        )\n      );\n    }\n\n    if (definition.type === 'Literal') {\n      if (stringsAllowed && state.isStrict) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values in strict mode templates`,\n            node.loc\n          )\n        );\n      } else if (!stringsAllowed) {\n        return Err(\n          generateSyntaxError(\n            `(${readableType}) cannot resolve string values, you must pass a ${readableType} definition directly`,\n            node.loc\n          )\n        );\n      }\n    }\n\n    args = new ASTv2.Args({\n      positional: new ASTv2.PositionalArguments({\n        exprs: args.positional.exprs.slice(1),\n        loc: args.positional.loc,\n      }),\n      named: args.named,\n      loc: args.loc,\n    });\n\n    return Ok({ definition, args });\n  };\n}\n\nfunction translateCurryKeyword(curriedType: CurriedType) {\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.CallExpression | ASTv2.AppendContent; state: NormalizationState },\n    { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n  ): Result<mir.Curry> => {\n    let definitionResult = VISIT_EXPRS.visit(definition, state);\n    let argsResult = VISIT_EXPRS.Args(args, state);\n\n    return Result.all(definitionResult, argsResult).mapOk(\n      ([definition, args]) =>\n        new mir.Curry({\n          loc: node.loc,\n          curriedType,\n          definition,\n          args,\n        })\n    );\n  };\n}\n\nexport function curryKeyword(\n  curriedType: CurriedType\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  { definition: ASTv2.ExpressionNode; args: ASTv2.Args },\n  mir.Curry\n> {\n  return {\n    assert: assertCurryKeyword(curriedType),\n    translate: translateCurryKeyword(curriedType),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertGetDynamicVarKeyword(node: GenericKeywordNode): Result<ASTv2.ExpressionNode> {\n  let call = node.type === 'AppendContent' ? node.value : node;\n\n  let named = call.type === 'Call' ? call.args.named : null;\n  let positionals = call.type === 'Call' ? call.args.positional : null;\n\n  if (named && !named.isEmpty()) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) does not take any named arguments`, node.loc)\n    );\n  }\n\n  let varName = positionals?.nth(0);\n\n  if (!varName) {\n    return Err(generateSyntaxError(`(-get-dynamic-vars) requires a var name to get`, node.loc));\n  }\n\n  if (positionals && positionals.size > 1) {\n    return Err(\n      generateSyntaxError(`(-get-dynamic-vars) only receives one positional arg`, node.loc)\n    );\n  }\n\n  return Ok(varName);\n}\n\nfunction translateGetDynamicVarKeyword(\n  { node, state }: { node: GenericKeywordNode; state: NormalizationState },\n  name: ASTv2.ExpressionNode\n): Result<mir.GetDynamicVar> {\n  return VISIT_EXPRS.visit(name, state).mapOk(\n    (name) => new mir.GetDynamicVar({ name, loc: node.loc })\n  );\n}\n\nexport const getDynamicVarKeyword: KeywordDelegate<\n  GenericKeywordNode,\n  ASTv2.ExpressionNode,\n  mir.GetDynamicVar\n> = {\n  assert: assertGetDynamicVarKeyword,\n  translate: translateGetDynamicVarKeyword,\n};\n","import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\n\nfunction assertHasBlockKeyword(type: string) {\n  return (node: GenericKeywordNode): Result<SourceSlice> => {\n    let call = node.type === 'AppendContent' ? node.value : node;\n\n    let named = call.type === 'Call' ? call.args.named : null;\n    let positionals = call.type === 'Call' ? call.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));\n    }\n\n    if (!positionals || positionals.isEmpty()) {\n      return Ok(SourceSlice.synthetic('default'));\n    } else if (positionals.exprs.length === 1) {\n      let positional = positionals.exprs[0] as ASTv2.ExpressionNode;\n      if (ASTv2.isLiteral(positional, 'string')) {\n        return Ok(positional.toSlice());\n      } else {\n        return Err(\n          generateSyntaxError(\n            `(${type}) can only receive a string literal as its first argument`,\n            call.loc\n          )\n        );\n      }\n    } else {\n      return Err(\n        generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc)\n      );\n    }\n  };\n}\n\nfunction translateHasBlockKeyword(type: string) {\n  return (\n    { node, state: { scope } }: { node: ASTv2.CallExpression; state: NormalizationState },\n    target: SourceSlice\n  ): Result<mir.HasBlock | mir.HasBlockParams> => {\n    let block =\n      type === 'has-block'\n        ? new mir.HasBlock({ loc: node.loc, target, symbol: scope.allocateBlock(target.chars) })\n        : new mir.HasBlockParams({\n            loc: node.loc,\n            target,\n            symbol: scope.allocateBlock(target.chars),\n          });\n\n    return Ok(block);\n  };\n}\n\nexport function hasBlockKeyword(\n  type: string\n): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  SourceSlice,\n  mir.HasBlock | mir.HasBlockParams\n> {\n  return {\n    assert: assertHasBlockKeyword(type),\n    translate: translateHasBlockKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\nimport type { KeywordDelegate } from '../impl';\n\nimport { Err, Ok, Result } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertIfUnlessInlineKeyword(type: string) {\n  return (\n    originalNode: ASTv2.AppendContent | ASTv2.ExpressionNode\n  ): Result<{\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  }> => {\n    let inverted = type === 'unless';\n\n    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;\n    let named = node.type === 'Call' ? node.args.named : null;\n    let positional = node.type === 'Call' ? node.args.positional : null;\n\n    if (named && !named.isEmpty()) {\n      return Err(\n        generateSyntaxError(\n          `(${type}) cannot receive named parameters, received ${named.entries\n            .map((e) => e.name.chars)\n            .join(', ')}`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let condition = positional?.nth(0);\n\n    if (!positional || !condition) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Did not receive any parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    let truthy = positional.nth(1);\n    let falsy = positional.nth(2);\n\n    if (truthy === null) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }. Received only one parameter, the condition`,\n          originalNode.loc\n        )\n      );\n    }\n\n    if (positional.size > 3) {\n      return Err(\n        generateSyntaxError(\n          `When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${\n            inverted ? 'false' : 'true'\n          }, and 3. the value to return if the condition is ${\n            inverted ? 'true' : 'false'\n          }. Received ${positional?.size ?? 0} parameters`,\n          originalNode.loc\n        )\n      );\n    }\n\n    return Ok({ condition, truthy, falsy });\n  };\n}\n\nfunction translateIfUnlessInlineKeyword(type: string) {\n  let inverted = type === 'unless';\n\n  return (\n    {\n      node,\n      state,\n    }: { node: ASTv2.AppendContent | ASTv2.ExpressionNode; state: NormalizationState },\n    {\n      condition,\n      truthy,\n      falsy,\n    }: {\n      condition: ASTv2.ExpressionNode;\n      truthy: ASTv2.ExpressionNode;\n      falsy: ASTv2.ExpressionNode | null;\n    }\n  ): Result<mir.IfInline> => {\n    let conditionResult = VISIT_EXPRS.visit(condition, state);\n    let truthyResult = VISIT_EXPRS.visit(truthy, state);\n    let falsyResult = falsy ? VISIT_EXPRS.visit(falsy, state) : Ok(null);\n\n    return Result.all(conditionResult, truthyResult, falsyResult).mapOk(\n      ([condition, truthy, falsy]) => {\n        if (inverted) {\n          condition = new mir.Not({ value: condition, loc: node.loc });\n        }\n\n        return new mir.IfInline({\n          loc: node.loc,\n          condition,\n          truthy,\n          falsy,\n        });\n      }\n    );\n  };\n}\n\nexport function ifUnlessInlineKeyword(type: string): KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  {\n    condition: ASTv2.ExpressionNode;\n    truthy: ASTv2.ExpressionNode;\n    falsy: ASTv2.ExpressionNode | null;\n  },\n  mir.IfInline\n> {\n  return {\n    assert: assertIfUnlessInlineKeyword(type),\n    translate: translateIfUnlessInlineKeyword(type),\n  };\n}\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { GenericKeywordNode, KeywordDelegate } from '../impl';\n\nimport { Err, Ok } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../../visitors/expressions';\n\nfunction assertLogKeyword(node: GenericKeywordNode): Result<ASTv2.PositionalArguments> {\n  let {\n    args: { named, positional },\n  } = node;\n\n  if (named && !named.isEmpty()) {\n    return Err(generateSyntaxError(`(log) does not take any named arguments`, node.loc));\n  }\n\n  return Ok(positional);\n}\n\nfunction translateLogKeyword(\n  { node, state }: { node: ASTv2.CallExpression; state: NormalizationState },\n  positional: ASTv2.PositionalArguments\n): Result<mir.Log> {\n  return VISIT_EXPRS.Positional(positional, state).mapOk(\n    (positional) => new mir.Log({ positional, loc: node.loc })\n  );\n}\n\nexport const logKeyword: KeywordDelegate<\n  ASTv2.CallExpression | ASTv2.AppendContent,\n  ASTv2.PositionalArguments,\n  mir.Log\n> = {\n  assert: assertLogKeyword,\n  translate: translateLogKeyword,\n};\n","import { ASTv2, generateSyntaxError, src } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { keywords } from './impl';\nimport { toAppend } from './utils/call-to-append';\nimport { assertCurryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const APPEND_KEYWORDS = keywords('Append')\n  .kw('has-block', toAppend(hasBlockKeyword('has-block')))\n  .kw('has-block-params', toAppend(hasBlockKeyword('has-block-params')))\n  .kw('-get-dynamic-var', toAppend(getDynamicVarKeyword))\n  .kw('log', toAppend(logKeyword))\n  .kw('if', toAppend(ifUnlessInlineKeyword('if')))\n  .kw('unless', toAppend(ifUnlessInlineKeyword('unless')))\n  .kw('yield', {\n    assert(node: ASTv2.AppendContent): Result<{\n      target: src.SourceSlice;\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (args.named.isEmpty()) {\n        return Ok({\n          target: src.SourceSpan.synthetic('default').toSlice(),\n          positional: args.positional,\n        });\n      } else {\n        let target = args.named.get('to');\n\n        if (args.named.size > 1 || target === null) {\n          return Err(\n            generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc)\n          );\n        }\n\n        if (ASTv2.isLiteral(target, 'string')) {\n          return Ok({ target: target.toSlice(), positional: args.positional });\n        } else {\n          return Err(\n            generateSyntaxError(`you can only yield to a literal string value`, target.loc)\n          );\n        }\n      }\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      {\n        target,\n        positional,\n      }: {\n        target: src.SourceSlice;\n        positional: ASTv2.PositionalArguments;\n      }\n    ): Result<mir.Statement> {\n      return VISIT_EXPRS.Positional(positional, state).mapOk(\n        (positional) =>\n          new mir.Yield({\n            loc: node.loc,\n            target,\n            to: state.scope.allocateBlock(target.chars),\n            positional,\n          })\n      );\n    },\n  })\n  .kw('debugger', {\n    assert(node: ASTv2.AppendContent): Result<void> {\n      let { args } = node;\n      let { positional } = args;\n\n      if (args.isEmpty()) {\n        return Ok(undefined);\n      } else {\n        if (positional.isEmpty()) {\n          return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));\n        } else {\n          return Err(\n            generateSyntaxError(`debugger does not take any positional arguments`, node.loc)\n          );\n        }\n      }\n    },\n\n    translate({\n      node,\n      state: { scope },\n    }: {\n      node: ASTv2.AppendContent;\n      state: NormalizationState;\n    }): Result<mir.Statement> {\n      scope.setHasDebugger();\n      return Ok(new mir.Debugger({ loc: node.loc, scope }));\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(\n        ([definition, args]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks: null,\n          })\n      );\n    },\n  })\n  .kw('helper', {\n    assert: assertCurryKeyword(CurriedTypes.Helper),\n\n    translate(\n      { node, state }: { node: ASTv2.AppendContent; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.AppendTextNode> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n\n      return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {\n        let text = new mir.CallExpression({ callee: definition, args, loc: node.loc });\n\n        return new mir.AppendTextNode({\n          loc: node.loc,\n          text,\n        });\n      });\n    },\n  });\n","import type { ASTv2 } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { NormalizationState } from '../context';\n\nimport { Err, Ok, Result } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { VISIT_EXPRS } from '../visitors/expressions';\nimport { VISIT_STMTS } from '../visitors/statements';\nimport { keywords } from './impl';\nimport { assertCurryKeyword } from './utils/curry';\n\nexport const BLOCK_KEYWORDS = keywords('Block')\n  .kw('in-element', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      insertBefore: ASTv2.ExpressionNode | null;\n      destination: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      let guid = args.get('guid');\n\n      if (guid) {\n        return Err(generateSyntaxError(`Cannot pass \\`guid\\` to \\`{{#in-element}}\\``, guid.loc));\n      }\n\n      let insertBefore = args.get('insertBefore');\n      let destination = args.nth(0);\n\n      if (destination === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#in-element}} requires a target element as its first positional parameter`,\n            args.loc\n          )\n        );\n      }\n\n      // TODO Better syntax checks\n\n      return Ok({ insertBefore, destination });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      {\n        insertBefore,\n        destination,\n      }: { insertBefore: ASTv2.ExpressionNode | null; destination: ASTv2.ExpressionNode }\n    ): Result<mir.InElement> {\n      let named = node.blocks.get('default');\n      let body = VISIT_STMTS.NamedBlock(named, state);\n      let destinationResult = VISIT_EXPRS.visit(destination, state);\n\n      return Result.all(body, destinationResult)\n        .andThen(\n          ([body, destination]): Result<{\n            body: mir.NamedBlock;\n            destination: mir.ExpressionNode;\n            insertBefore: mir.ExpressionNode;\n          }> => {\n            if (insertBefore) {\n              return VISIT_EXPRS.visit(insertBefore, state).mapOk((insertBefore) => ({\n                body,\n                destination,\n                insertBefore,\n              }));\n            } else {\n              return Ok({\n                body,\n                destination,\n                insertBefore: new mir.Missing({\n                  loc: node.callee.loc.collapse('end'),\n                }),\n              });\n            }\n          }\n        )\n        .mapOk(\n          ({ body, destination, insertBefore }) =>\n            new mir.InElement({\n              loc: node.loc,\n              block: body,\n              insertBefore,\n              guid: state.generateUniqueCursor(),\n              destination,\n            })\n        );\n    },\n  })\n  .kw('if', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#if}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('unless', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      condition: ASTv2.ExpressionNode;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            node.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`,\n            node.loc\n          )\n        );\n      }\n\n      let condition = args.nth(0);\n\n      if (condition === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`,\n            node.loc\n          )\n        );\n      }\n\n      return Ok({ condition });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { condition }: { condition: ASTv2.ExpressionNode }\n    ): Result<mir.If> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let conditionResult = VISIT_EXPRS.visit(condition, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(conditionResult, blockResult, inverseResult).mapOk(\n        ([condition, block, inverse]) =>\n          new mir.If({\n            loc: node.loc,\n            condition: new mir.Not({ value: condition, loc: node.loc }),\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('each', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      value: ASTv2.ExpressionNode;\n      key: ASTv2.ExpressionNode | null;\n    }> {\n      let { args } = node;\n\n      if (!args.named.entries.every((e) => e.name.chars === 'key')) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive the 'key' named parameter, received ${args.named.entries\n              .filter((e) => e.name.chars !== 'key')\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size > 1) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      let value = args.nth(0);\n      let key = args.get('key');\n\n      if (value === null) {\n        return Err(\n          generateSyntaxError(\n            `{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`,\n            args.loc\n          )\n        );\n      }\n\n      return Ok({ value, key });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { value, key }: { value: ASTv2.ExpressionNode; key: ASTv2.ExpressionNode | null }\n    ): Result<mir.Each> {\n      let block = node.blocks.get('default');\n      let inverse = node.blocks.get('else');\n\n      let valueResult = VISIT_EXPRS.visit(value, state);\n      let keyResult = key ? VISIT_EXPRS.visit(key, state) : Ok(null);\n\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n      let inverseResult = inverse ? VISIT_STMTS.NamedBlock(inverse, state) : Ok(null);\n\n      return Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(\n        ([value, key, block, inverse]) =>\n          new mir.Each({\n            loc: node.loc,\n            value,\n            key,\n            block,\n            inverse,\n          })\n      );\n    },\n  })\n  .kw('let', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      positional: ASTv2.PositionalArguments;\n    }> {\n      let { args } = node;\n\n      if (!args.named.isEmpty()) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} cannot receive named parameters, received ${args.named.entries\n              .map((e) => e.name.chars)\n              .join(', ')}`,\n            args.named.loc\n          )\n        );\n      }\n\n      if (args.positional.size === 0) {\n        return Err(\n          generateSyntaxError(\n            `{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`,\n            args.positional.loc\n          )\n        );\n      }\n\n      if (node.blocks.get('else')) {\n        return Err(\n          generateSyntaxError(`{{#let}} cannot receive an {{else}} block`, args.positional.loc)\n        );\n      }\n\n      return Ok({ positional: args.positional });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { positional }: { positional: ASTv2.PositionalArguments }\n    ): Result<mir.Let> {\n      let block = node.blocks.get('default');\n\n      let positionalResult = VISIT_EXPRS.Positional(positional, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(positionalResult, blockResult).mapOk(\n        ([positional, block]) =>\n          new mir.Let({\n            loc: node.loc,\n            positional,\n            block,\n          })\n      );\n    },\n  })\n  .kw('-with-dynamic-vars', {\n    assert(node: ASTv2.InvokeBlock): Result<{\n      named: ASTv2.NamedArguments;\n    }> {\n      return Ok({ named: node.args.named });\n    },\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { named }: { named: ASTv2.NamedArguments }\n    ): Result<mir.WithDynamicVars> {\n      let block = node.blocks.get('default');\n\n      let namedResult = VISIT_EXPRS.NamedArguments(named, state);\n      let blockResult = VISIT_STMTS.NamedBlock(block, state);\n\n      return Result.all(namedResult, blockResult).mapOk(\n        ([named, block]) =>\n          new mir.WithDynamicVars({\n            loc: node.loc,\n            named,\n            block,\n          })\n      );\n    },\n  })\n  .kw('component', {\n    assert: assertCurryKeyword(CurriedTypes.Component),\n\n    translate(\n      { node, state }: { node: ASTv2.InvokeBlock; state: NormalizationState },\n      { definition, args }: { definition: ASTv2.ExpressionNode; args: ASTv2.Args }\n    ): Result<mir.InvokeComponent> {\n      let definitionResult = VISIT_EXPRS.visit(definition, state);\n      let argsResult = VISIT_EXPRS.Args(args, state);\n      let blocksResult = VISIT_STMTS.NamedBlocks(node.blocks, state);\n\n      return Result.all(definitionResult, argsResult, blocksResult).mapOk(\n        ([definition, args, blocks]) =>\n          new mir.InvokeComponent({\n            loc: node.loc,\n            definition,\n            args,\n            blocks,\n          })\n      );\n    },\n  });\n","import { CurriedTypes } from '@glimmer/vm';\n\nimport { keywords } from './impl';\nimport { curryKeyword } from './utils/curry';\nimport { getDynamicVarKeyword } from './utils/dynamic-vars';\nimport { hasBlockKeyword } from './utils/has-block';\nimport { ifUnlessInlineKeyword } from './utils/if-unless';\nimport { logKeyword } from './utils/log';\n\nexport const CALL_KEYWORDS = keywords('Call')\n  .kw('has-block', hasBlockKeyword('has-block'))\n  .kw('has-block-params', hasBlockKeyword('has-block-params'))\n  .kw('-get-dynamic-var', getDynamicVarKeyword)\n  .kw('log', logKeyword)\n  .kw('if', ifUnlessInlineKeyword('if'))\n  .kw('unless', ifUnlessInlineKeyword('unless'))\n  .kw('component', curryKeyword(CurriedTypes.Component))\n  .kw('helper', curryKeyword(CurriedTypes.Helper))\n  .kw('modifier', curryKeyword(CurriedTypes.Modifier));\n","import { keywords } from './impl';\n\nexport const MODIFIER_KEYWORDS = keywords('Modifier');\n","import type { Dict, WellKnownAttrName, WellKnownTagName } from '@glimmer/interfaces';\nimport { WellKnownAttrNames, WellKnownTagNames } from '@glimmer/wire-format';\n\n// There is a small whitelist of namespaced attributes specially\n// enumerated in\n// https://www.w3.org/TR/html/syntax.html#attributes-0\n//\n// > When a foreign element has one of the namespaced attributes given by\n// > the local name and namespace of the first and second cells of a row\n// > from the following table, it must be written using the name given by\n// > the third cell from the same row.\n//\n// In all other cases, colons are interpreted as a regular character\n// with no special meaning:\n//\n// > No other namespaced attribute can be expressed in the HTML syntax.\n\nconst XLINK = 'http://www.w3.org/1999/xlink';\nconst XML = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\nconst WHITELIST: Dict<string | undefined> = {\n  'xlink:actuate': XLINK,\n  'xlink:arcrole': XLINK,\n  'xlink:href': XLINK,\n  'xlink:role': XLINK,\n  'xlink:show': XLINK,\n  'xlink:title': XLINK,\n  'xlink:type': XLINK,\n  'xml:base': XML,\n  'xml:lang': XML,\n  'xml:space': XML,\n  xmlns: XMLNS,\n  'xmlns:xlink': XMLNS,\n};\n\nexport function getAttrNamespace(attrName: string): string | undefined {\n  return WHITELIST[attrName];\n}\n\nconst DEFLATE_TAG_TABLE: {\n  [tagName: string]: WellKnownTagName | undefined;\n} = {\n  div: WellKnownTagNames.div,\n  span: WellKnownTagNames.span,\n  p: WellKnownTagNames.p,\n  a: WellKnownTagNames.a,\n};\n\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function deflateTagName(tagName: string): string | WellKnownTagName {\n  return DEFLATE_TAG_TABLE[tagName] ?? tagName;\n}\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nconst DEFLATE_ATTR_TABLE: {\n  [tagName: string]: WellKnownAttrName | undefined;\n} = {\n  class: WellKnownAttrNames.class,\n  id: WellKnownAttrNames.id,\n  value: WellKnownAttrNames.value,\n  name: WellKnownAttrNames.name,\n  type: WellKnownAttrNames.type,\n  style: WellKnownAttrNames.style,\n  href: WellKnownAttrNames.href,\n};\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\n\nexport function deflateAttrName(attrName: string): string | WellKnownAttrName {\n  return DEFLATE_ATTR_TABLE[attrName] ?? attrName;\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n","import { ASTv2, maybeLoc, src } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../../context';\n\nimport { OptionalList } from '../../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../../shared/result';\nimport { getAttrNamespace } from '../../../../utils';\nimport * as mir from '../../../2-encoding/mir';\nimport { MODIFIER_KEYWORDS } from '../../keywords';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\n\nexport type ValidAttr = mir.StaticAttr | mir.DynamicAttr | mir.SplatAttr;\n\ntype ProcessedAttributes = {\n  attrs: ValidAttr[];\n  args: mir.NamedArguments;\n};\n\nexport interface Classified {\n  readonly dynamicFeatures: boolean;\n\n  arg(attr: ASTv2.AttrNode, classified: ClassifiedElement): Result<mir.NamedArgument>;\n  toStatement(classified: ClassifiedElement, prepared: PreparedArgs): Result<mir.Statement>;\n}\n\nexport class ClassifiedElement {\n  readonly delegate: Classified;\n\n  constructor(\n    readonly element: ASTv2.ElementNode,\n    delegate: Classified,\n    readonly state: NormalizationState\n  ) {\n    this.delegate = delegate;\n  }\n\n  toStatement(): Result<mir.Statement> {\n    return this.prepare().andThen((prepared) => this.delegate.toStatement(this, prepared));\n  }\n\n  private attr(attr: ASTv2.HtmlAttr): Result<ValidAttr> {\n    let name = attr.name;\n    let rawValue = attr.value;\n    let namespace = getAttrNamespace(name.chars) || undefined;\n\n    if (ASTv2.isLiteral(rawValue, 'string')) {\n      return Ok(\n        new mir.StaticAttr({\n          loc: attr.loc,\n          name,\n          value: rawValue.toSlice(),\n          namespace,\n          kind: {\n            component: this.delegate.dynamicFeatures,\n          },\n        })\n      );\n    }\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk((value) => {\n      let isTrusting = attr.trusting;\n\n      return new mir.DynamicAttr({\n        loc: attr.loc,\n        name,\n        value: value,\n        namespace,\n        kind: {\n          trusting: isTrusting,\n          component: this.delegate.dynamicFeatures,\n        },\n      });\n    });\n  }\n\n  private modifier(modifier: ASTv2.ElementModifier): Result<mir.Modifier> {\n    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(modifier.callee, this.state);\n    let args = VISIT_EXPRS.Args(modifier.args, this.state);\n\n    return Result.all(head, args).mapOk(\n      ([head, args]) =>\n        new mir.Modifier({\n          loc: modifier.loc,\n          callee: head,\n          args,\n        })\n    );\n  }\n\n  private attrs(): Result<ProcessedAttributes> {\n    let attrs = new ResultArray<ValidAttr>();\n    let args = new ResultArray<mir.NamedArgument>();\n\n    // Unlike most attributes, the `type` attribute can change how\n    // subsequent attributes are interpreted by the browser. To address\n    // this, in simple cases, we special case the `type` attribute to be set\n    // last. For elements with splattributes, where attribute order affects\n    // precedence, this re-ordering happens at runtime instead.\n    // See https://github.com/glimmerjs/glimmer-vm/pull/726\n    let typeAttr: ASTv2.AttrNode | null = null;\n    let simple = this.element.attrs.filter((attr) => attr.type === 'SplatAttr').length === 0;\n\n    for (let attr of this.element.attrs) {\n      if (attr.type === 'SplatAttr') {\n        attrs.add(\n          Ok(new mir.SplatAttr({ loc: attr.loc, symbol: this.state.scope.allocateBlock('attrs') }))\n        );\n      } else if (attr.name.chars === 'type' && simple) {\n        typeAttr = attr;\n      } else {\n        attrs.add(this.attr(attr));\n      }\n    }\n\n    for (let arg of this.element.componentArgs) {\n      args.add(this.delegate.arg(arg, this));\n    }\n\n    if (typeAttr) {\n      attrs.add(this.attr(typeAttr));\n    }\n\n    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({\n      attrs,\n      args: new mir.NamedArguments({\n        loc: maybeLoc(args, src.SourceSpan.NON_EXISTENT),\n        entries: OptionalList(args),\n      }),\n    }));\n  }\n\n  private prepare(): Result<PreparedArgs> {\n    let attrs = this.attrs();\n    let modifiers = new ResultArray(this.element.modifiers.map((m) => this.modifier(m))).toArray();\n\n    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {\n      let { attrs, args } = result;\n\n      let elementParams = [...attrs, ...modifiers];\n\n      let params = new mir.ElementParameters({\n        loc: maybeLoc(elementParams, src.SourceSpan.NON_EXISTENT),\n        body: OptionalList(elementParams),\n      });\n\n      return { args, params };\n    });\n  }\n}\n\nexport interface PreparedArgs {\n  args: mir.NamedArguments;\n  params: mir.ElementParameters;\n}\n\nexport function hasDynamicFeatures({\n  attrs,\n  modifiers,\n}: Pick<ASTv2.ElementNode, 'attrs' | 'modifiers'>): boolean {\n  // ElementModifier needs the special ComponentOperations\n  if (modifiers.length > 0) {\n    return true;\n  }\n\n  // Splattributes need the special ComponentOperations to merge into\n  return !!attrs.filter((attr) => attr.type === 'SplatAttr')[0];\n}\n","import type { ASTv2 } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { NormalizationState } from '../../context';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport * as mir from '../../../2-encoding/mir';\nimport { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedComponent implements Classified {\n  readonly dynamicFeatures = true;\n\n  constructor(\n    private tag: mir.ExpressionNode,\n    private element: ASTv2.InvokeComponent\n  ) {}\n\n  arg(attr: ASTv2.ComponentArg, { state }: ClassifiedElement): Result<mir.NamedArgument> {\n    let name = attr.name;\n\n    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(attr.value), state).mapOk(\n      (value) =>\n        new mir.NamedArgument({\n          loc: attr.loc,\n          key: name,\n          value,\n        })\n    );\n  }\n\n  toStatement(component: ClassifiedElement, { args, params }: PreparedArgs): Result<mir.Statement> {\n    let { element, state } = component;\n\n    return this.blocks(state).mapOk(\n      (blocks) =>\n        new mir.Component({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          args,\n          blocks,\n        })\n    );\n  }\n\n  private blocks(state: NormalizationState): Result<mir.NamedBlocks> {\n    return VISIT_STMTS.NamedBlocks(this.element.blocks, state);\n  }\n}\n","import type { ASTv2, SourceSlice } from '@glimmer/syntax';\nimport { generateSyntaxError } from '@glimmer/syntax';\n\nimport type { Result } from '../../../../shared/result';\nimport type { Classified, ClassifiedElement, PreparedArgs } from './classified';\n\nimport { Err } from '../../../../shared/result';\nimport * as mir from '../../../2-encoding/mir';\nimport { VISIT_STMTS } from '../statements';\n\nexport class ClassifiedSimpleElement implements Classified {\n  constructor(\n    private tag: SourceSlice,\n    private element: ASTv2.SimpleElement,\n    readonly dynamicFeatures: boolean\n  ) {}\n\n  readonly isComponent = false;\n\n  arg(attr: ASTv2.ComponentArg): Result<mir.NamedArgument> {\n    return Err(\n      generateSyntaxError(\n        `${attr.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\\`${this.tag.chars}\\`) is a regular, non-component HTML element.`,\n        attr.loc\n      )\n    );\n  }\n\n  toStatement(classified: ClassifiedElement, { params }: PreparedArgs): Result<mir.Statement> {\n    let { state, element } = classified;\n\n    let body = VISIT_STMTS.visitList(this.element.body, state);\n\n    return body.mapOk(\n      (body) =>\n        new mir.SimpleElement({\n          loc: element.loc,\n          tag: this.tag,\n          params,\n          body: body.toArray(),\n          dynamicFeatures: this.dynamicFeatures,\n        })\n    );\n  }\n}\n","import { ASTv2 } from '@glimmer/syntax';\n\nimport type { NormalizationState } from '../context';\n\nimport { OptionalList } from '../../../shared/list';\nimport { Ok, Result, ResultArray } from '../../../shared/result';\nimport * as mir from '../../2-encoding/mir';\nimport { BLOCK_KEYWORDS } from '../keywords';\nimport { APPEND_KEYWORDS } from '../keywords/append';\nimport { ClassifiedElement, hasDynamicFeatures } from './element/classified';\nimport { ClassifiedComponent } from './element/component';\nimport { ClassifiedSimpleElement } from './element/simple-element';\nimport { VISIT_EXPRS } from './expressions';\n\nclass NormalizationStatements {\n  visitList(\n    nodes: readonly ASTv2.ContentNode[],\n    state: NormalizationState\n  ): Result<OptionalList<mir.Statement>> {\n    return new ResultArray(nodes.map((e) => VISIT_STMTS.visit(e, state)))\n      .toOptionalList()\n      .mapOk((list) => list.filter((s: mir.Statement | null): s is mir.Statement => s !== null));\n  }\n\n  visit(node: ASTv2.ContentNode, state: NormalizationState): Result<mir.Statement | null> {\n    switch (node.type) {\n      case 'GlimmerComment':\n        return Ok(null);\n      case 'AppendContent':\n        return this.AppendContent(node, state);\n      case 'HtmlText':\n        return Ok(this.TextNode(node));\n      case 'HtmlComment':\n        return Ok(this.HtmlComment(node));\n      case 'InvokeBlock':\n        return this.InvokeBlock(node, state);\n      case 'InvokeComponent':\n        return this.Component(node, state);\n      case 'SimpleElement':\n        return this.SimpleElement(node, state);\n    }\n  }\n\n  InvokeBlock(node: ASTv2.InvokeBlock, state: NormalizationState): Result<mir.Statement> {\n    let translated = BLOCK_KEYWORDS.translate(node, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let head = VISIT_EXPRS.visit(node.callee, state);\n    let args = VISIT_EXPRS.Args(node.args, state);\n\n    return Result.all(head, args).andThen(([head, args]) =>\n      this.NamedBlocks(node.blocks, state).mapOk(\n        (blocks) =>\n          new mir.InvokeBlock({\n            loc: node.loc,\n            head,\n            args,\n            blocks,\n          })\n      )\n    );\n  }\n\n  NamedBlocks(blocks: ASTv2.NamedBlocks, state: NormalizationState): Result<mir.NamedBlocks> {\n    let list = new ResultArray(blocks.blocks.map((b) => this.NamedBlock(b, state)));\n\n    return list\n      .toArray()\n      .mapOk((list) => new mir.NamedBlocks({ loc: blocks.loc, blocks: OptionalList(list) }));\n  }\n\n  NamedBlock(named: ASTv2.NamedBlock, state: NormalizationState): Result<mir.NamedBlock> {\n    let body = state.visitBlock(named.block);\n\n    return body.mapOk((body) => {\n      return new mir.NamedBlock({\n        loc: named.loc,\n        name: named.name,\n        body: body.toArray(),\n        scope: named.block.scope,\n      });\n    });\n  }\n\n  SimpleElement(element: ASTv2.SimpleElement, state: NormalizationState): Result<mir.Statement> {\n    return new ClassifiedElement(\n      element,\n      new ClassifiedSimpleElement(element.tag, element, hasDynamicFeatures(element)),\n      state\n    ).toStatement();\n  }\n\n  Component(component: ASTv2.InvokeComponent, state: NormalizationState): Result<mir.Statement> {\n    return VISIT_EXPRS.visit(component.callee, state).andThen((callee) =>\n      new ClassifiedElement(\n        component,\n        new ClassifiedComponent(callee, component),\n        state\n      ).toStatement()\n    );\n  }\n\n  AppendContent(append: ASTv2.AppendContent, state: NormalizationState): Result<mir.Statement> {\n    let translated = APPEND_KEYWORDS.translate(append, state);\n\n    if (translated !== null) {\n      return translated;\n    }\n\n    let value = VISIT_EXPRS.visit(append.value, state);\n\n    return value.mapOk((value) => {\n      if (append.trusting) {\n        return new mir.AppendTrustedHTML({\n          loc: append.loc,\n          html: value,\n        });\n      } else {\n        return new mir.AppendTextNode({\n          loc: append.loc,\n          text: value,\n        });\n      }\n    });\n  }\n\n  TextNode(text: ASTv2.HtmlText): mir.Statement {\n    return new mir.AppendTextNode({\n      loc: text.loc,\n      text: new ASTv2.LiteralExpression({ loc: text.loc, value: text.chars }),\n    });\n  }\n\n  HtmlComment(comment: ASTv2.HtmlComment): mir.Statement {\n    return new mir.AppendComment({\n      loc: comment.loc,\n      value: comment.text,\n    });\n  }\n}\n\nexport const VISIT_STMTS = new NormalizationStatements();\n","import type { ASTv2, SymbolTable } from '@glimmer/syntax';\n\nimport type { OptionalList } from '../../shared/list';\nimport type { Result } from '../../shared/result';\nimport type * as mir from '../2-encoding/mir';\n\nimport { VISIT_STMTS } from './visitors/statements';\n\n/**\n * This is the mutable state for this compiler pass.\n */\nexport class NormalizationState {\n  _currentScope: SymbolTable;\n  _cursorCount = 0;\n\n  constructor(\n    block: SymbolTable,\n    readonly isStrict: boolean\n  ) {\n    this._currentScope = block;\n  }\n\n  generateUniqueCursor(): string {\n    return `%cursor:${this._cursorCount++}%`;\n  }\n\n  get scope(): SymbolTable {\n    return this._currentScope;\n  }\n\n  visitBlock(block: ASTv2.Block): Result<OptionalList<mir.Statement>> {\n    let oldBlock = this._currentScope;\n    this._currentScope = block.scope;\n\n    try {\n      return VISIT_STMTS.visitList(block.body, this);\n    } finally {\n      this._currentScope = oldBlock;\n    }\n  }\n}\n","import type { HasSourceSpan } from '@glimmer/syntax';\nimport { generateSyntaxError, loc } from '@glimmer/syntax';\nimport { CurriedTypes } from '@glimmer/vm';\n\nimport type { Result } from '../../../shared/result';\nimport type * as mir from '../../2-encoding/mir';\n\nimport { Err, Ok } from '../../../shared/result';\n\nenum ResolutionType {\n  Value = 'value',\n  Component = 'component',\n  Helper = 'helper',\n  Modifier = 'modifier',\n  ComponentOrHelper = 'component or helper',\n}\n\nexport default class StrictModeValidationPass {\n  // This is done at the end of all the keyword normalizations\n  // At this point any free variables that isn't a valid keyword\n  // in its context should be considered a syntax error. We\n  // probably had various opportunities to do this inline in the\n  // earlier passes, but this aims to produce a better syntax\n  // error as we don't always have the right loc-context to do\n  // so in the other spots.\n  static validate(template: mir.Template): Result<mir.Template> {\n    return new this(template).validate();\n  }\n\n  private constructor(private template: mir.Template) {}\n\n  validate(): Result<mir.Template> {\n    return this.Statements(this.template.body).mapOk(() => this.template);\n  }\n\n  Statements(statements: mir.Statement[]): Result<null> {\n    let result = Ok(null);\n\n    for (let statement of statements) {\n      result = result.andThen(() => this.Statement(statement));\n    }\n\n    return result;\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): Result<null> {\n    let result = Ok(null);\n\n    for (let block of blocks.toArray()) {\n      result = result.andThen(() => this.NamedBlock(block));\n    }\n\n    return result;\n  }\n\n  NamedBlock(block: mir.NamedBlock): Result<null> {\n    return this.Statements(block.body);\n  }\n\n  Statement(statement: mir.Statement): Result<null> {\n    switch (statement.type) {\n      case 'InElement':\n        return this.InElement(statement);\n\n      case 'Debugger':\n        return Ok(null);\n\n      case 'Yield':\n        return this.Yield(statement);\n\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(statement);\n\n      case 'AppendTextNode':\n        return this.AppendTextNode(statement);\n\n      case 'Component':\n        return this.Component(statement);\n\n      case 'SimpleElement':\n        return this.SimpleElement(statement);\n\n      case 'InvokeBlock':\n        return this.InvokeBlock(statement);\n\n      case 'AppendComment':\n        return Ok(null);\n\n      case 'If':\n        return this.If(statement);\n\n      case 'Each':\n        return this.Each(statement);\n\n      case 'Let':\n        return this.Let(statement);\n\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(statement);\n\n      case 'InvokeComponent':\n        return this.InvokeComponent(statement);\n    }\n  }\n\n  Expressions(expressions: mir.ExpressionNode[]): Result<null> {\n    let result = Ok(null);\n\n    for (let expression of expressions) {\n      result = result.andThen(() => this.Expression(expression));\n    }\n\n    return result;\n  }\n\n  Expression(\n    expression: mir.ExpressionNode,\n    span: HasSourceSpan = expression,\n    resolution?: ResolutionType\n  ): Result<null> {\n    switch (expression.type) {\n      case 'Literal':\n      case 'Keyword':\n      case 'Missing':\n      case 'This':\n      case 'Arg':\n      case 'Local':\n      case 'HasBlock':\n      case 'HasBlockParams':\n      case 'GetDynamicVar':\n        return Ok(null);\n\n      case 'PathExpression':\n        return this.Expression(expression.head, span, resolution);\n\n      case 'Free':\n        return this.errorFor(expression.name, span, resolution);\n\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expression, span, resolution);\n\n      case 'CallExpression':\n        return this.CallExpression(expression, span, resolution ?? ResolutionType.Helper);\n\n      case 'Not':\n        return this.Expression(expression.value, span, resolution);\n\n      case 'IfInline':\n        return this.IfInline(expression);\n\n      case 'Curry':\n        return this.Curry(expression);\n\n      case 'Log':\n        return this.Log(expression);\n    }\n  }\n\n  Args(args: mir.Args): Result<null> {\n    return this.Positional(args.positional).andThen(() => this.NamedArguments(args.named));\n  }\n\n  Positional(positional: mir.Positional, span?: HasSourceSpan): Result<null> {\n    let result = Ok(null);\n    let expressions = positional.list.toArray();\n\n    // For cases like {{yield foo}}, when there is only a single argument, it\n    // makes for a slightly better error to report that entire span. However,\n    // when there are more than one, we need to be specific.\n    if (expressions.length === 1) {\n      result = this.Expression(expressions[0]!, span);\n    } else {\n      result = this.Expressions(expressions);\n    }\n\n    return result;\n  }\n\n  NamedArguments({ entries }: mir.NamedArguments): Result<null> {\n    let result = Ok(null);\n\n    for (let arg of entries.toArray()) {\n      result = result.andThen(() => this.NamedArgument(arg));\n    }\n\n    return result;\n  }\n\n  NamedArgument(arg: mir.NamedArgument): Result<null> {\n    if (arg.value.type === 'CallExpression') {\n      return this.Expression(arg.value, arg, ResolutionType.Helper);\n    } else {\n      return this.Expression(arg.value, arg);\n    }\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): Result<null> {\n    let result = Ok(null);\n\n    for (let param of body.toArray()) {\n      result = result.andThen(() => this.ElementParameter(param));\n    }\n\n    return result;\n  }\n\n  ElementParameter(param: mir.ElementParameter): Result<null> {\n    switch (param.type) {\n      case 'StaticAttr':\n        return Ok(null);\n      case 'DynamicAttr':\n        return this.DynamicAttr(param);\n      case 'Modifier':\n        return this.Modifier(param);\n      case 'SplatAttr':\n        return Ok(null);\n    }\n  }\n\n  DynamicAttr(attr: mir.DynamicAttr): Result<null> {\n    if (attr.value.type === 'CallExpression') {\n      return this.Expression(attr.value, attr, ResolutionType.Helper);\n    } else {\n      return this.Expression(attr.value, attr);\n    }\n  }\n\n  Modifier(modifier: mir.Modifier): Result<null> {\n    return this.Expression(modifier.callee, modifier, ResolutionType.Modifier).andThen(() =>\n      this.Args(modifier.args)\n    );\n  }\n\n  InElement(inElement: mir.InElement): Result<null> {\n    return (\n      this.Expression(inElement.destination)\n        // Unfortunately we lost the `insertBefore=` part of the span\n        .andThen(() => this.Expression(inElement.insertBefore))\n        .andThen(() => this.NamedBlock(inElement.block))\n    );\n  }\n\n  Yield(statement: mir.Yield): Result<null> {\n    return this.Positional(statement.positional, statement);\n  }\n\n  AppendTrustedHTML(statement: mir.AppendTrustedHTML): Result<null> {\n    return this.Expression(statement.html, statement);\n  }\n\n  AppendTextNode(statement: mir.AppendTextNode): Result<null> {\n    if (statement.text.type === 'CallExpression') {\n      return this.Expression(statement.text, statement, ResolutionType.ComponentOrHelper);\n    } else {\n      return this.Expression(statement.text, statement);\n    }\n  }\n\n  Component(statement: mir.Component): Result<null> {\n    return this.Expression(statement.tag, statement, ResolutionType.Component)\n      .andThen(() => this.ElementParameters(statement.params))\n      .andThen(() => this.NamedArguments(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  SimpleElement(statement: mir.SimpleElement): Result<null> {\n    return this.ElementParameters(statement.params).andThen(() => this.Statements(statement.body));\n  }\n\n  InvokeBlock(statement: mir.InvokeBlock): Result<null> {\n    return this.Expression(statement.head, statement.head, ResolutionType.Component)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => this.NamedBlocks(statement.blocks));\n  }\n\n  If(statement: mir.If): Result<null> {\n    return this.Expression(statement.condition, statement)\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Each(statement: mir.Each): Result<null> {\n    return this.Expression(statement.value, statement)\n      .andThen(() => {\n        if (statement.key) {\n          return this.Expression(statement.key, statement);\n        } else {\n          return Ok(null);\n        }\n      })\n      .andThen(() => this.NamedBlock(statement.block))\n      .andThen(() => {\n        if (statement.inverse) {\n          return this.NamedBlock(statement.inverse);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Let(statement: mir.Let): Result<null> {\n    return this.Positional(statement.positional).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  WithDynamicVars(statement: mir.WithDynamicVars): Result<null> {\n    return this.NamedArguments(statement.named).andThen(() => this.NamedBlock(statement.block));\n  }\n\n  InvokeComponent(statement: mir.InvokeComponent): Result<null> {\n    return this.Expression(statement.definition, statement, ResolutionType.Component)\n      .andThen(() => this.Args(statement.args))\n      .andThen(() => {\n        if (statement.blocks) {\n          return this.NamedBlocks(statement.blocks);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  InterpolateExpression(\n    expression: mir.InterpolateExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    let expressions = expression.parts.toArray();\n\n    if (expressions.length === 1) {\n      return this.Expression(expressions[0], span, resolution);\n    } else {\n      return this.Expressions(expressions);\n    }\n  }\n\n  CallExpression(\n    expression: mir.CallExpression,\n    span: HasSourceSpan,\n    resolution?: ResolutionType\n  ): Result<null> {\n    return this.Expression(expression.callee, span, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  IfInline(expression: mir.IfInline): Result<null> {\n    return this.Expression(expression.condition)\n      .andThen(() => this.Expression(expression.truthy))\n      .andThen(() => {\n        if (expression.falsy) {\n          return this.Expression(expression.falsy);\n        } else {\n          return Ok(null);\n        }\n      });\n  }\n\n  Curry(expression: mir.Curry): Result<null> {\n    let resolution: ResolutionType;\n\n    if (expression.curriedType === CurriedTypes.Component) {\n      resolution = ResolutionType.Component;\n    } else if (expression.curriedType === CurriedTypes.Helper) {\n      resolution = ResolutionType.Helper;\n    } else {\n      resolution = ResolutionType.Modifier;\n    }\n\n    return this.Expression(expression.definition, expression, resolution).andThen(() =>\n      this.Args(expression.args)\n    );\n  }\n\n  Log(expression: mir.Log): Result<null> {\n    return this.Positional(expression.positional, expression);\n  }\n\n  errorFor(name: string, span: HasSourceSpan, type = ResolutionType.Value): Result<never> {\n    return Err(\n      generateSyntaxError(\n        `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${name}`,\n        loc(span)\n      )\n    );\n  }\n}\n","import type {\n  CurriedType,\n  Nullable,\n  SerializedInlineBlock,\n  SerializedTemplateBlock,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { dict, exhausted } from '@glimmer/util';\nimport { CurriedTypes } from '@glimmer/vm';\nimport { SexpOpcodes as Op } from '@glimmer/wire-format';\n\nimport { inflateAttrName, inflateTagName } from './utils';\n\nexport default class WireFormatDebugger {\n  private upvars: string[];\n  private symbols: string[];\n\n  constructor([_statements, symbols, _hasEval, upvars]: SerializedTemplateBlock) {\n    this.upvars = upvars;\n    this.symbols = symbols;\n  }\n\n  format(program: SerializedTemplateBlock): unknown {\n    let out = [];\n\n    for (let statement of program[0]) {\n      out.push(this.formatOpcode(statement));\n    }\n\n    return out;\n  }\n\n  formatOpcode(opcode: WireFormat.Syntax): unknown {\n    if (Array.isArray(opcode)) {\n      switch (opcode[0]) {\n        case Op.Append:\n          return ['append', this.formatOpcode(opcode[1])];\n        case Op.TrustingAppend:\n          return ['trusting-append', this.formatOpcode(opcode[1])];\n\n        case Op.Block:\n          return [\n            'block',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.InElement:\n          return [\n            'in-element',\n            opcode[1],\n            this.formatOpcode(opcode[2]),\n            opcode[3] ? this.formatOpcode(opcode[3]) : undefined,\n          ];\n\n        case Op.OpenElement:\n          return ['open-element', inflateTagName(opcode[1])];\n\n        case Op.OpenElementWithSplat:\n          return ['open-element-with-splat', inflateTagName(opcode[1])];\n\n        case Op.CloseElement:\n          return ['close-element'];\n\n        case Op.FlushElement:\n          return ['flush-element'];\n\n        case Op.StaticAttr:\n          return ['static-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.StaticComponentAttr:\n          return ['static-component-attr', inflateAttrName(opcode[1]), opcode[2], opcode[3]];\n\n        case Op.DynamicAttr:\n          return [\n            'dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.ComponentAttr:\n          return [\n            'component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.AttrSplat:\n          return ['attr-splat'];\n\n        case Op.Yield:\n          return ['yield', opcode[1], this.formatParams(opcode[2])];\n\n        case Op.DynamicArg:\n          return ['dynamic-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.StaticArg:\n          return ['static-arg', opcode[1], this.formatOpcode(opcode[2])];\n\n        case Op.TrustingDynamicAttr:\n          return [\n            'trusting-dynamic-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.TrustingComponentAttr:\n          return [\n            'trusting-component-attr',\n            inflateAttrName(opcode[1]),\n            this.formatOpcode(opcode[2]),\n            opcode[3],\n          ];\n\n        case Op.Debugger:\n          return ['debugger', opcode[1]];\n\n        case Op.Comment:\n          return ['comment', opcode[1]];\n\n        case Op.Modifier:\n          return [\n            'modifier',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Component:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatElementParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n\n        case Op.HasBlock:\n          return ['has-block', this.formatOpcode(opcode[1])];\n\n        case Op.HasBlockParams:\n          return ['has-block-params', this.formatOpcode(opcode[1])];\n\n        case Op.Curry:\n          return [\n            'curry',\n            this.formatOpcode(opcode[1]),\n            this.formatCurryType(opcode[2]),\n            this.formatParams(opcode[3]),\n            this.formatHash(opcode[4]),\n          ];\n\n        case Op.Undefined:\n          return ['undefined'];\n\n        case Op.Call:\n          return [\n            'call',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n          ];\n\n        case Op.Concat:\n          return ['concat', this.formatParams(opcode[1] as WireFormat.Core.Params)];\n\n        case Op.GetStrictKeyword:\n          return ['get-strict-free', this.upvars[opcode[1]]];\n\n        case Op.GetFreeAsComponentOrHelperHead:\n          return ['GetFreeAsComponentOrHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsHelperHead:\n          return ['GetFreeAsHelperHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsComponentHead:\n          return ['GetFreeAsComponentHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetFreeAsModifierHead:\n          return ['GetFreeAsModifierHead', this.upvars[opcode[1]], opcode[2]];\n\n        case Op.GetSymbol: {\n          if (opcode[1] === 0) {\n            return ['get-symbol', 'this', opcode[2]];\n          } else {\n            return ['get-symbol', this.symbols[opcode[1] - 1], opcode[2]];\n          }\n        }\n\n        case Op.GetLexicalSymbol: {\n          return ['get-template-symbol', opcode[1], opcode[2]];\n        }\n\n        case Op.If:\n          return [\n            'if',\n            this.formatOpcode(opcode[1]),\n            this.formatBlock(opcode[2]),\n            opcode[3] ? this.formatBlock(opcode[3]) : null,\n          ];\n\n        case Op.IfInline:\n          return ['if-inline'];\n\n        case Op.Not:\n          return ['not'];\n\n        case Op.Each:\n          return [\n            'each',\n            this.formatOpcode(opcode[1]),\n            opcode[2] ? this.formatOpcode(opcode[2]) : null,\n            this.formatBlock(opcode[3]),\n            opcode[4] ? this.formatBlock(opcode[4]) : null,\n          ];\n\n        case Op.Let:\n          return ['let', this.formatParams(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.Log:\n          return ['log', this.formatParams(opcode[1])];\n\n        case Op.WithDynamicVars:\n          return ['-with-dynamic-vars', this.formatHash(opcode[1]), this.formatBlock(opcode[2])];\n\n        case Op.GetDynamicVar:\n          return ['-get-dynamic-vars', this.formatOpcode(opcode[1])];\n\n        case Op.InvokeComponent:\n          return [\n            'component',\n            this.formatOpcode(opcode[1]),\n            this.formatParams(opcode[2]),\n            this.formatHash(opcode[3]),\n            this.formatBlocks(opcode[4]),\n          ];\n      }\n    } else {\n      return opcode;\n    }\n  }\n\n  private formatCurryType(value: CurriedType) {\n    switch (value) {\n      case CurriedTypes.Component:\n        return 'component';\n      case CurriedTypes.Helper:\n        return 'helper';\n      case CurriedTypes.Modifier:\n        return 'modifier';\n      default:\n        throw exhausted(value);\n    }\n  }\n\n  private formatElementParams(\n    opcodes: Nullable<WireFormat.ElementParameter[]>\n  ): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatParams(opcodes: Nullable<WireFormat.Expression[]>): Nullable<unknown[]> {\n    if (opcodes === null) return null;\n    return opcodes.map((o) => this.formatOpcode(o));\n  }\n\n  private formatHash(hash: WireFormat.Core.Hash): Nullable<object> {\n    if (hash === null) return null;\n\n    return hash[0].reduce((accum, key, index) => {\n      accum[key] = this.formatOpcode(hash[1][index]);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlocks(blocks: WireFormat.Core.Blocks): Nullable<object> {\n    if (blocks === null) return null;\n\n    return blocks[0].reduce((accum, key, index) => {\n      accum[key] = this.formatBlock(blocks[1][index] as SerializedInlineBlock);\n      return accum;\n    }, dict());\n  }\n\n  private formatBlock(block: SerializedInlineBlock): object {\n    return {\n      statements: block[0].map((s) => this.formatOpcode(s)),\n      parameters: block[1],\n    };\n  }\n}\n","import type { PresentArray, WireFormat } from '@glimmer/interfaces';\nimport type { ASTv2 } from '@glimmer/syntax';\nimport { assert, assertPresentArray, isPresentArray, mapPresentArray } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type * as mir from './mir';\n\nexport type HashPair = [string, WireFormat.Expression];\n\nexport class ExpressionEncoder {\n  expr(expr: mir.ExpressionNode): WireFormat.Expression {\n    switch (expr.type) {\n      case 'Missing':\n        return undefined;\n      case 'Literal':\n        return this.Literal(expr);\n      case 'Keyword':\n        return this.Keyword(expr);\n      case 'CallExpression':\n        return this.CallExpression(expr);\n      case 'PathExpression':\n        return this.PathExpression(expr);\n      case 'Arg':\n        return [SexpOpcodes.GetSymbol, expr.symbol];\n      case 'Local':\n        return this.Local(expr);\n      case 'This':\n        return [SexpOpcodes.GetSymbol, 0];\n      case 'Free':\n        return [expr.resolution.resolution(), expr.symbol];\n      case 'HasBlock':\n        return this.HasBlock(expr);\n      case 'HasBlockParams':\n        return this.HasBlockParams(expr);\n      case 'Curry':\n        return this.Curry(expr);\n      case 'Not':\n        return this.Not(expr);\n      case 'IfInline':\n        return this.IfInline(expr);\n      case 'InterpolateExpression':\n        return this.InterpolateExpression(expr);\n      case 'GetDynamicVar':\n        return this.GetDynamicVar(expr);\n      case 'Log':\n        return this.Log(expr);\n    }\n  }\n\n  Literal({\n    value,\n  }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined {\n    if (value === undefined) {\n      return [SexpOpcodes.Undefined];\n    } else {\n      return value;\n    }\n  }\n\n  Missing(): undefined {\n    return undefined;\n  }\n\n  HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock {\n    return [SexpOpcodes.HasBlock, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams {\n    return [SexpOpcodes.HasBlockParams, [SexpOpcodes.GetSymbol, symbol]];\n  }\n\n  Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry {\n    return [\n      SexpOpcodes.Curry,\n      EXPR.expr(definition),\n      curriedType,\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n    ];\n  }\n\n  Local({\n    isTemplateLocal,\n    symbol,\n  }: ASTv2.LocalVarReference):\n    | WireFormat.Expressions.GetSymbol\n    | WireFormat.Expressions.GetLexicalSymbol {\n    return [isTemplateLocal ? SexpOpcodes.GetLexicalSymbol : SexpOpcodes.GetSymbol, symbol];\n  }\n\n  Keyword({ symbol }: ASTv2.KeywordExpression): WireFormat.Expressions.GetStrictFree {\n    return [SexpOpcodes.GetStrictKeyword, symbol];\n  }\n\n  PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath {\n    let getOp = EXPR.expr(head) as WireFormat.Expressions.GetVar;\n    assert(getOp[0] !== SexpOpcodes.GetStrictKeyword, '[BUG] keyword in a PathExpression');\n    return [...getOp, EXPR.Tail(tail)];\n  }\n\n  InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat {\n    return [SexpOpcodes.Concat, parts.map((e) => EXPR.expr(e)).toArray()];\n  }\n\n  CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper {\n    return [SexpOpcodes.Call, EXPR.expr(callee), ...EXPR.Args(args)];\n  }\n\n  Tail({ members }: mir.Tail): PresentArray<string> {\n    return mapPresentArray(members, (member) => member.chars);\n  }\n\n  Args({ positional, named }: mir.Args): WireFormat.Core.Args {\n    return [this.Positional(positional), this.NamedArguments(named)];\n  }\n\n  Positional({ list }: mir.Positional): WireFormat.Core.Params {\n    return list.map((l) => EXPR.expr(l)).toPresentArray();\n  }\n\n  NamedArgument({ key, value }: mir.NamedArgument): HashPair {\n    return [key.chars, EXPR.expr(value)];\n  }\n\n  NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash {\n    let list = pairs.toArray();\n\n    if (isPresentArray(list)) {\n      let names: string[] = [];\n      let values: WireFormat.Expression[] = [];\n\n      for (let pair of list) {\n        let [name, value] = EXPR.NamedArgument(pair);\n        names.push(name);\n        values.push(value);\n      }\n\n      assertPresentArray(names);\n      assertPresentArray(values);\n\n      return [names, values];\n    } else {\n      return null;\n    }\n  }\n\n  Not({ value }: mir.Not): WireFormat.Expressions.Not {\n    return [SexpOpcodes.Not, EXPR.expr(value)];\n  }\n\n  IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline {\n    let expr = [SexpOpcodes.IfInline, EXPR.expr(condition), EXPR.expr(truthy)];\n\n    if (falsy) {\n      expr.push(EXPR.expr(falsy));\n    }\n\n    return expr as WireFormat.Expressions.IfInline;\n  }\n\n  GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar {\n    return [SexpOpcodes.GetDynamicVar, EXPR.expr(name)];\n  }\n\n  Log({ positional }: mir.Log): WireFormat.Expressions.Log {\n    return [SexpOpcodes.Log, this.Positional(positional)];\n  }\n}\n\nexport const EXPR = new ExpressionEncoder();\n","import type {\n  AttrOpcode,\n  ComponentAttrOpcode,\n  DynamicAttrOpcode,\n  StaticAttrOpcode,\n  StaticComponentAttrOpcode,\n  TrustingComponentAttrOpcode,\n  TrustingDynamicAttrOpcode,\n  WellKnownAttrName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { exhausted, LOCAL_LOGGER } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { OptionalList } from '../../shared/list';\nimport type * as mir from './mir';\n\nimport { deflateAttrName, deflateTagName } from '../../utils';\nimport { EXPR } from './expressions';\n\nclass WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {\n  constructor(private statements: readonly S[]) {}\n\n  toArray(): readonly S[] {\n    return this.statements;\n  }\n}\n\nexport class ContentEncoder {\n  list(statements: mir.Statement[]): WireFormat.Statement[] {\n    let out: WireFormat.Statement[] = [];\n\n    for (let statement of statements) {\n      let result = CONTENT.content(statement);\n\n      if (result && result instanceof WireStatements) {\n        out.push(...result.toArray());\n      } else {\n        out.push(result);\n      }\n    }\n\n    return out;\n  }\n\n  content(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    if (LOCAL_SHOULD_LOG) {\n      LOCAL_LOGGER.log(`encoding`, stmt);\n    }\n\n    return this.visitContent(stmt);\n  }\n\n  private visitContent(stmt: mir.Statement): WireFormat.Statement | WireStatements {\n    switch (stmt.type) {\n      case 'Debugger':\n        return [SexpOpcodes.Debugger, stmt.scope.getDebugInfo()];\n      case 'AppendComment':\n        return this.AppendComment(stmt);\n      case 'AppendTextNode':\n        return this.AppendTextNode(stmt);\n      case 'AppendTrustedHTML':\n        return this.AppendTrustedHTML(stmt);\n      case 'Yield':\n        return this.Yield(stmt);\n      case 'Component':\n        return this.Component(stmt);\n      case 'SimpleElement':\n        return this.SimpleElement(stmt);\n      case 'InElement':\n        return this.InElement(stmt);\n      case 'InvokeBlock':\n        return this.InvokeBlock(stmt);\n      case 'If':\n        return this.If(stmt);\n      case 'Each':\n        return this.Each(stmt);\n      case 'Let':\n        return this.Let(stmt);\n      case 'WithDynamicVars':\n        return this.WithDynamicVars(stmt);\n      case 'InvokeComponent':\n        return this.InvokeComponent(stmt);\n      default:\n        return exhausted(stmt);\n    }\n  }\n\n  Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield {\n    return [SexpOpcodes.Yield, to, EXPR.Positional(positional)];\n  }\n\n  InElement({\n    guid,\n    insertBefore,\n    destination,\n    block,\n  }: mir.InElement): WireFormat.Statements.InElement {\n    let wireBlock = CONTENT.NamedBlock(block)[1];\n    // let guid = args.guid;\n    let wireDestination = EXPR.expr(destination);\n    let wireInsertBefore = EXPR.expr(insertBefore);\n\n    if (wireInsertBefore === undefined) {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination];\n    } else {\n      return [SexpOpcodes.InElement, wireBlock, guid, wireDestination, wireInsertBefore];\n    }\n  }\n\n  InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block {\n    return [SexpOpcodes.Block, EXPR.expr(head), ...EXPR.Args(args), CONTENT.NamedBlocks(blocks)];\n  }\n\n  AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend {\n    return [SexpOpcodes.TrustingAppend, EXPR.expr(html)];\n  }\n\n  AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append {\n    return [SexpOpcodes.Append, EXPR.expr(text)];\n  }\n\n  AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment {\n    return [SexpOpcodes.Comment, value.chars];\n  }\n\n  SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements {\n    let op = dynamicFeatures ? SexpOpcodes.OpenElementWithSplat : SexpOpcodes.OpenElement;\n    return new WireStatements<WireFormat.Statement | WireFormat.ElementParameter>([\n      [op, deflateTagName(tag.chars)],\n      ...CONTENT.ElementParameters(params).toArray(),\n      [SexpOpcodes.FlushElement],\n      ...CONTENT.list(body),\n      [SexpOpcodes.CloseElement],\n    ]);\n  }\n\n  Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component {\n    let wireTag = EXPR.expr(tag);\n    let wirePositional = CONTENT.ElementParameters(params);\n    let wireNamed = EXPR.NamedArguments(args);\n\n    let wireNamedBlocks = CONTENT.NamedBlocks(blocks);\n\n    return [\n      SexpOpcodes.Component,\n      wireTag,\n      wirePositional.toPresentArray(),\n      wireNamed,\n      wireNamedBlocks,\n    ];\n  }\n\n  ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter> {\n    return body.map((p) => CONTENT.ElementParameter(p));\n  }\n\n  ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter {\n    switch (param.type) {\n      case 'SplatAttr':\n        return [SexpOpcodes.AttrSplat, param.symbol];\n      case 'DynamicAttr':\n        return [dynamicAttrOp(param.kind), ...dynamicAttr(param)];\n      case 'StaticAttr':\n        return [staticAttrOp(param.kind), ...staticAttr(param)];\n      case 'Modifier':\n        return [SexpOpcodes.Modifier, EXPR.expr(param.callee), ...EXPR.Args(param.args)];\n    }\n  }\n\n  NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks {\n    let names: string[] = [];\n    let serializedBlocks: WireFormat.SerializedInlineBlock[] = [];\n\n    for (let block of blocks.toArray()) {\n      let [name, serializedBlock] = CONTENT.NamedBlock(block);\n\n      names.push(name);\n      serializedBlocks.push(serializedBlock);\n    }\n\n    return names.length > 0 ? [names, serializedBlocks] : null;\n  }\n\n  NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock {\n    let nameChars = name.chars;\n    if (nameChars === 'inverse') {\n      nameChars = 'else';\n    }\n    return [nameChars, [CONTENT.list(body), scope.slots]];\n  }\n\n  If({ condition, block, inverse }: mir.If): WireFormat.Statements.If {\n    return [\n      SexpOpcodes.If,\n      EXPR.expr(condition),\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each {\n    return [\n      SexpOpcodes.Each,\n      EXPR.expr(value),\n      key ? EXPR.expr(key) : null,\n      CONTENT.NamedBlock(block)[1],\n      inverse ? CONTENT.NamedBlock(inverse)[1] : null,\n    ];\n  }\n\n  Let({ positional, block }: mir.Let): WireFormat.Statements.Let {\n    return [SexpOpcodes.Let, EXPR.Positional(positional), CONTENT.NamedBlock(block)[1]];\n  }\n\n  WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars {\n    return [SexpOpcodes.WithDynamicVars, EXPR.NamedArguments(named), CONTENT.NamedBlock(block)[1]];\n  }\n\n  InvokeComponent({\n    definition,\n    args,\n    blocks,\n  }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent {\n    return [\n      SexpOpcodes.InvokeComponent,\n      EXPR.expr(definition),\n      EXPR.Positional(args.positional),\n      EXPR.NamedArguments(args.named),\n      blocks ? CONTENT.NamedBlocks(blocks) : null,\n    ];\n  }\n}\n\nexport const CONTENT = new ContentEncoder();\n\nexport type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];\n\nfunction staticAttr({ name, value, namespace }: mir.StaticAttr): StaticAttrArgs {\n  let out: StaticAttrArgs = [deflateAttrName(name.chars), value.chars];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nexport type DynamicAttrArgs = [\n  name: string | WellKnownAttrName,\n  value: WireFormat.Expression,\n  namespace?: string,\n];\n\nfunction dynamicAttr({ name, value, namespace }: mir.DynamicAttr): DynamicAttrArgs {\n  let out: DynamicAttrArgs = [deflateAttrName(name.chars), EXPR.expr(value)];\n\n  if (namespace) {\n    out.push(namespace);\n  }\n\n  return out;\n}\n\nfunction staticAttrOp(kind: { component: boolean }): StaticAttrOpcode | StaticComponentAttrOpcode;\nfunction staticAttrOp(kind: { component: boolean }): AttrOpcode {\n  if (kind.component) {\n    return SexpOpcodes.StaticComponentAttr;\n  } else {\n    return SexpOpcodes.StaticAttr;\n  }\n}\n\nfunction dynamicAttrOp(\n  kind: mir.AttrKind\n):\n  | TrustingComponentAttrOpcode\n  | TrustingDynamicAttrOpcode\n  | ComponentAttrOpcode\n  | DynamicAttrOpcode {\n  if (kind.component) {\n    return kind.trusting ? SexpOpcodes.TrustingComponentAttr : SexpOpcodes.ComponentAttr;\n  } else {\n    return kind.trusting ? SexpOpcodes.TrustingDynamicAttr : SexpOpcodes.DynamicAttr;\n  }\n}\n","import type {\n  Nullable,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  TemplateJavascript,\n} from '@glimmer/interfaces';\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n  TemplateIdFn,\n} from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { normalize, src } from '@glimmer/syntax';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport pass0 from './passes/1-normalization/index';\nimport { visit as pass2 } from './passes/2-encoding/index';\n\ndeclare function require(id: 'crypto'): Crypto;\ndeclare function require(id: string): unknown;\n\ninterface Crypto {\n  createHash(alg: 'sha1'): {\n    update(src: string, encoding: 'utf8'): void;\n    digest(encoding: 'base64'): string;\n  };\n}\n\nexport const defaultId: TemplateIdFn = (() => {\n  const req: typeof require | undefined =\n    typeof module === 'object' && typeof module.require === 'function'\n      ? module.require\n      : globalThis.require;\n\n  if (req) {\n    try {\n      const crypto = req('crypto');\n\n      const idFn: TemplateIdFn = (src) => {\n        const hash = crypto.createHash('sha1');\n        hash.update(src, 'utf8');\n        // trim to 6 bytes of data (2^48 - 1)\n        return hash.digest('base64').substring(0, 8);\n      };\n\n      idFn('test');\n\n      return idFn;\n    } catch {\n      // do nothing\n    }\n  }\n\n  return function idFn() {\n    return null;\n  };\n})();\n\nconst defaultOptions: PrecompileOptions = {\n  id: defaultId,\n};\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompileJSON(\n  string: Nullable<string>,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): [block: SerializedTemplateBlock, usedLocals: string[]] {\n  const source = new src.Source(string ?? '', options.meta?.moduleName);\n  const [ast, locals] = normalize(source, { lexicalScope: () => false, ...options });\n  const block = pass0(source, ast, options.strictMode ?? false).mapOk((pass2In) => {\n    return pass2(pass2In);\n  });\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.log(`Template ->`, block);\n  }\n\n  if (block.isOk) {\n    return [block.value, locals];\n  } else {\n    throw block.reason;\n  }\n}\n\n// UUID used as a unique placeholder for placing a snippet of JS code into\n// the otherwise JSON stringified value below.\nconst SCOPE_PLACEHOLDER = '796d24e6-2450-4fb0-8cdf-b65638b5ef70';\n\n/*\n * Compile a string into a template javascript string.\n *\n * Example usage:\n *     import { precompile } from '@glimmer/compiler';\n *     import { templateFactory } from 'glimmer-runtime';\n *     let templateJs = precompile(\"Howdy {{name}}\");\n *     let factory = templateFactory(new Function(\"return \" + templateJs)());\n *     let template = factory.create(env);\n *\n * @method precompile\n * @param {string} string a Glimmer template string\n * @return {string} a template javascript string\n */\nexport function precompile(\n  source: string,\n  options: PrecompileOptions | PrecompileOptionsWithLexicalScope = defaultOptions\n): TemplateJavascript {\n  const [block, usedLocals] = precompileJSON(source, options);\n\n  const moduleName = options.meta?.moduleName;\n  const idFn = options.id || defaultId;\n  const blockJSON = JSON.stringify(block);\n  const templateJSONObject: SerializedTemplateWithLazyBlock = {\n    id: idFn(JSON.stringify(options.meta) + blockJSON),\n    block: blockJSON,\n    moduleName: moduleName ?? '(unknown template module)',\n    // lying to the type checker here because we're going to\n    // replace it just below, after stringification\n    scope: SCOPE_PLACEHOLDER as unknown as null,\n    isStrictMode: options.strictMode ?? false,\n  };\n\n  if (usedLocals.length === 0) {\n    delete templateJSONObject.scope;\n  }\n\n  // JSON is javascript\n  let stringified = JSON.stringify(templateJSONObject);\n\n  if (usedLocals.length > 0) {\n    const scopeFn = `()=>[${usedLocals.join(',')}]`;\n\n    stringified = stringified.replace(`\"${SCOPE_PLACEHOLDER}\"`, scopeFn);\n  }\n\n  return stringified;\n}\n\nexport type { PrecompileOptions };\n","import type { ASTv2, src } from '@glimmer/syntax';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type { Result } from '../../shared/result';\n\nimport * as mir from '../2-encoding/mir';\nimport { NormalizationState } from './context';\nimport { VISIT_STMTS } from './visitors/statements';\nimport StrictModeValidationPass from './visitors/strict-mode';\n\n/**\n * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special\n * instructions for keywords like `{{yield}}`, `(has-block)` and\n * `{{#in-element}}`.\n *\n * Most importantly, it also classifies HTML element syntax into:\n *\n * 1. simple HTML element (with optional splattributes)\n * 2. component invocation\n *\n * Because the @glimmer/syntax AST gives us a string for an element's tag,\n * this pass also normalizes that string into an expression.\n *\n * ```\n * // normalized into a path expression whose head is `this` and tail is\n * // `[\"x\"]`\n * <this.x />\n *\n * {{#let expr as |t|}}\n *   // `\"t\"` is normalized into a variable lookup.\n *   <t />\n *\n *   // normalized into a path expression whose head is the variable lookup\n *   // `t` and tail is `[\"input\"]`.\n *   <t.input />\n * {{/let}}\n *\n * // normalized into a free variable lookup for `SomeComponent` (with the\n * // context `ComponentHead`).\n * <SomeComponent />\n *\n * // normalized into a path expression whose head is the free variable\n * // `notInScope` (with the context `Expression`), and whose tail is\n * // `[\"SomeComponent\"]`. In resolver mode, this path will be rejected later,\n * // since it cannot serve as an input to the resolver.\n * <notInScope.SomeComponent />\n * ```\n */\nexport default function normalize(\n  source: src.Source,\n  root: ASTv2.Template,\n  isStrict: boolean\n): Result<mir.Template> {\n  // create a new context for the normalization pass\n  let state = new NormalizationState(root.table, isStrict);\n\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);\n    LOCAL_LOGGER.log('symbols', root.table);\n    LOCAL_LOGGER.log('source', source);\n    LOCAL_LOGGER.groupEnd();\n  }\n\n  let body = VISIT_STMTS.visitList(root.body, state);\n\n  if (LOCAL_SHOULD_LOG) {\n    if (body.isOk) {\n      LOCAL_LOGGER.log('-> pass0: out', body.value);\n    } else {\n      LOCAL_LOGGER.log('-> pass0: error', body.reason);\n    }\n  }\n\n  let template = body.mapOk(\n    (body) => new mir.Template({ loc: root.loc, scope: root.table, body: body.toArray() })\n  );\n\n  if (isStrict) {\n    template = template.andThen((template) => StrictModeValidationPass.validate(template));\n  }\n\n  return template;\n}\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { LOCAL_LOGGER } from '@glimmer/util';\n\nimport type * as mir from './mir';\n\nimport WireFormatDebugger from '../../wire-format-debug';\nimport { CONTENT } from './content';\n\nexport function visit(template: mir.Template): WireFormat.SerializedTemplateBlock {\n  let statements = CONTENT.list(template.body);\n  let scope = template.scope;\n  let block: WireFormat.SerializedTemplateBlock = [\n    statements,\n    scope.symbols,\n    scope.hasEval,\n    scope.upvars,\n  ];\n\n  if (LOCAL_SHOULD_LOG) {\n    let debug = new WireFormatDebugger(block);\n    LOCAL_LOGGER.log(\n      `-> `,\n      statements.map((s) => debug.formatOpcode(s))\n    );\n  }\n\n  return block;\n}\n"],"names":["HeadKind","VariableKind","normalizeStatement","statement","Array","isArray","name","Builder","Literal","Get","Concat","HasBlock","HasBlockParams","statementIsExpression","normalizeAppendExpression","isSugaryArrayStatement","params","hash","length","normalizeParams","normalizeHash","kind","Call","head","normalizeCallHead","trusted","path","blocks","blockParams","normalizeBuilderBlockStatement","Block","slice","Keyword","attrs","dict","block","normalizeAttrs","normalizeBlock","Element","expect","extractElement","Error","JSON","stringify","normalizeSugaryArrayStatement","value","Append","Modifier","DynamicComponent","expr","normalizeExpression","Comment","normalizeVerboseStatement","normalizeAppendHead","normalizeDottedPath","assertNever","type","ExpressionKind","GetPath","AppendPath","AppendExpr","extractBlockHead","result","exec","normalizePath","tail","pathHead","normalizePathHead","isPresentArray","GetVar","variable","whole","rest","split","mode","test","This","Free","Arg","Local","normalizeBlocks","normalizeBlockHash","out","callback","Object","keys","forEach","key","entries","default","mapObject","map","s","a","attr","Splat","normalizeAttr","object","mapper","k","input","match","expression","forceTrusted","isBuilderCallExpression","normalizeCallExpression","ProgramSymbols","_freeVariables","_symbols","top","this","toSymbols","toUpvars","freeVar","addString","symbol","arg","local","hasLocal","_name","child","locals","LocalSymbols","constructor","parent","paramSymbols","values","array","item","index","indexOf","push","unimpl","message","buildStatements","statements","symbols","buildStatement","buildNormalizedStatements","normalized","Op","TrustingAppend","buildGetPath","buildExpression","builtParams","buildParams","builtHash","buildHash","builtExpr","buildCallHead","VariableResolutionContext","ResolveAsHelperHead","ResolveAsComponentOrHelperHead","buildBlock","buildBlocks","ResolveAsComponentHead","buildKeyword","hasSplat","OpenElementWithSplat","OpenElement","args","AttrSplat","buildAttributeValue","extractNamespace","buildElementParams","assert","FlushElement","CloseElement","buildElement","arr","interpolated","reduce","string","i","String","c","unicode","charCode","fromCharCode","parseInt","NEWLINE","childSymbols","inverse","Let","If","keyExpr","Each","some","NS_XMLNS","NS_XLINK","NS_XML","namespace","val","StaticAttr","undefined","DynamicAttr","varContext","context","bare","buildVar","buildConcat","Strict","Undefined","callHead","sym","op","GetSymbol","GetStrictKeyword","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHead","ResolveAsModifierHead","GetFreeAsModifierHead","GetFreeAsComponentHead","exhausted","expressionContextOp","getSymbolForVar","exprs","e","LOCAL_SHOULD_LOG","window","location","search","Template","node","fields","InElement","Not","IfInline","WithDynamicVars","GetDynamicVar","Log","InvokeComponent","NamedBlocks","NamedBlock","AppendTrustedHTML","AppendTextNode","AppendComment","Component","SimpleElement","ElementParameters","Yield","Debugger","CallExpression","InvokeBlock","SplatAttr","PathExpression","Missing","InterpolateExpression","Curry","Positional","NamedArguments","NamedArgument","Args","Tail","PresentList","list","toArray","mapPresentArray","filter","predicate","OptionalList","toPresentArray","into","ifPresent","EmptyList","_callback","_predicate","ifEmpty","ResultImpl","all","results","isErr","cast","Ok","Result","OkImpl","isOk","super","_message","ifOk","andThen","mapOk","ifErr","mapErr","ErrImpl","reason","Err","ResultArray","items","add","err","toOptionalList","convertPathToCallIfKeyword","ref","KEYWORDS_TYPES","ASTv2","callee","empty","loc","VISIT_EXPRS","visit","state","Interpolate","translated","CALL_KEYWORDS","translate","visitList","nodes","VariableReference","tailLoc","extend","getLast","mir","members","literal","keyword","parts","positional","named","pairs","KeywordImpl","types","delegate","Set","nodeType","KEYWORD_NODES","has","getCalleeExpression","generateSyntaxError","asString","param","Keywords","_keywords","_type","kw","isKeyword","usedType","validTypes","includes","typesToReadableName","join","generateTypesMessage","keywords","toAppend","text","CurriedTypeToReadableType","CurriedTypes","Helper","assertCurryKeyword","curriedType","readableType","stringsAllowed","definition","nth","isStrict","PositionalArguments","translateCurryKeyword","definitionResult","argsResult","curryKeyword","getDynamicVarKeyword","call","positionals","isEmpty","varName","size","assertHasBlockKeyword","SourceSlice","synthetic","isLiteral","toSlice","translateHasBlockKeyword","scope","target","allocateBlock","chars","hasBlockKeyword","assertIfUnlessInlineKeyword","originalNode","inverted","condition","truthy","falsy","translateIfUnlessInlineKeyword","conditionResult","truthyResult","falsyResult","ifUnlessInlineKeyword","logKeyword","APPEND_KEYWORDS","src","SourceSpan","get","to","setHasDebugger","BLOCK_KEYWORDS","guid","insertBefore","destination","body","VISIT_STMTS","destinationResult","collapse","generateUniqueCursor","blockResult","inverseResult","every","valueResult","keyResult","positionalResult","namedResult","blocksResult","MODIFIER_KEYWORDS","XLINK","XML","XMLNS","WHITELIST","xmlns","DEFLATE_TAG_TABLE","div","WellKnownTagNames","span","p","INFLATE_TAG_TABLE","inflateTagName","tagName","DEFLATE_ATTR_TABLE","class","WellKnownAttrNames","id","style","href","INFLATE_ATTR_TABLE","deflateAttrName","attrName","inflateAttrName","ClassifiedElement","element","toStatement","prepare","prepared","rawValue","component","dynamicFeatures","isTrusting","trusting","modifier","typeAttr","simple","componentArgs","maybeLoc","NON_EXISTENT","modifiers","m","elementParams","ClassifiedComponent","tag","ClassifiedSimpleElement","isComponent","classified","AppendContent","TextNode","HtmlComment","b","visitBlock","hasDynamicFeatures","append","html","LiteralExpression","comment","NormalizationState","_currentScope","_cursorCount","oldBlock","ResolutionType","StrictModeValidationPass","validate","template","Statements","Statement","Expressions","expressions","Expression","resolution","errorFor","ElementParameter","inElement","ComponentOrHelper","Value","WireFormatDebugger","upvars","_statements","_hasEval","format","program","formatOpcode","opcode","formatParams","formatHash","formatBlocks","StaticComponentAttr","ComponentAttr","DynamicArg","StaticArg","TrustingDynamicAttr","TrustingComponentAttr","formatElementParams","formatCurryType","GetLexicalSymbol","formatBlock","opcodes","o","accum","parameters","EXPR","SexpOpcodes","isTemplateLocal","getOp","member","l","names","pair","assertPresentArray","WireStatements","CONTENT","content","stmt","LOCAL_LOGGER","log","visitContent","getDebugInfo","wireBlock","wireDestination","wireInsertBefore","wireTag","wirePositional","wireNamed","wireNamedBlocks","dynamicAttrOp","dynamicAttr","staticAttrOp","staticAttr","serializedBlocks","serializedBlock","nameChars","slots","defaultId","req","module","require","globalThis","crypto","idFn","createHash","update","digest","substring","defaultOptions","precompileJSON","options","source","Source","meta","moduleName","ast","normalize","lexicalScope","root","table","groupCollapsed","groupEnd","pass0","strictMode","pass2In","hasEval","debug","pass2","SCOPE_PLACEHOLDER","precompile","usedLocals","blockJSON","templateJSONObject","isStrictMode","stringified","scopeFn","replace"],"mappings":"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"}
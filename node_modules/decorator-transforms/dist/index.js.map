{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type * as Babel from \"@babel/core\";\nimport type { types as t, NodePath } from \"@babel/core\";\nimport { createRequire } from \"node:module\";\nimport { ImportUtil, type Importer } from \"babel-import-util\";\nimport { globalId } from \"./global-id.ts\";\nconst req = createRequire(import.meta.url);\nconst { default: decoratorSyntax } = req(\"@babel/plugin-syntax-decorators\");\n\ninterface State extends Babel.PluginPass {\n  currentClassBodies: t.ClassBody[];\n  currentObjectExpressions: {\n    decorated: [\n      \"field\" | \"method\",\n      t.Expression, // for the property name\n      t.Expression[] // for the decorators applied to it\n    ][];\n  }[];\n  opts: Options;\n  runtime: (i: Importer, fnName: string) => t.Expression;\n  util: ImportUtil;\n  optsWithDefaults: Required<Options>;\n}\n\nexport interface Options {\n  runtime?: \"globals\" | { import: string };\n  runEarly?: boolean;\n}\n\nfunction makeVisitor(babel: typeof Babel): Babel.Visitor<State> {\n  const t = babel.types;\n  return {\n    Program(path: NodePath<t.Program>, state: State) {\n      state.currentClassBodies = [];\n      state.currentObjectExpressions = [];\n      state.optsWithDefaults = {\n        runtime: \"globals\",\n        runEarly: false,\n        ...state.opts,\n      };\n      state.util = new ImportUtil(babel, path);\n      state.runtime = (i: Importer, fnName: string) => {\n        const { runtime } = state.optsWithDefaults;\n        if (runtime === \"globals\") {\n          return t.memberExpression(\n            t.identifier(globalId),\n            t.identifier(fnName)\n          );\n        } else {\n          return i.import(runtime.import, fnName);\n        }\n      };\n    },\n    ClassBody: {\n      enter(path, state) {\n        state.currentClassBodies.unshift(path.node);\n      },\n      exit(_path, state) {\n        state.currentClassBodies.shift();\n      },\n    },\n    ClassExpression(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        state.util.replaceWith(path, (i) => {\n          let call = t.callExpression(state.runtime(i, \"c\"), [\n            path.node,\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression)\n            ),\n          ]);\n          for (let decorator of decorators) {\n            decorator.remove();\n          }\n          return call;\n        });\n      }\n    },\n    ClassDeclaration(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        const buildCall = (i: Importer) => {\n          return t.callExpression(state.runtime(i, \"c\"), [\n            t.classExpression(\n              path.node.id,\n              path.node.superClass,\n              path.node.body,\n              [] // decorators removed here\n            ),\n            t.arrayExpression(\n              decorators\n                .slice()\n                .reverse()\n                .map((d) => d.node.expression)\n            ),\n          ]);\n        };\n\n        if (path.parentPath.isExportDefaultDeclaration()) {\n          let id = path.node.id;\n          if (id) {\n            state.util.insertBefore(path.parentPath, (i) =>\n              t.variableDeclaration(\"const\", [\n                t.variableDeclarator(id, buildCall(i)),\n              ])\n            );\n            path.parentPath.replaceWith(t.exportDefaultDeclaration(id));\n          } else {\n            state.util.replaceWith(path.parentPath, (i) =>\n              t.exportDefaultDeclaration(buildCall(i))\n            );\n          }\n        } else if (path.parentPath.isExportNamedDeclaration()) {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.insertBefore(path.parentPath, (i) =>\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i)),\n            ])\n          );\n          path.parentPath.replaceWith(\n            t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)])\n          );\n        } else {\n          let id = path.node.id;\n          if (!id) {\n            throw new Error(\n              `bug: expected a class name is required in this context`\n            );\n          }\n          state.util.replaceWith(path, (i) =>\n            t.variableDeclaration(\"const\", [\n              t.variableDeclarator(id, buildCall(i)),\n            ])\n          );\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype: t.Expression;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        let args: t.Expression[] = [\n          prototype,\n          valueForFieldKey(t, path.node.key),\n          t.arrayExpression(\n            decorators\n              .slice()\n              .reverse()\n              .map((d) => d.node.expression)\n          ),\n        ];\n        if (path.node.value) {\n          args.push(\n            t.functionExpression(\n              null,\n              [],\n              t.blockStatement([t.returnStatement(path.node.value)])\n            )\n          );\n        }\n        state.util.insertBefore(path, (i) =>\n          t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"g\"), args)\n            ),\n          ])\n        );\n        state.util.insertBefore(path, (i) =>\n          t.classPrivateProperty(\n            t.privateName(\n              t.identifier(\n                unusedPrivateNameLike(state, propName(path.node.key))\n              )\n            ),\n            t.sequenceExpression([\n              t.callExpression(state.runtime(i, \"i\"), [\n                t.thisExpression(),\n                valueForFieldKey(t, path.node.key),\n              ]),\n              t.identifier(\"void 0\"),\n            ])\n          )\n        );\n        path.remove();\n      }\n    },\n    ClassMethod(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        let prototype: t.Expression;\n        if (path.node.static) {\n          prototype = t.thisExpression();\n        } else {\n          prototype = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"prototype\")\n          );\n        }\n        state.util.insertAfter(path, (i) =>\n          t.staticBlock([\n            t.expressionStatement(\n              t.callExpression(state.runtime(i, \"n\"), [\n                prototype,\n                valueForFieldKey(t, path.node.key),\n                t.arrayExpression(\n                  decorators\n                    .slice()\n                    .reverse()\n                    .map((d) => d.node.expression)\n                ),\n              ])\n            ),\n          ])\n        );\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n    ObjectExpression: {\n      enter(_path, state) {\n        state.currentObjectExpressions.unshift({\n          decorated: [],\n        });\n      },\n      exit(path, state) {\n        let { decorated } = state.currentObjectExpressions.shift()!;\n        if (decorated.length > 0) {\n          state.util.replaceWith(path, (i) =>\n            t.callExpression(state.runtime(i, \"p\"), [\n              path.node,\n              t.arrayExpression(\n                decorated.map(([type, prop, decorators]) =>\n                  t.arrayExpression([\n                    t.stringLiteral(type),\n                    prop,\n                    t.arrayExpression(decorators),\n                  ])\n                )\n              ),\n            ])\n          );\n        }\n      },\n    },\n    ObjectProperty(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        if (prop.type === \"PrivateName\") {\n          throw new Error(`cannot decorate private field`);\n        }\n        state.currentObjectExpressions[0].decorated.push([\n          \"field\",\n          valueForFieldKey(t, prop),\n          decorators\n            .slice()\n            .reverse()\n            .map((d) => d.node.expression),\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n\n    ObjectMethod(path, state) {\n      let decorators = path.get(\"decorators\") as\n        | NodePath<t.Decorator>[]\n        | NodePath<undefined>;\n      if (Array.isArray(decorators) && decorators.length > 0) {\n        if (state.currentObjectExpressions.length === 0) {\n          throw new Error(\n            `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`\n          );\n        }\n        let prop = path.node.key;\n        state.currentObjectExpressions[0].decorated.push([\n          \"method\",\n          valueForFieldKey(t, prop),\n          decorators\n            .slice()\n            .reverse()\n            .map((d) => d.node.expression),\n        ]);\n        for (let decorator of decorators) {\n          decorator.remove();\n        }\n      }\n    },\n  };\n}\n\nexport default function legacyDecoratorCompat(\n  babel: typeof Babel\n): Babel.PluginObj<State> {\n  let visitor: Babel.Visitor<State> | undefined = makeVisitor(babel);\n  return {\n    inherits: (api: unknown, _options: unknown, dirname: unknown) =>\n      decoratorSyntax(api, { legacy: true }, dirname),\n    pre(this: State, file) {\n      if (this.opts.runEarly) {\n        babel.traverse(file.ast, makeVisitor(babel), file.scope, this);\n        visitor = undefined;\n      }\n    },\n    get visitor() {\n      return visitor ?? {};\n    },\n  };\n}\n\nfunction unusedPrivateNameLike(state: State, name: string): string {\n  let classBody = state.currentClassBodies[0];\n  if (!classBody) {\n    throw new Error(\n      `bug: no current class body around our class field decorator`\n    );\n  }\n  let usedNames = new Set();\n  for (let element of classBody.body) {\n    if (\n      (element.type === \"ClassPrivateProperty\" ||\n        element.type === \"ClassPrivateMethod\" ||\n        element.type === \"ClassAccessorProperty\") &&\n      element.key.type === \"PrivateName\"\n    ) {\n      usedNames.add(element.key.id.name);\n    }\n  }\n  let candidate = name;\n  while (usedNames.has(candidate)) {\n    candidate = candidate + \"_\";\n  }\n  return candidate;\n}\n\n// derive a best-effort name we can use when creating a private-field\nfunction propName(expr: t.Expression): string {\n  if (expr.type === \"Identifier\") {\n    return expr.name;\n  }\n  if (expr.type === \"BigIntLiteral\" || expr.type === \"NumericLiteral\") {\n    return `_${expr.value}`;\n  }\n  if (expr.type === \"StringLiteral\") {\n    return \"_\" + expr.value.replace(/[^a-zA-Z]/g, \"\");\n  }\n  return \"_\";\n}\n\n// turn the field key into a runtime value. Identifiers are special because they\n// need to become string literals, anything else is already usable as a value.\nfunction valueForFieldKey(\n  t: (typeof Babel)[\"types\"],\n  expr: t.Expression\n): t.Expression {\n  if (expr.type === \"Identifier\") {\n    return t.stringLiteral(expr.name);\n  }\n  return expr;\n}\n"],"mappings":"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","names":[]}
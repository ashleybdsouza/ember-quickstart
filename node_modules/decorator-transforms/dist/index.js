import {
  globalId
} from "./chunk-P25EBXNA.js";
import "./chunk-CSAU5B4Q.js";

// src/index.ts
import { createRequire } from "module";
import { ImportUtil } from "babel-import-util";
var req = createRequire(import.meta.url);
var { default: decoratorSyntax } = req("@babel/plugin-syntax-decorators");
function makeVisitor(babel) {
  const t = babel.types;
  return {
    Program(path, state) {
      state.currentClassBodies = [];
      state.currentObjectExpressions = [];
      state.optsWithDefaults = {
        runtime: "globals",
        runEarly: false,
        ...state.opts
      };
      state.util = new ImportUtil(babel, path);
      state.runtime = (i, fnName) => {
        const { runtime } = state.optsWithDefaults;
        if (runtime === "globals") {
          return t.memberExpression(
            t.identifier(globalId),
            t.identifier(fnName)
          );
        } else {
          return i.import(runtime.import, fnName);
        }
      };
    },
    ClassBody: {
      enter(path, state) {
        state.currentClassBodies.unshift(path.node);
      },
      exit(_path, state) {
        state.currentClassBodies.shift();
      }
    },
    ClassExpression(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        state.util.replaceWith(path, (i) => {
          let call = t.callExpression(state.runtime(i, "c"), [
            path.node,
            t.arrayExpression(
              decorators.slice().reverse().map((d) => d.node.expression)
            )
          ]);
          for (let decorator of decorators) {
            decorator.remove();
          }
          return call;
        });
      }
    },
    ClassDeclaration(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        const buildCall = (i) => {
          return t.callExpression(state.runtime(i, "c"), [
            t.classExpression(
              path.node.id,
              path.node.superClass,
              path.node.body,
              []
              // decorators removed here
            ),
            t.arrayExpression(
              decorators.slice().reverse().map((d) => d.node.expression)
            )
          ]);
        };
        if (path.parentPath.isExportDefaultDeclaration()) {
          let id = path.node.id;
          if (id) {
            state.util.insertBefore(
              path.parentPath,
              (i) => t.variableDeclaration("const", [
                t.variableDeclarator(id, buildCall(i))
              ])
            );
            path.parentPath.replaceWith(t.exportDefaultDeclaration(id));
          } else {
            state.util.replaceWith(
              path.parentPath,
              (i) => t.exportDefaultDeclaration(buildCall(i))
            );
          }
        } else if (path.parentPath.isExportNamedDeclaration()) {
          let id = path.node.id;
          if (!id) {
            throw new Error(
              `bug: expected a class name is required in this context`
            );
          }
          state.util.insertBefore(
            path.parentPath,
            (i) => t.variableDeclaration("const", [
              t.variableDeclarator(id, buildCall(i))
            ])
          );
          path.parentPath.replaceWith(
            t.exportNamedDeclaration(null, [t.exportSpecifier(id, id)])
          );
        } else {
          let id = path.node.id;
          if (!id) {
            throw new Error(
              `bug: expected a class name is required in this context`
            );
          }
          state.util.replaceWith(
            path,
            (i) => t.variableDeclaration("const", [
              t.variableDeclarator(id, buildCall(i))
            ])
          );
        }
      }
    },
    ClassProperty(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        let prototype;
        if (path.node.static) {
          prototype = t.thisExpression();
        } else {
          prototype = t.memberExpression(
            t.thisExpression(),
            t.identifier("prototype")
          );
        }
        let args = [
          prototype,
          valueForFieldKey(t, path.node.key),
          t.arrayExpression(
            decorators.slice().reverse().map((d) => d.node.expression)
          )
        ];
        if (path.node.value) {
          args.push(
            t.functionExpression(
              null,
              [],
              t.blockStatement([t.returnStatement(path.node.value)])
            )
          );
        }
        state.util.insertBefore(
          path,
          (i) => t.staticBlock([
            t.expressionStatement(
              t.callExpression(state.runtime(i, "g"), args)
            )
          ])
        );
        state.util.insertBefore(
          path,
          (i) => t.classPrivateProperty(
            t.privateName(
              t.identifier(
                unusedPrivateNameLike(state, propName(path.node.key))
              )
            ),
            t.sequenceExpression([
              t.callExpression(state.runtime(i, "i"), [
                t.thisExpression(),
                valueForFieldKey(t, path.node.key)
              ]),
              t.identifier("void 0")
            ])
          )
        );
        path.remove();
      }
    },
    ClassMethod(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        let prototype;
        if (path.node.static) {
          prototype = t.thisExpression();
        } else {
          prototype = t.memberExpression(
            t.thisExpression(),
            t.identifier("prototype")
          );
        }
        state.util.insertAfter(
          path,
          (i) => t.staticBlock([
            t.expressionStatement(
              t.callExpression(state.runtime(i, "n"), [
                prototype,
                valueForFieldKey(t, path.node.key),
                t.arrayExpression(
                  decorators.slice().reverse().map((d) => d.node.expression)
                )
              ])
            )
          ])
        );
        for (let decorator of decorators) {
          decorator.remove();
        }
      }
    },
    ObjectExpression: {
      enter(_path, state) {
        state.currentObjectExpressions.unshift({
          decorated: []
        });
      },
      exit(path, state) {
        let { decorated } = state.currentObjectExpressions.shift();
        if (decorated.length > 0) {
          state.util.replaceWith(
            path,
            (i) => t.callExpression(state.runtime(i, "p"), [
              path.node,
              t.arrayExpression(
                decorated.map(
                  ([type, prop, decorators]) => t.arrayExpression([
                    t.stringLiteral(type),
                    prop,
                    t.arrayExpression(decorators)
                  ])
                )
              )
            ])
          );
        }
      }
    },
    ObjectProperty(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        if (state.currentObjectExpressions.length === 0) {
          throw new Error(
            `bug in decorator-transforms: didn't expect to see ObjectProperty outside ObjectExpression`
          );
        }
        let prop = path.node.key;
        if (prop.type === "PrivateName") {
          throw new Error(`cannot decorate private field`);
        }
        state.currentObjectExpressions[0].decorated.push([
          "field",
          valueForFieldKey(t, prop),
          decorators.slice().reverse().map((d) => d.node.expression)
        ]);
        for (let decorator of decorators) {
          decorator.remove();
        }
      }
    },
    ObjectMethod(path, state) {
      let decorators = path.get("decorators");
      if (Array.isArray(decorators) && decorators.length > 0) {
        if (state.currentObjectExpressions.length === 0) {
          throw new Error(
            `bug in decorator-transforms: didn't expect to see ObjectMethod outside ObjectExpression`
          );
        }
        let prop = path.node.key;
        state.currentObjectExpressions[0].decorated.push([
          "method",
          valueForFieldKey(t, prop),
          decorators.slice().reverse().map((d) => d.node.expression)
        ]);
        for (let decorator of decorators) {
          decorator.remove();
        }
      }
    }
  };
}
function legacyDecoratorCompat(babel) {
  let visitor = makeVisitor(babel);
  return {
    inherits: (api, _options, dirname) => decoratorSyntax(api, { legacy: true }, dirname),
    pre(file) {
      if (this.opts.runEarly) {
        babel.traverse(file.ast, makeVisitor(babel), file.scope, this);
        visitor = void 0;
      }
    },
    get visitor() {
      return visitor ?? {};
    }
  };
}
function unusedPrivateNameLike(state, name) {
  let classBody = state.currentClassBodies[0];
  if (!classBody) {
    throw new Error(
      `bug: no current class body around our class field decorator`
    );
  }
  let usedNames = /* @__PURE__ */ new Set();
  for (let element of classBody.body) {
    if ((element.type === "ClassPrivateProperty" || element.type === "ClassPrivateMethod" || element.type === "ClassAccessorProperty") && element.key.type === "PrivateName") {
      usedNames.add(element.key.id.name);
    }
  }
  let candidate = name;
  while (usedNames.has(candidate)) {
    candidate = candidate + "_";
  }
  return candidate;
}
function propName(expr) {
  if (expr.type === "Identifier") {
    return expr.name;
  }
  if (expr.type === "BigIntLiteral" || expr.type === "NumericLiteral") {
    return `_${expr.value}`;
  }
  if (expr.type === "StringLiteral") {
    return "_" + expr.value.replace(/[^a-zA-Z]/g, "");
  }
  return "_";
}
function valueForFieldKey(t, expr) {
  if (expr.type === "Identifier") {
    return t.stringLiteral(expr.name);
  }
  return expr;
}
export {
  legacyDecoratorCompat as default
};
//# sourceMappingURL=index.js.map
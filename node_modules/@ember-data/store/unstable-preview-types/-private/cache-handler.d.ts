declare module '@ember-data/store/-private/cache-handler' {
  /**
   * @module @ember-data/store
   */
  import type { CacheHandler as CacheHandlerType } from '@ember-data/request';
  import type { StableDocumentIdentifier } from '@warp-drive/core-types/identifier';
  import type { ImmutableRequestInfo, RequestContext, ResponseInfo } from '@warp-drive/core-types/request';
  import { EnableHydration } from '@warp-drive/core-types/request';
  import type { ResourceIdentifierObject } from '@warp-drive/core-types/spec/json-api-raw';
  import type { Store } from '@ember-data/store/-private/store-service';
  /**
   * A service which an application may provide to the store via
   * the store's `lifetimes` property to configure the behavior
   * of the CacheHandler.
   *
   * The default behavior for request lifetimes is to never expire
   * unless manually refreshed via `cacheOptions.reload` or `cacheOptions.backgroundReload`.
   *
   * Implementing this service allows you to programatically define
   * when a request should be considered expired.
   *
   * @class <Interface> CachePolicy
   * @public
   */
  export interface CachePolicy {
      /**
       * Invoked to determine if the request may be fulfilled from cache
       * if possible.
       *
       * Note, this is only invoked if the request has a cache-key.
       *
       * If no cache entry is found or the entry is hard expired,
       * the request will be fulfilled from the configured request handlers
       * and the cache will be updated before returning the response.
       *
       * @method isHardExpired
       * @public
       * @param {StableDocumentIdentifier} identifier
       * @param {Store} store
       * @return {boolean} true if the request is considered hard expired
       */
      isHardExpired(identifier: StableDocumentIdentifier, store: Store): boolean;
      /**
       * Invoked if `isHardExpired` is false to determine if the request
       * should be update behind the scenes if cache data is already available.
       *
       * Note, this is only invoked if the request has a cache-key.
       *
       * If true, the request will be fulfilled from cache while a backgrounded
       * request is made to update the cache via the configured request handlers.
       *
       * @method isSoftExpired
       * @public
       * @param {StableDocumentIdentifier} identifier
       * @param {Store} store
       * @return {boolean} true if the request is considered soft expired
       */
      isSoftExpired(identifier: StableDocumentIdentifier, store: Store): boolean;
      /**
       * Invoked when a request will be sent to the configured request handlers.
       * This is invoked for both foreground and background requests.
       *
       * Note, this is invoked regardless of whether the request has a cache-key.
       *
       * @method willRequest [Optional]
       * @public
       * @param {ImmutableRequestInfo} request
       * @param {StableDocumentIdentifier | null} identifier
       * @param {Store} store
       * @return {void}
       */
      willRequest?(request: ImmutableRequestInfo, identifier: StableDocumentIdentifier | null, store: Store): void;
      /**
       * Invoked when a request has been fulfilled from the configured request handlers.
       * This is invoked for both foreground and background requests once the cache has
       * been updated.
       *
       * Note, this is invoked regardless of whether the request has a cache-key.
       *
       * @method didRequest [Optional]
       * @public
       * @param {ImmutableRequestInfo} request
       * @param {ImmutableResponse} response
       * @param {StableDocumentIdentifier | null} identifier
       * @param {Store} store
       * @return {void}
       */
      didRequest?(request: ImmutableRequestInfo, response: Response | ResponseInfo | null, identifier: StableDocumentIdentifier | null, store: Store): void;
  }
  export type LooseStoreRequestInfo<T = unknown, RT = unknown> = Omit<ImmutableRequestInfo<T, RT>, 'records' | 'headers'> & {
      records?: ResourceIdentifierObject[];
      headers?: Headers;
  };
  export type StoreRequestInput<T = unknown, RT = unknown> = ImmutableRequestInfo<T, RT> | LooseStoreRequestInfo<T, RT>;
  export interface StoreRequestContext extends RequestContext {
      request: ImmutableRequestInfo & {
          store: Store;
          [EnableHydration]?: boolean;
      };
  }
  /**
   * A CacheHandler that adds support for using an EmberData Cache with a RequestManager.
   *
   * This handler will only run when a request has supplied a `store` instance. Requests
   * issued by the store via `store.request()` will automatically have the `store` instance
   * attached to the request.
   *
   * ```ts
   * requestManager.request({
   *   store: store,
   *   url: '/api/posts',
   *   method: 'GET'
   * });
   * ```
   *
   * When this handler elects to handle a request, it will return the raw `StructuredDocument`
   * unless the request has `[EnableHydration]` set to `true`. In this case, the handler will
   * return a `Document` instance that will automatically update the UI when the cache is updated
   * in the future and will hydrate any identifiers in the StructuredDocument into Record instances.
   *
   * When issuing a request via the store, [EnableHydration] is automatically set to `true`. This
   * means that if desired you can issue requests that utilize the cache without needing to also
   * utilize Record instances if desired.
   *
   * Said differently, you could elect to issue all requests via a RequestManager, without ever using
   * the store directly, by setting [EnableHydration] to `true` and providing a store instance. Not
   * necessarily the most useful thing, but the decoupled nature of the RequestManager and incremental-feature
   * approach of EmberData allows for this flexibility.
   *
   * ```ts
   * import { EnableHydration } from '@warp-drive/core-types/request';
   *
   * requestManager.request({
   *   store: store,
   *   url: '/api/posts',
   *   method: 'GET',
   *   [EnableHydration]: true
   * });
   *
   * @typedoc
   */
  export const CacheHandler: CacheHandlerType;
}
//# sourceMappingURL=cache-handler.d.ts.map
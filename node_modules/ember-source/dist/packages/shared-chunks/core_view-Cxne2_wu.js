import '../@ember/-internals/meta/lib/meta.js';
import './mandatory-setter-1UQhiJOb.js';
import '@embroider/macros';
import './index-DTxy4Zgx.js';
import '../@glimmer/destroyable/index.js';
import '../@glimmer/validator/index.js';
import { f as inject } from './cache-gDE3bkXq.js';
import '../@glimmer/manager/index.js';
import './env-BJLX2Arx.js';
import '../@ember/-internals/runtime/lib/mixins/registry_proxy.js';
import '../@ember/-internals/runtime/lib/mixins/container_proxy.js';
import '../@ember/-internals/runtime/lib/mixins/comparable.js';
import ActionHandler from '../@ember/-internals/runtime/lib/mixins/action_handler.js';
import '../@ember/-internals/runtime/lib/mixins/-proxy.js';
import '../@ember/enumerable/mutable.js';
import '../@ember/-internals/runtime/lib/mixins/target_action_support.js';
import '../@ember/-internals/runtime/lib/ext/rsvp.js';
import Evented from '../@ember/object/evented.js';
import { FrameworkObject } from '../@ember/object/-internals.js';
import states from '../@ember/-internals/views/lib/views/states.js';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};

// src/runtime.ts
var runtime_exports = {};
__export(runtime_exports, {
  c: () => decorateClass,
  f: () => decorateFieldV1,
  g: () => decorateFieldV2,
  i: () => initializeDeferredDecorator,
  m: () => decorateMethodV1,
  n: () => decorateMethodV2,
  p: () => decoratePOJO
});
var deferred = /* @__PURE__ */new WeakMap();
function deferDecorator(proto, prop, desc) {
  let map = deferred.get(proto);
  if (!map) {
    map = /* @__PURE__ */new Map();
    deferred.set(proto, map);
  }
  map.set(prop, desc);
}
function findDeferredDecorator(target, prop) {
  let cursor = target.prototype;
  while (cursor) {
    let desc = deferred.get(cursor)?.get(prop);
    if (desc) {
      return desc;
    }
    cursor = cursor.prototype;
  }
}
function decorateFieldV1(target, prop, decorators, initializer) {
  return decorateFieldV2(target.prototype, prop, decorators, initializer);
}
function decorateFieldV2(prototype, prop, decorators, initializer) {
  let desc = {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: null
  };
  if (initializer) {
    desc.initializer = initializer;
  }
  for (let decorator of decorators) {
    desc = decorator(prototype, prop, desc) || desc;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(prototype, prop, desc);
  } else {
    deferDecorator(prototype, prop, desc);
  }
}
function decorateMethodV1({
  prototype
}, prop, decorators) {
  return decorateMethodV2(prototype, prop, decorators);
}
function decorateMethodV2(prototype, prop, decorators) {
  const origDesc = Object.getOwnPropertyDescriptor(prototype, prop);
  let desc = {
    ...origDesc
  };
  for (let decorator of decorators) {
    desc = decorator(prototype, prop, desc) || desc;
  }
  if (desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(prototype) : void 0;
    desc.initializer = void 0;
  }
  Object.defineProperty(prototype, prop, desc);
}
function initializeDeferredDecorator(target, prop) {
  let desc = findDeferredDecorator(target.constructor, prop);
  if (desc) {
    Object.defineProperty(target, prop, {
      enumerable: desc.enumerable,
      configurable: desc.configurable,
      writable: desc.writable,
      value: desc.initializer ? desc.initializer.call(target) : void 0
    });
  }
}
function decorateClass(target, decorators) {
  return decorators.reduce((accum, decorator) => decorator(accum) || accum, target);
}
function decoratePOJO(pojo, decorated) {
  for (let [type, prop, decorators] of decorated) {
    if (type === "field") {
      decoratePojoField(pojo, prop, decorators);
    } else {
      decorateMethodV2(pojo, prop, decorators);
    }
  }
  return pojo;
}
function decoratePojoField(pojo, prop, decorators) {
  let desc = {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: () => Object.getOwnPropertyDescriptor(pojo, prop)?.value
  };
  for (let decorator of decorators) {
    desc = decorator(pojo, prop, desc) || desc;
  }
  if (desc.initializer) {
    desc.value = desc.initializer.call(pojo);
    delete desc.initializer;
  }
  Object.defineProperty(pojo, prop, desc);
}

class CoreView extends FrameworkObject.extend(Evented, ActionHandler) {
  isView = true;
  _superTrigger;
  _superHas;

  /**
    If the view is currently inserted into the DOM of a parent view, this
    property will point to the parent of the view.
     @property parentView
    @type Ember.View
    @default null
    @private
  */

  init(properties) {
    super.init(properties);

    // Handle methods from Evented
    // The native class inheritance will not work for mixins. To work around this,
    // we copy the existing trigger and has methods provided by the mixin and swap in the
    // new ones from our class.
    this._superTrigger = this.trigger;
    this.trigger = this._trigger;
    this._superHas = this.has;
    this.has = this._has;
    this.parentView ??= null;
    this._state = 'preRender';
    this._currentState = this._states.preRender;
  }
  static {
    decorateFieldV2(this.prototype, "renderer", [inject('renderer', '-dom')]);
  }
  #renderer = (initializeDeferredDecorator(this, "renderer"), void 0);
  instrumentDetails(hash) {
    hash['object'] = this.toString();
    hash['containerKey'] = this._debugContainerKey;
    hash['view'] = this;
    return hash;
  }

  /**
    Override the default event firing from `Evented` to
    also call methods with the given name.
     @method trigger
    @param name {String}
    @private
  */
  // Changed to `trigger` on init
  _trigger(name, ...args) {
    this._superTrigger(name, ...args);
    let method = this[name];
    if (typeof method === 'function') {
      return method.apply(this, args);
    }
  }

  // Changed to `has` on init
  _has(name) {
    return typeof this[name] === 'function' || this._superHas(name);
  }
  static isViewFactory = true;
}

// Declare on the prototype to have a single shared value.
CoreView.prototype._states = states;

export { CoreView as C, decorateMethodV2 as a, decorateFieldV2 as d, initializeDeferredDecorator as i };

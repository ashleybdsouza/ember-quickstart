import { templateFactory, programCompilationContext } from '../@glimmer/opcode-compiler/index.js';
import { g as getFactoryFor, p as privatize, R as Registry } from './registry-DzfcDwii.js';
import { a as assert, w as warn, b as inspect, h as debugFreeze, d as deprecate, i as info } from './index-DTxy4Zgx.js';
import { on as on$1, reifyPositional, normalizeProperty, EMPTY_ARGS, createCapturedArgs, EMPTY_POSITIONAL, curry, hash, array, concat, fn, get as get$1, templateOnlyComponent, TEMPLATE_ONLY_COMPONENT_MANAGER, runtimeContext, DOMTreeConstruction, DOMChanges, clientBuilder, inTransaction, renderMain, rehydrationBuilder } from '../@glimmer/runtime/index.js';
import { a0 as tracked, g as get, j as join, Q as PROPERTY_DID_CHANGE, t as tagForObject, R as objectAt, a as tagForProperty, _ as _backburner, a6 as _getProp, s as schedule, Z as _getCurrentRunLoop, ac as flushAsyncObservers, N as once, B as descriptorForProperty, d as defineProperty, x as addObserver, c as computed, O as run, ag as scheduleOnce, ah as cancel } from './cache-gDE3bkXq.js';
import { valueForRef, isConstRef, createConstRef, isUpdatableRef, updateRef, createPrimitiveRef, childRefFor, createComputeRef, childRefFromParts, isInvokableRef, createUnboundRef, createInvokableRef, createReadOnlyRef, createDebugAliasRef, UNDEFINED_REFERENCE } from '../@glimmer/reference/index.js';
import { untrack, consumeTag, tagFor, createCache, getValue, valueForTag, beginUntrackFrame, endUntrackFrame, beginTrackFrame, endTrackFrame, validateTag, createTag, dirtyTag as DIRTY_TAG$1, CONSTANT_TAG, isTracking, debug, createUpdatableTag, CURRENT_TAG } from '../@glimmer/validator/index.js';
import { isDevelopingApp } from '@embroider/macros';
import { setModifierManager as setModifierManager$1, setInternalComponentManager, setComponentTemplate, setInternalHelperManager, setHelperManager, getInternalHelperManager, helperCapabilities, capabilityFlagsFrom, setInternalModifierManager, getInternalComponentManager, getComponentTemplate } from '../@glimmer/manager/index.js';
import { h as hasDOM } from './index-BGP1rw3B.js';
import { b as action$1, i as isArray, E as EmberObject, t as typeOf, A } from './index-PYiGj1jp.js';
import { isSimpleClick, getViewElement, clearElementView, clearViewElement, addChildView, setViewElement, setElementView, constructStyleDeprecationMessage, getViewId } from '../@ember/-internals/views/lib/system/utils.js';
import '../@ember/-internals/meta/lib/meta.js';
import { g as guidFor, a as getDebugName, e as isObject, u as uuid, l as lookupDescriptor } from './mandatory-setter-1UQhiJOb.js';
import { registerDestructor, associateDestroyableChild, destroy } from '../@glimmer/destroyable/index.js';
import { E as ENV } from './env-BJLX2Arx.js';
import ActionManager from '../@ember/-internals/views/lib/system/action_manager.js';
import ComponentLookup from '../@ember/-internals/views/lib/component_lookup.js';
import { d as decorateFieldV2, i as initializeDeferredDecorator, a as decorateMethodV2, C as CoreView } from './core_view-Cxne2_wu.js';
import ClassNamesSupport from '../@ember/-internals/views/lib/mixins/class_names_support.js';
import ChildViewsSupport from '../@ember/-internals/views/lib/mixins/child_views_support.js';
import ViewStateSupport from '../@ember/-internals/views/lib/mixins/view_state_support.js';
import ViewMixin from '../@ember/-internals/views/lib/mixins/view_support.js';
import ActionSupport from '../@ember/-internals/views/lib/mixins/action_support.js';
import { getEngineParent, ENGINE_PARENT, setEngineParent } from '../@ember/engine/lib/engine-parent.js';
import { c as canInvoke } from './invoke-BjRgvK2V.js';
import Controller from '../@ember/controller/index.js';
import Namespace from '../@ember/application/namespace.js';
import DAG from '../dag-map/index.js';
import ContainerDebugAdapter from '../@ember/debug/container-debug-adapter.js';
import RegistryProxyMixin from '../@ember/-internals/runtime/lib/mixins/registry_proxy.js';
import ContainerProxyMixin from '../@ember/-internals/runtime/lib/mixins/container_proxy.js';
import '../@ember/-internals/runtime/lib/mixins/comparable.js';
import ActionHandler from '../@ember/-internals/runtime/lib/mixins/action_handler.js';
import { contentFor } from '../@ember/-internals/runtime/lib/mixins/-proxy.js';
import '../@ember/enumerable/mutable.js';
import TargetActionSupport from '../@ember/-internals/runtime/lib/mixins/target_action_support.js';
import '../@ember/-internals/runtime/lib/ext/rsvp.js';
import { setOwner, getOwner, isFactory } from '../@ember/-internals/owner/index.js';
import { a as RSVP, R as RSVP$1 } from './rsvp-DaQAFb0W.js';
import { _ as _setProp, s as set } from './property_set-CW4q-uo4.js';
import '../route-recognizer/index.js';
import { S as STATE_SYMBOL, P as PARAMS_SYMBOL, R as Router, l as logAbort } from './router-B-Q1aYBn.js';
import { readOnly } from '../@ember/object/lib/computed/computed_macros.js';
import Service, { service } from '../@ember/service/index.js';
import { getOwner as getOwner$1 } from '../@ember/owner/index.js';
import BucketCache from '../@ember/routing/lib/cache.js';
import DSLImpl from '../@ember/routing/lib/dsl.js';
import Evented from '../@ember/object/evented.js';
import { i as isProxy } from './is_proxy-Dmis-70B.js';
import { g as getProperties, s as setProperties } from './set_properties-DvalyQdu.js';
import generateController, { generateControllerFactory } from '../@ember/routing/lib/generate_controller.js';
import { deprecateUntil, DEPRECATIONS } from '../@ember/-internals/deprecations/index.js';
import { dependentKeyCompat } from '../@ember/object/compat.js';
import { isTesting } from '../@ember/debug/lib/testing.js';
import EventDispatcher from '../@ember/-internals/views/lib/system/event_dispatcher.js';
import { e as enumerableSymbol } from './to-string-D8i3mjEU.js';
import { flaggedInstrument, _instrumentStart } from '../@ember/instrumentation/index.js';
import { unwrapTemplate, EMPTY_ARRAY as EMPTY_ARRAY$1, dict } from '../@glimmer/util/index.js';
import { dasherize } from '../@ember/-internals/string/index.js';
import { MUTABLE_CELL } from '../@ember/-internals/views/lib/compat/attrs.js';
import { FrameworkObject } from '../@ember/object/-internals.js';
import { CurriedType as CurriedTypes } from '../@glimmer/vm/index.js';
import { RuntimeOpImpl, artifacts } from '../@glimmer/program/index.js';
import { NodeDOMTreeConstruction, serializeBuilder } from '../@glimmer/node/index.js';
import setGlobalContext from '../@glimmer/global-context/index.js';
import { isEmberArray } from '../@ember/array/-internals.js';

const RootTemplate = templateFactory(
/*
  {{component this}}
*/
{
  "id": "tjANIXCV",
  "block": "[[[46,[30,0],null,null,null]],[],false,[\"component\"]]",
  "moduleName": "packages/@ember/-internals/glimmer/lib/templates/root.hbs",
  "isStrictMode": true
});

// In normal TypeScript, this modifier is essentially an opaque token that just
// needs to be importable. Declaring it with a unique interface like this,
// however, gives tools like Glint (that *do* have a richer notion of what it
// is) a place to install more detailed type information.
// eslint-disable-next-line @typescript-eslint/no-empty-interface

// SAFETY: at the time of writing, the cast here is from `{}` to `OnModifier`,
// which makes it strictly safer to use outside this module because it is not
// usable as "any non-null item", which is what `{}` means, without loss of any
// information from the type itself.
const on = on$1;

// NOTE: this uses assignment to *require* that the `glimmerSetModifierManager`
// is legally assignable to this type, i.e. that variance is properly upheld.
const setModifierManager = setModifierManager$1;

const InputTemplate = templateFactory(
/*
  <input
  {{!-- for compatibility --}}
  id={{this.id}}
  class={{this.class}}

  ...attributes

  type={{this.type}}
  checked={{this.checked}}
  value={{this.value}}

  {{on "change" this.change}}
  {{on "input" this.input}}
  {{on "keyup" this.keyUp}}
  {{on "paste" this.valueDidChange}}
  {{on "cut" this.valueDidChange}}
/>
*/
{
  "id": "4z3DuGQ3",
  "block": "[[[11,\"input\"],[16,1,[30,0,[\"id\"]]],[16,0,[30,0,[\"class\"]]],[17,1],[16,4,[30,0,[\"type\"]]],[16,\"checked\",[30,0,[\"checked\"]]],[16,2,[30,0,[\"value\"]]],[4,[32,0],[\"change\",[30,0,[\"change\"]]],null],[4,[32,0],[\"input\",[30,0,[\"input\"]]],null],[4,[32,0],[\"keyup\",[30,0,[\"keyUp\"]]],null],[4,[32,0],[\"paste\",[30,0,[\"valueDidChange\"]]],null],[4,[32,0],[\"cut\",[30,0,[\"valueDidChange\"]]],null],[12],[13]],[\"&attrs\"],false,[]]",
  "moduleName": "packages/@ember/-internals/glimmer/lib/templates/input.hbs",
  "scope": () => [on],
  "isStrictMode": true
});

function NOOP$2() {}
class InternalComponent {
  // Override this
  static toString() {
    return 'internal component';
  }
  constructor(owner, args, caller) {
    this.owner = owner;
    this.args = args;
    this.caller = caller;
    setOwner(this, owner);
  }

  /**
   * The default HTML id attribute. We don't really _need_ one, this is just
   * added for compatibility as it's hard to tell if people rely on it being
   * present, and it doens't really hurt.
   *
   * However, don't rely on this internally, like passing it to `getElementId`.
   * This can be (and often is) overriden by passing an `id` attribute on the
   * invocation, which shadows this default id via `...attributes`.
   */
  get id() {
    return guidFor(this);
  }

  /**
   * The default HTML class attribute. Similar to the above, we don't _need_
   * them, they are just added for compatibility as it's similarly hard to tell
   * if people rely on it in their CSS etc, and it doens't really hurt.
   */
  get class() {
    return 'ember-view';
  }
  validateArguments() {
    for (let name of Object.keys(this.args.named)) {
      if (!this.isSupportedArgument(name)) {
        this.onUnsupportedArgument(name);
      }
    }
  }
  named(name) {
    let ref = this.args.named[name];
    return ref ? valueForRef(ref) : undefined;
  }
  positional(index) {
    let ref = this.args.positional[index];
    return ref ? valueForRef(ref) : undefined;
  }
  listenerFor(name) {
    let listener = this.named(name);
    if (listener) {
      (isDevelopingApp() && !(typeof listener === 'function') && assert(`The \`@${name}\` argument to the <${this.constructor}> component must be a function`, typeof listener === 'function'));
      return listener;
    } else {
      return NOOP$2;
    }
  }
  isSupportedArgument(_name) {
    return false;
  }
  onUnsupportedArgument(_name) {}
  toString() {
    return `<${this.constructor}:${guidFor(this)}>`;
  }
}
const OPAQUE_CONSTRUCTOR_MAP = new WeakMap();
function opaquify(constructor, template) {
  let _opaque = {
    // Factory interface
    create() {
      throw assert('Use constructor instead of create');
    },
    toString() {
      return constructor.toString();
    }
  };
  let opaque = _opaque;
  OPAQUE_CONSTRUCTOR_MAP.set(opaque, constructor);
  setInternalComponentManager(INTERNAL_COMPONENT_MANAGER, opaque);
  setComponentTemplate(template, opaque);
  return opaque;
}
function deopaquify(opaque) {
  let constructor = OPAQUE_CONSTRUCTOR_MAP.get(opaque);
  (isDevelopingApp() && !(constructor) && assert(`[BUG] Invalid internal component constructor: ${opaque}`, constructor));
  return constructor;
}
const CAPABILITIES$2 = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: true,
  dynamicScope: false,
  updateHook: false,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
class InternalManager {
  getCapabilities() {
    return CAPABILITIES$2;
  }
  create(owner, definition, args, _env, _dynamicScope, caller) {
    (isDevelopingApp() && !(isConstRef(caller)) && assert('caller must be const', isConstRef(caller)));
    let ComponentClass = deopaquify(definition);
    let instance = new ComponentClass(owner, args.capture(), valueForRef(caller));
    untrack(instance['validateArguments'].bind(instance));
    return instance;
  }
  didCreate() {}
  didUpdate() {}
  didRenderLayout() {}
  didUpdateLayout() {}
  getDebugName(definition) {
    return definition.toString();
  }
  getSelf(instance) {
    return createConstRef(instance, 'this');
  }
  getDestroyable(instance) {
    return instance;
  }
}
const INTERNAL_COMPONENT_MANAGER = new InternalManager();

const UNINITIALIZED = Object.freeze({});
function elementForEvent(event) {
  (isDevelopingApp() && !(event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) && assert('[BUG] event target must be an <input> or <textarea> element', event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement));
  return event.target;
}
function valueForEvent(event) {
  return elementForEvent(event).value;
}
function devirtualize(callback) {
  return event => callback(valueForEvent(event), event);
}
function valueFrom(reference) {
  if (reference === undefined) {
    return new LocalValue(undefined);
  } else if (isConstRef(reference)) {
    return new LocalValue(valueForRef(reference));
  } else if (isUpdatableRef(reference)) {
    return new UpstreamValue(reference);
  } else {
    return new ForkedValue(reference);
  }
}
class LocalValue {
  static {
    decorateFieldV2(this.prototype, "value", [tracked]);
  }
  #value = (initializeDeferredDecorator(this, "value"), void 0);
  constructor(value) {
    this.value = value;
  }
  get() {
    return this.value;
  }
  set(value) {
    this.value = value;
  }
}
class UpstreamValue {
  constructor(reference) {
    this.reference = reference;
  }
  get() {
    return valueForRef(this.reference);
  }
  set(value) {
    updateRef(this.reference, value);
  }
}
class ForkedValue {
  local;
  upstream;
  lastUpstreamValue = UNINITIALIZED;
  constructor(reference) {
    this.upstream = new UpstreamValue(reference);
  }
  get() {
    let upstreamValue = this.upstream.get();
    if (upstreamValue !== this.lastUpstreamValue) {
      this.lastUpstreamValue = upstreamValue;
      this.local = new LocalValue(upstreamValue);
    }
    (isDevelopingApp() && !(this.local) && assert('[BUG] this.local must have been initialized at this point', this.local));
    return this.local.get();
  }
  set(value) {
    (isDevelopingApp() && !(this.local) && assert('[BUG] this.local must have been initialized at this point', this.local));
    this.local.set(value);
  }
}
class AbstractInput extends InternalComponent {
  validateArguments() {
    (isDevelopingApp() && !(this.args.positional.length === 0) && assert(`The ${this.constructor} component does not take any positional arguments`, this.args.positional.length === 0));
    super.validateArguments();
  }
  _value = valueFrom(this.args.named['value']);
  get value() {
    return this._value.get();
  }
  set value(value) {
    this._value.set(value);
  }
  valueDidChange(event) {
    this.value = valueForEvent(event);
  }

  /**
   * The `change` and `input` actions need to be overridden in the `Input`
   * subclass. Unfortunately, some ember-source builds currently uses babel
   * loose mode to transpile its classes. Having the `@action` decorator on the
   * super class creates a getter on the prototype, and when the subclass
   * overrides the method, the loose mode transpilation would emit something
   * like `Subclass.prototype['change'] = function change() { ... }`, which
   * fails because `prototype['change']` is getter-only/readonly. The correct
   * solution is to use `Object.defineProperty(prototype, 'change', ...)` but
   * that requires disabling loose mode. For now, the workaround is to add the
   * decorator only on the subclass. This is more of a configuration issue on
   * our own builds and doesn't really affect apps.
   */

  /* @action */
  static {
    decorateMethodV2(this.prototype, "valueDidChange", [action$1]);
  }
  change(event) {
    this.valueDidChange(event);
  }

  /* @action */
  input(event) {
    this.valueDidChange(event);
  }
  keyUp(event) {
    switch (event.key) {
      case 'Enter':
        this.listenerFor('enter')(event);
        this.listenerFor('insert-newline')(event);
        break;
      case 'Escape':
        this.listenerFor('escape-press')(event);
        break;
    }
  }
  static {
    decorateMethodV2(this.prototype, "keyUp", [action$1]);
  }
  listenerFor(name) {
    let listener = super.listenerFor(name);
    if (this.isVirtualEventListener(name, listener)) {
      return devirtualize(listener);
    } else {
      return listener;
    }
  }
  isVirtualEventListener(name, _listener) {
    let virtualEvents = ['enter', 'insert-newline', 'escape-press'];
    return virtualEvents.indexOf(name) !== -1;
  }
}

/**
@module @ember/component
*/
let isValidInputType;
if (hasDOM) {
  const INPUT_TYPES = Object.create(null);
  const INPUT_ELEMENT = document.createElement('input');
  INPUT_TYPES[''] = false;
  INPUT_TYPES['text'] = true;
  INPUT_TYPES['checkbox'] = true;
  isValidInputType = type => {
    let isValid = INPUT_TYPES[type];
    if (isValid === undefined) {
      try {
        INPUT_ELEMENT.type = type;
        isValid = INPUT_ELEMENT.type === type;
      } catch (_e) {
        isValid = false;
      } finally {
        INPUT_ELEMENT.type = 'text';
      }
      INPUT_TYPES[type] = isValid;
    }
    return isValid;
  };
} else {
  isValidInputType = type => type !== '';
}

/**
  See [Ember.Templates.components.Input](/ember/release/classes/Ember.Templates.components/methods/Input?anchor=Input).

  @method input
  @for Ember.Templates.helpers
  @param {Hash} options
  @public
  */

/**
  An opaque interface which can be imported and used in strict-mode
  templates to call <Input>.

  See [Ember.Templates.components.Input](/ember/release/classes/Ember.Templates.components/methods/Input?anchor=Input).

  @for @ember/component
  @method Input
  @see {Ember.Templates.components.Input}
  @public
**/

/**
  The `Input` component lets you create an HTML `<input>` element.

  ```handlebars
  <Input @value="987" />
  ```

  creates an `<input>` element with `type="text"` and value set to 987.

  ### Text field

  If no `type` argument is specified, a default of type 'text' is used.

  ```handlebars
  Search:
  <Input @value={{this.searchWord}} />
  ```

  In this example, the initial value in the `<input>` will be set to the value of
  `this.searchWord`. If the user changes the text, the value of `this.searchWord` will also be
  updated.

  ### Actions

  The `Input` component takes a number of arguments with callbacks that are invoked in response to
  user events.

  * `enter`
  * `insert-newline`
  * `escape-press`
  * `focus-in`
  * `focus-out`
  * `key-down`
  * `key-press`
  * `key-up`

  These callbacks are passed to `Input` like this:

  ```handlebars
  <Input @value={{this.searchWord}} @enter={{this.query}} />
  ```

  Starting with Ember Octane, we recommend using the `{{on}}` modifier to call actions
  on specific events, such as the input event.

  ```handlebars
  <label for="input-name">Name:</label>
  <Input
    @id="input-name"
    @value={{this.name}}
    {{on "input" this.validateName}}
  />
  ```

  The event name (e.g. `focusout`, `input`, `keydown`) always follows the casing
  that the HTML standard uses.

  ### `<input>` HTML Attributes to Avoid

  In most cases, if you want to pass an attribute to the underlying HTML `<input>` element, you
  can pass the attribute directly, just like any other Ember component.

  ```handlebars
  <Input @type="text" size="10" />
  ```

  In this example, the `size` attribute will be applied to the underlying `<input>` element in the
  outputted HTML.

  However, there are a few attributes where you **must** use the `@` version.

  * `@type`: This argument is used to control which Ember component is used under the hood
  * `@value`: The `@value` argument installs a two-way binding onto the element. If you wanted a
    one-way binding, use `<input>` with the `value` property and the `input` event instead.
  * `@checked` (for checkboxes): like `@value`, the `@checked` argument installs a two-way binding
    onto the element. If you wanted a one-way binding, use `<input type="checkbox">` with
    `checked` and the `input` event instead.

  ### Checkbox

  To create an `<input type="checkbox">`:

  ```handlebars
  Emberize Everything:
  <Input @type="checkbox" @checked={{this.isEmberized}} name="isEmberized" />
  ```

  This will bind the checked state of this checkbox to the value of `isEmberized` -- if either one
  changes, it will be reflected in the other.

  @method Input
  @for Ember.Templates.components
  @param {Hash} options
  @public
*/
class _Input extends AbstractInput {
  static toString() {
    return 'Input';
  }

  /**
   * The HTML class attribute.
   */
  get class() {
    if (this.isCheckbox) {
      return 'ember-checkbox ember-view';
    } else {
      return 'ember-text-field ember-view';
    }
  }

  /**
   * The HTML type attribute.
   */
  get type() {
    let type = this.named('type');
    if (type === null || type === undefined) {
      return 'text';
    }
    (isDevelopingApp() && !(typeof type === 'string') && assert('The `@type` argument to the <Input> component must be a string', typeof type === 'string'));
    return isValidInputType(type) ? type : 'text';
  }
  get isCheckbox() {
    return this.named('type') === 'checkbox';
  }
  _checked = valueFrom(this.args.named['checked']);
  get checked() {
    if (this.isCheckbox) {
      (isDevelopingApp() && warn('`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. ' + 'You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. ' + 'Did you mean `<Input @type="checkbox" @checked={{...}} />`?', untrack(() => this.args.named['checked'] !== undefined || this.args.named['value'] === undefined || typeof valueForRef(this.args.named['value']) === 'string'), {
        id: 'ember.built-in-components.input-checkbox-value'
      }));
      return this._checked.get();
    } else {
      return undefined;
    }
  }
  set checked(checked) {
    (isDevelopingApp() && warn('`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. ' + 'You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. ' + 'Did you mean `<Input @type="checkbox" @checked={{...}} />`?', untrack(() => this.args.named['checked'] !== undefined || this.args.named['value'] === undefined || typeof valueForRef(this.args.named['value']) === 'string'), {
      id: 'ember.built-in-components.input-checkbox-value'
    }));
    this._checked.set(checked);
  }
  change(event) {
    if (this.isCheckbox) {
      this.checkedDidChange(event);
    } else {
      super.change(event);
    }
  }
  static {
    decorateMethodV2(this.prototype, "change", [action$1]);
  }
  input(event) {
    if (!this.isCheckbox) {
      super.input(event);
    }
  }
  static {
    decorateMethodV2(this.prototype, "input", [action$1]);
  }
  checkedDidChange(event) {
    let element = event.target;
    (isDevelopingApp() && !(element instanceof HTMLInputElement) && assert('[BUG] element must be an <input>', element instanceof HTMLInputElement));
    this.checked = element.checked;
  }
  static {
    decorateMethodV2(this.prototype, "checkedDidChange", [action$1]);
  }
  isSupportedArgument(name) {
    let supportedArguments = ['type', 'value', 'checked', 'enter', 'insert-newline', 'escape-press'];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
}
const Input = opaquify(_Input, InputTemplate);

const LinkToTemplate = templateFactory(
/*
  <a
  {{!-- for compatibility --}}
  id={{this.id}}
  class={{this.class}}

  {{!-- deprecated attribute bindings --}}
  role={{this.role}}
  title={{this.title}}
  rel={{this.rel}}
  tabindex={{this.tabindex}}
  target={{this.target}}

  ...attributes

  href={{this.href}}

  {{on 'click' this.click}}
>{{yield}}</a>
*/
{
  "id": "Ub0nir+H",
  "block": "[[[11,3],[16,1,[30,0,[\"id\"]]],[16,0,[30,0,[\"class\"]]],[16,\"role\",[30,0,[\"role\"]]],[16,\"title\",[30,0,[\"title\"]]],[16,\"rel\",[30,0,[\"rel\"]]],[16,\"tabindex\",[30,0,[\"tabindex\"]]],[16,\"target\",[30,0,[\"target\"]]],[17,1],[16,6,[30,0,[\"href\"]]],[4,[32,0],[\"click\",[30,0,[\"click\"]]],null],[12],[18,2,null],[13]],[\"&attrs\",\"&default\"],false,[\"yield\"]]",
  "moduleName": "packages/@ember/-internals/glimmer/lib/templates/link-to.hbs",
  "scope": () => [on],
  "isStrictMode": true
});

const EMPTY_ARRAY = [];
const EMPTY_QUERY_PARAMS = {};
debugFreeze(EMPTY_ARRAY);
debugFreeze(EMPTY_QUERY_PARAMS);
function isMissing(value) {
  return value === null || value === undefined;
}
function isPresent(value) {
  return !isMissing(value);
}
function isQueryParams(value) {
  return typeof value === 'object' && value !== null && value['isQueryParams'] === true;
}

/**
  The `LinkTo` component renders a link to the supplied `routeName` passing an optionally
  supplied model to the route as its `model` context of the route. The block for `LinkTo`
  becomes the contents of the rendered element:

  ```handlebars
  <LinkTo @route='photoGallery'>
    Great Hamster Photos
  </LinkTo>
  ```

  This will result in:

  ```html
  <a href="/hamster-photos">
    Great Hamster Photos
  </a>
  ```

  ### Disabling the `LinkTo` component

  The `LinkTo` component can be disabled by using the `disabled` argument. A disabled link
  doesn't result in a transition when activated, and adds the `disabled` class to the `<a>`
  element.

  (The class name to apply to the element can be overridden by using the `disabledClass`
  argument)

  ```handlebars
  <LinkTo @route='photoGallery' @disabled={{true}}>
    Great Hamster Photos
  </LinkTo>
  ```

  ### Handling `href`

  `<LinkTo>` will use your application's Router to fill the element's `href` property with a URL
  that matches the path to the supplied `routeName`.

  ### Handling current route

  The `LinkTo` component will apply a CSS class name of 'active' when the application's current
  route matches the supplied routeName. For example, if the application's current route is
  'photoGallery.recent', then the following invocation of `LinkTo`:

  ```handlebars
  <LinkTo @route='photoGallery.recent'>
    Great Hamster Photos
  </LinkTo>
  ```

  will result in

  ```html
  <a href="/hamster-photos/this-week" class="active">
    Great Hamster Photos
  </a>
  ```

  The CSS class used for active classes can be customized by passing an `activeClass` argument:

  ```handlebars
  <LinkTo @route='photoGallery.recent' @activeClass="current-url">
    Great Hamster Photos
  </LinkTo>
  ```

  ```html
  <a href="/hamster-photos/this-week" class="current-url">
    Great Hamster Photos
  </a>
  ```

  ### Keeping a link active for other routes

  If you need a link to be 'active' even when it doesn't match the current route, you can use the
  `current-when` argument.

  ```handlebars
  <LinkTo @route='photoGallery' @current-when='photos'>
    Photo Gallery
  </LinkTo>
  ```

  This may be helpful for keeping links active for:

  * non-nested routes that are logically related
  * some secondary menu approaches
  * 'top navigation' with 'sub navigation' scenarios

  A link will be active if `current-when` is `true` or the current
  route is the route this link would transition to.

  To match multiple routes 'space-separate' the routes:

  ```handlebars
  <LinkTo @route='gallery' @current-when='photos drawings paintings'>
    Art Gallery
  </LinkTo>
  ```

  ### Supplying a model

  An optional `model` argument can be used for routes whose
  paths contain dynamic segments. This argument will become
  the model context of the linked route:

  ```javascript
  Router.map(function() {
    this.route("photoGallery", {path: "hamster-photos/:photo_id"});
  });
  ```

  ```handlebars
  <LinkTo @route='photoGallery' @model={{this.aPhoto}}>
    {{aPhoto.title}}
  </LinkTo>
  ```

  ```html
  <a href="/hamster-photos/42">
    Tomster
  </a>
  ```

  ### Supplying multiple models

  For deep-linking to route paths that contain multiple
  dynamic segments, the `models` argument can be used.

  As the router transitions through the route path, each
  supplied model argument will become the context for the
  route with the dynamic segments:

  ```javascript
  Router.map(function() {
    this.route("photoGallery", { path: "hamster-photos/:photo_id" }, function() {
      this.route("comment", {path: "comments/:comment_id"});
    });
  });
  ```

  This argument will become the model context of the linked route:

  ```handlebars
  <LinkTo @route='photoGallery.comment' @models={{array this.aPhoto this.comment}}>
    {{comment.body}}
  </LinkTo>
  ```

  ```html
  <a href="/hamster-photos/42/comments/718">
    A+++ would snuggle again.
  </a>
  ```

  ### Supplying an explicit dynamic segment value

  If you don't have a model object available to pass to `LinkTo`,
  an optional string or integer argument can be passed for routes whose
  paths contain dynamic segments. This argument will become the value
  of the dynamic segment:

  ```javascript
  Router.map(function() {
    this.route("photoGallery", { path: "hamster-photos/:photo_id" });
  });
  ```

  ```handlebars
  <LinkTo @route='photoGallery' @model={{aPhotoId}}>
    {{this.aPhoto.title}}
  </LinkTo>
  ```

  ```html
  <a href="/hamster-photos/42">
    Tomster
  </a>
  ```

  When transitioning into the linked route, the `model` hook will
  be triggered with parameters including this passed identifier.

  ### Supplying query parameters

  If you need to add optional key-value pairs that appear to the right of the ? in a URL,
  you can use the `query` argument.

  ```handlebars
  <LinkTo @route='photoGallery' @query={{hash page=1 per_page=20}}>
    Great Hamster Photos
  </LinkTo>
  ```

  This will result in:

  ```html
  <a href="/hamster-photos?page=1&per_page=20">
    Great Hamster Photos
  </a>
  ```

  @for Ember.Templates.components
  @method LinkTo
  @public
*/

/**
  @module @ember/routing
*/

/**
  See [Ember.Templates.components.LinkTo](/ember/release/classes/Ember.Templates.components/methods/input?anchor=LinkTo).

  @for Ember.Templates.helpers
  @method link-to
  @see {Ember.Templates.components.LinkTo}
  @public
**/

/**
  An opaque interface which can be imported and used in strict-mode
  templates to call <LinkTo>.

  See [Ember.Templates.components.LinkTo](/ember/release/classes/Ember.Templates.components/methods/input?anchor=LinkTo).

  @for @ember/routing
  @method LinkTo
  @see {Ember.Templates.components.LinkTo}
  @public
**/

class _LinkTo extends InternalComponent {
  static toString() {
    return 'LinkTo';
  }
  static {
    decorateFieldV2(this.prototype, "routing", [service('-routing')]);
  }
  #routing = (initializeDeferredDecorator(this, "routing"), void 0);
  validateArguments() {
    (isDevelopingApp() && !(!this.isEngine || this.engineMountPoint !== undefined) && assert('You attempted to use the <LinkTo> component within a routeless engine, this is not supported. ' + 'If you are using the ember-engines addon, use the <LinkToExternal> component instead. ' + 'See https://ember-engines.com/docs/links for more info.', !this.isEngine || this.engineMountPoint !== undefined));
    (isDevelopingApp() && !('route' in this.args.named || 'model' in this.args.named || 'models' in this.args.named || 'query' in this.args.named) && assert('You must provide at least one of the `@route`, `@model`, `@models` or `@query` arguments to `<LinkTo>`.', 'route' in this.args.named || 'model' in this.args.named || 'models' in this.args.named || 'query' in this.args.named));
    (isDevelopingApp() && !(!('model' in this.args.named && 'models' in this.args.named)) && assert('You cannot provide both the `@model` and `@models` arguments to the <LinkTo> component.', !('model' in this.args.named && 'models' in this.args.named)));
    super.validateArguments();
  }
  get class() {
    let classes = 'ember-view';
    if (this.isActive) {
      classes += this.classFor('active');
      if (this.willBeActive === false) {
        classes += ' ember-transitioning-out';
      }
    } else if (this.willBeActive) {
      classes += ' ember-transitioning-in';
    }
    if (this.isLoading) {
      classes += this.classFor('loading');
    }
    if (this.isDisabled) {
      classes += this.classFor('disabled');
    }
    return classes;
  }
  get href() {
    if (this.isLoading) {
      return '#';
    }
    let {
      routing,
      route,
      models,
      query
    } = this;
    (isDevelopingApp() && !(isPresent(route)) && assert('[BUG] route can only be missing if isLoading is true', isPresent(route))); // consume the current router state so we invalidate when QP changes
    // TODO: can we narrow this down to QP changes only?
    consumeTag(tagFor(routing, 'currentState'));
    if (isDevelopingApp()) {
      try {
        return routing.generateURL(route, models, query);
      } catch (e) {
        let details = e instanceof Error ? e.message : inspect(e);
        let message = `While generating link to route "${route}": ${details}`;
        if (e instanceof Error) {
          e.message = message;
          throw e;
        } else {
          throw message;
        }
      }
    } else {
      return routing.generateURL(route, models, query);
    }
  }
  click(event) {
    if (!isSimpleClick(event)) {
      return;
    }
    let element = event.currentTarget;
    (isDevelopingApp() && !(element instanceof HTMLAnchorElement) && assert('[BUG] must be an <a> element', element instanceof HTMLAnchorElement));
    let isSelf = element.target === '' || element.target === '_self';
    if (isSelf) {
      this.preventDefault(event);
    } else {
      return;
    }
    if (this.isDisabled) {
      return;
    }
    if (this.isLoading) {
      (isDevelopingApp() && warn('This link is in an inactive loading state because at least one of its models ' + 'currently has a null/undefined value, or the provided route name is invalid.', false, {
        id: 'ember-glimmer.link-to.inactive-loading-state'
      }));
      return;
    }
    let {
      routing,
      route,
      models,
      query,
      replace
    } = this;
    let payload = {
      routeName: route,
      queryParams: query,
      transition: undefined
    };
    flaggedInstrument('interaction.link-to', payload, () => {
      (isDevelopingApp() && !(isPresent(route)) && assert('[BUG] route can only be missing if isLoading is true', isPresent(route)));
      payload.transition = routing.transitionTo(route, models, query, replace);
    });
  }
  static {
    decorateMethodV2(this.prototype, "click", [action$1]);
  }
  get route() {
    if ('route' in this.args.named) {
      let route = this.named('route');
      (isDevelopingApp() && !(isMissing(route) || typeof route === 'string') && assert('The `@route` argument to the <LinkTo> component must be a string', isMissing(route) || typeof route === 'string'));
      return route && this.namespaceRoute(route);
    } else {
      return this.currentRoute;
    }
  }

  // GH #17963
  currentRouteCache = createCache(() => {
    consumeTag(tagFor(this.routing, 'currentState'));
    return untrack(() => this.routing.currentRouteName);
  });
  get currentRoute() {
    return getValue(this.currentRouteCache);
  }

  // TODO: not sure why generateURL takes {}[] instead of unknown[]
  get models() {
    if ('models' in this.args.named) {
      let models = this.named('models');
      (isDevelopingApp() && !(Array.isArray(models)) && assert('The `@models` argument to the <LinkTo> component must be an array.', Array.isArray(models)));
      return models;
    } else if ('model' in this.args.named) {
      return [this.named('model')];
    } else {
      return EMPTY_ARRAY;
    }
  }
  get query() {
    if ('query' in this.args.named) {
      let query = this.named('query');
      (isDevelopingApp() && !(query !== null && typeof query === 'object') && assert('The `@query` argument to the <LinkTo> component must be an object.', query !== null && typeof query === 'object'));
      return {
        ...query
      };
    } else {
      return EMPTY_QUERY_PARAMS;
    }
  }
  get replace() {
    return this.named('replace') === true;
  }
  get isActive() {
    return this.isActiveForState(this.routing.currentState);
  }
  get willBeActive() {
    let current = this.routing.currentState;
    let target = this.routing.targetState;
    if (current === target) {
      return null;
    } else {
      return this.isActiveForState(target);
    }
  }
  get isLoading() {
    return isMissing(this.route) || this.models.some(model => isMissing(model));
  }
  get isDisabled() {
    return Boolean(this.named('disabled'));
  }
  get isEngine() {
    let owner = this.owner;
    return owner instanceof EmberEngineInstance && getEngineParent(owner) !== undefined;
  }
  get engineMountPoint() {
    let owner = this.owner;
    return owner instanceof EmberEngineInstance ? owner.mountPoint : undefined;
  }
  classFor(state) {
    let className = this.named(`${state}Class`);
    (isDevelopingApp() && !(isMissing(className) || typeof className === 'string' || typeof className === 'boolean') && assert(`The \`@${state}Class\` argument to the <LinkTo> component must be a string or boolean`, isMissing(className) || typeof className === 'string' || typeof className === 'boolean'));
    if (className === true || isMissing(className)) {
      return ` ${state}`;
    } else if (className) {
      return ` ${className}`;
    } else {
      return '';
    }
  }
  namespaceRoute(route) {
    let {
      engineMountPoint
    } = this;
    if (engineMountPoint === undefined) {
      return route;
    } else if (route === 'application') {
      return engineMountPoint;
    } else {
      return `${engineMountPoint}.${route}`;
    }
  }
  isActiveForState(state) {
    if (!isPresent(state)) {
      return false;
    }
    if (this.isLoading) {
      return false;
    }
    let currentWhen = this.named('current-when');
    if (typeof currentWhen === 'boolean') {
      return currentWhen;
    } else if (typeof currentWhen === 'string') {
      let {
        models,
        routing
      } = this;
      return currentWhen.split(' ').some(route => routing.isActiveForRoute(models, undefined, this.namespaceRoute(route), state));
    } else {
      let {
        route,
        models,
        query,
        routing
      } = this;
      (isDevelopingApp() && !(isPresent(route)) && assert('[BUG] route can only be missing if isLoading is true', isPresent(route)));
      return routing.isActiveForRoute(models, query, route, state);
    }
  }
  preventDefault(event) {
    event.preventDefault();
  }
  isSupportedArgument(name) {
    let supportedArguments = ['route', 'model', 'models', 'query', 'replace', 'disabled', 'current-when', 'activeClass', 'loadingClass', 'disabledClass'];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
}
let {
  prototype
} = _LinkTo;
let descriptorFor = (target, property) => {
  if (target) {
    return Object.getOwnPropertyDescriptor(target, property) || descriptorFor(Object.getPrototypeOf(target), property);
  } else {
    return null;
  }
};

// @href
{
  let superOnUnsupportedArgument = prototype['onUnsupportedArgument'];
  Object.defineProperty(prototype, 'onUnsupportedArgument', {
    configurable: true,
    enumerable: false,
    value: function onUnsupportedArgument(name) {
      if (name === 'href') {
        (isDevelopingApp() && !(false) && assert(`Passing the \`@href\` argument to <LinkTo> is not supported.`));
      } else {
        superOnUnsupportedArgument.call(this, name);
      }
    }
  });
}

// QP
{
  let superModelsDescriptor = descriptorFor(prototype, 'models');
  (isDevelopingApp() && !(superModelsDescriptor && typeof superModelsDescriptor.get === 'function') && assert(`[BUG] expecting models to be a getter on <LinkTo>`, superModelsDescriptor && typeof superModelsDescriptor.get === 'function'));
  let superModelsGetter = superModelsDescriptor.get;
  Object.defineProperty(prototype, 'models', {
    configurable: true,
    enumerable: false,
    get: function models() {
      let models = superModelsGetter.call(this);
      if (models.length > 0 && !('query' in this.args.named)) {
        if (isQueryParams(models[models.length - 1])) {
          models = models.slice(0, -1);
        }
      }
      return models;
    }
  });
  let superQueryDescriptor = descriptorFor(prototype, 'query');
  (isDevelopingApp() && !(superQueryDescriptor && typeof superQueryDescriptor.get === 'function') && assert(`[BUG] expecting query to be a getter on <LinkTo>`, superQueryDescriptor && typeof superQueryDescriptor.get === 'function'));
  let superQueryGetter = superQueryDescriptor.get;
  Object.defineProperty(prototype, 'query', {
    configurable: true,
    enumerable: false,
    get: function query() {
      if ('query' in this.args.named) {
        let qp = superQueryGetter.call(this);
        if (isQueryParams(qp)) {
          return qp.values ?? EMPTY_QUERY_PARAMS;
        } else {
          return qp;
        }
      } else {
        let models = superModelsGetter.call(this);
        if (models.length > 0) {
          let qp = models[models.length - 1];
          if (isQueryParams(qp) && qp.values !== null) {
            return qp.values;
          }
        }
        return EMPTY_QUERY_PARAMS;
      }
    }
  });
}

// Positional Arguments
{
  let superOnUnsupportedArgument = prototype['onUnsupportedArgument'];
  Object.defineProperty(prototype, 'onUnsupportedArgument', {
    configurable: true,
    enumerable: false,
    value: function onUnsupportedArgument(name) {
      if (name !== 'params') {
        superOnUnsupportedArgument.call(this, name);
      }
    }
  });
}
const LinkTo = opaquify(_LinkTo, LinkToTemplate);

const TextareaTemplate = templateFactory(
/*
  <textarea
  {{!-- for compatibility --}}
  id={{this.id}}
  class={{this.class}}

  ...attributes

  value={{this.value}}

  {{on "change" this.change}}
  {{on "input" this.input}}
  {{on "keyup" this.keyUp}}
  {{on "paste" this.valueDidChange}}
  {{on "cut" this.valueDidChange}}
/>
*/
{
  "id": "112WKCh2",
  "block": "[[[11,\"textarea\"],[16,1,[30,0,[\"id\"]]],[16,0,[30,0,[\"class\"]]],[17,1],[16,2,[30,0,[\"value\"]]],[4,[32,0],[\"change\",[30,0,[\"change\"]]],null],[4,[32,0],[\"input\",[30,0,[\"input\"]]],null],[4,[32,0],[\"keyup\",[30,0,[\"keyUp\"]]],null],[4,[32,0],[\"paste\",[30,0,[\"valueDidChange\"]]],null],[4,[32,0],[\"cut\",[30,0,[\"valueDidChange\"]]],null],[12],[13]],[\"&attrs\"],false,[]]",
  "moduleName": "packages/@ember/-internals/glimmer/lib/templates/textarea.hbs",
  "scope": () => [on],
  "isStrictMode": true
});

/**
@module @ember/component
*/

class _Textarea extends AbstractInput {
  static toString() {
    return 'Textarea';
  }
  get class() {
    return 'ember-text-area ember-view';
  }

  // See abstract-input.ts for why these are needed

  change(event) {
    super.change(event);
  }
  static {
    decorateMethodV2(this.prototype, "change", [action$1]);
  }
  input(event) {
    super.input(event);
  }
  static {
    decorateMethodV2(this.prototype, "input", [action$1]);
  }
  isSupportedArgument(name) {
    let supportedArguments = ['type', 'value', 'enter', 'insert-newline', 'escape-press'];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
}
const Textarea = opaquify(_Textarea, TextareaTemplate);

function isTemplateFactory(template) {
  return typeof template === 'function';
}

function referenceForParts(rootRef, parts) {
  let isAttrs = parts[0] === 'attrs';

  // TODO deprecate this
  if (isAttrs) {
    parts.shift();
    if (parts.length === 1) {
      return childRefFor(rootRef, parts[0]);
    }
  }
  return childRefFromParts(rootRef, parts);
}
function parseAttributeBinding(microsyntax) {
  let colonIndex = microsyntax.indexOf(':');
  if (colonIndex === -1) {
    (isDevelopingApp() && !(microsyntax !== 'class') && assert('You cannot use class as an attributeBinding, use classNameBindings instead.', microsyntax !== 'class'));
    return [microsyntax, microsyntax, true];
  } else {
    let prop = microsyntax.substring(0, colonIndex);
    let attribute = microsyntax.substring(colonIndex + 1);
    (isDevelopingApp() && !(attribute !== 'class') && assert('You cannot use class as an attributeBinding, use classNameBindings instead.', attribute !== 'class'));
    return [prop, attribute, false];
  }
}
function installAttributeBinding(component, rootRef, parsed, operations) {
  let [prop, attribute, isSimple] = parsed;
  if (attribute === 'id') {
    // SAFETY: `get` could not infer the type of `prop` and just gave us `unknown`.
    //         we may want to throw an error in the future if the value isn't string or null/undefined.
    let elementId = get(component, prop);
    if (elementId === undefined || elementId === null) {
      elementId = component.elementId;
    }
    let elementIdRef = createPrimitiveRef(elementId);
    operations.setAttribute('id', elementIdRef, true, null);
    return;
  }
  let isPath = prop.indexOf('.') > -1;
  let reference = isPath ? referenceForParts(rootRef, prop.split('.')) : childRefFor(rootRef, prop);
  (isDevelopingApp() && !(!(isSimple && isPath)) && assert(`Illegal attributeBinding: '${prop}' is not a valid attribute name.`, !(isSimple && isPath)));
  operations.setAttribute(attribute, reference, false, null);
}
function createClassNameBindingRef(rootRef, microsyntax, operations) {
  let parts = microsyntax.split(':');
  let [prop, truthy, falsy] = parts;
  // NOTE: This could be an empty string
  (isDevelopingApp() && !(prop !== undefined) && assert('has prop', prop !== undefined)); // Will always have at least one part
  let isStatic = prop === '';
  if (isStatic) {
    operations.setAttribute('class', createPrimitiveRef(truthy), true, null);
  } else {
    let isPath = prop.indexOf('.') > -1;
    let parts = isPath ? prop.split('.') : [];
    let value = isPath ? referenceForParts(rootRef, parts) : childRefFor(rootRef, prop);
    let ref;
    if (truthy === undefined) {
      ref = createSimpleClassNameBindingRef(value, isPath ? parts[parts.length - 1] : prop);
    } else {
      ref = createColonClassNameBindingRef(value, truthy, falsy);
    }
    operations.setAttribute('class', ref, false, null);
  }
}
function createSimpleClassNameBindingRef(inner, path) {
  let dasherizedPath;
  return createComputeRef(() => {
    let value = valueForRef(inner);
    if (value === true) {
      (isDevelopingApp() && !(path !== undefined) && assert('You must pass a path when binding a to a class name using classNameBindings', path !== undefined));
      return dasherizedPath || (dasherizedPath = dasherize(path));
    } else if (value || value === 0) {
      return String(value);
    } else {
      return null;
    }
  });
}
function createColonClassNameBindingRef(inner, truthy, falsy) {
  return createComputeRef(() => {
    return valueForRef(inner) ? truthy : falsy;
  });
}

function NOOP$1() {}

/**
  @module ember
*/

/**
  Represents the internal state of the component.

  @class ComponentStateBucket
  @private
*/
class ComponentStateBucket {
  classRef = null;
  rootRef;
  argsRevision;
  constructor(component, args, argsTag, finalizer, hasWrappedElement, isInteractive) {
    this.component = component;
    this.args = args;
    this.argsTag = argsTag;
    this.finalizer = finalizer;
    this.hasWrappedElement = hasWrappedElement;
    this.isInteractive = isInteractive;
    this.classRef = null;
    this.argsRevision = args === null ? 0 : valueForTag(argsTag);
    this.rootRef = createConstRef(component, 'this');
    registerDestructor(this, () => this.willDestroy(), true);
    registerDestructor(this, () => this.component.destroy());
  }
  willDestroy() {
    let {
      component,
      isInteractive
    } = this;
    if (isInteractive) {
      beginUntrackFrame();
      component.trigger('willDestroyElement');
      component.trigger('willClearRender');
      endUntrackFrame();
      let element = getViewElement(component);
      if (element) {
        clearElementView(element);
        clearViewElement(component);
      }
    }
    component.renderer.unregister(component);
  }
  finalize() {
    let {
      finalizer
    } = this;
    finalizer();
    this.finalizer = NOOP$1;
  }
}

function internalHelper(helper) {
  return setInternalHelperManager(helper, {});
}

/**
@module ember
*/
const ACTIONS = new WeakSet();

/**
  The `{{action}}` helper provides a way to pass triggers for behavior (usually
  just a function) between components, and into components from controllers.

  ### Passing functions with the action helper

  There are three contexts an action helper can be used in. The first two
  contexts to discuss are attribute context, and Handlebars value context.

  ```handlebars
  {{! An example of attribute context }}
  <div onclick={{action "save"}}></div>
  {{! Examples of Handlebars value context }}
  {{input on-input=(action "save")}}
  {{yield (action "refreshData") andAnotherParam}}
  ```

  In these contexts,
  the helper is called a "closure action" helper. Its behavior is simple:
  If passed a function name, read that function off the `actions` property
  of the current context. Once that function is read, or immediately if a function was
  passed, create a closure over that function and any arguments.
  The resulting value of an action helper used this way is simply a function.

  For example, in the attribute context:

  ```handlebars
  {{! An example of attribute context }}
  <div onclick={{action "save"}}></div>
  ```

  The resulting template render logic would be:

  ```js
  var div = document.createElement('div');
  var actionFunction = (function(context){
    return function() {
      return context.actions.save.apply(context, arguments);
    };
  })(context);
  div.onclick = actionFunction;
  ```

  Thus when the div is clicked, the action on that context is called.
  Because the `actionFunction` is just a function, closure actions can be
  passed between components and still execute in the correct context.

  Here is an example action handler on a component:

  ```app/components/my-component.js
  import Component from '@glimmer/component';
  import { action } from '@ember/object';

  export default class extends Component {
    @action
    save() {
      this.model.save();
    }
  }
  ```

  Actions are always looked up on the `actions` property of the current context.
  This avoids collisions in the naming of common actions, such as `destroy`.
  Two options can be passed to the `action` helper when it is used in this way.

  * `target=someProperty` will look to `someProperty` instead of the current
    context for the `actions` hash. This can be useful when targeting a
    service for actions.
  * `value="target.value"` will read the path `target.value` off the first
    argument to the action when it is called and rewrite the first argument
    to be that value. This is useful when attaching actions to event listeners.

  ### Invoking an action

  Closure actions curry both their scope and any arguments. When invoked, any
  additional arguments are added to the already curried list.
  Actions are presented in JavaScript as callbacks, and are
  invoked like any other JavaScript function.

  For example

  ```app/components/update-name.js
  import Component from '@glimmer/component';
  import { action } from '@ember/object';

  export default class extends Component {
    @action
    setName(model, name) {
      model.set('name', name);
    }
  }
  ```

  ```app/components/update-name.hbs
  {{input on-input=(action (action 'setName' @model) value="target.value")}}
  ```

  The first argument (`@model`) was curried over, and the run-time argument (`event`)
  becomes a second argument. Action calls can be nested this way because each simply
  returns a function. Any function can be passed to the `{{action}}` helper, including
  other actions.

  Actions invoked with `sendAction` have the same currying behavior as demonstrated
  with `on-input` above. For example:

  ```app/components/my-input.js
  import Component from '@glimmer/component';
  import { action } from '@ember/object';

  export default class extends Component {
    @action
    setName(model, name) {
      model.set('name', name);
    }
  }
  ```

  ```handlebars
  <MyInput @submit={{action 'setName' @model}} />
  ```

  or

  ```handlebars
  {{my-input submit=(action 'setName' @model)}}
  ```

  ```app/components/my-component.js
  import Component from '@ember/component';

  export default Component.extend({
    click() {
      // Note that model is not passed, it was curried in the template
      this.submit('bob');
    }
  });
  ```

  ### Attaching actions to DOM elements

  The third context of the `{{action}}` helper can be called "element space".
  For example:

  ```handlebars
  {{! An example of element space }}
  <div {{action "save"}}></div>
  ```

  Used this way, the `{{action}}` helper provides a useful shortcut for
  registering an HTML element in a template for a single DOM event and
  forwarding that interaction to the template's context (controller or component).
  If the context of a template is a controller, actions used this way will
  bubble to routes when the controller does not implement the specified action.
  Once an action hits a route, it will bubble through the route hierarchy.

  ### Event Propagation

  `{{action}}` helpers called in element space can control event bubbling. Note
  that the closure style actions cannot.

  Events triggered through the action helper will automatically have
  `.preventDefault()` called on them. You do not need to do so in your event
  handlers. If you need to allow event propagation (to handle file inputs for
  example) you can supply the `preventDefault=false` option to the `{{action}}` helper:

  ```handlebars
  <div {{action "sayHello" preventDefault=false}}>
    <input type="file" />
    <input type="checkbox" />
  </div>
  ```

  To disable bubbling, pass `bubbles=false` to the helper:

  ```handlebars
  <button {{action 'edit' post bubbles=false}}>Edit</button>
  ```

  To disable bubbling with closure style actions you must create your own
  wrapper helper that makes use of `event.stopPropagation()`:

  ```handlebars
  <div onclick={{disable-bubbling (action "sayHello")}}>Hello</div>
  ```

  ```app/helpers/disable-bubbling.js
  import { helper } from '@ember/component/helper';

  export function disableBubbling([action]) {
    return function(event) {
      event.stopPropagation();
      return action(event);
    };
  }
  export default helper(disableBubbling);
  ```

  If you need the default handler to trigger you should either register your
  own event handler, or use event methods on your view class. See
  ["Responding to Browser Events"](/ember/release/classes/Component)
  in the documentation for `Component` for more information.

  ### Specifying DOM event type

  `{{action}}` helpers called in element space can specify an event type.
  By default the `{{action}}` helper registers for DOM `click` events. You can
  supply an `on` option to the helper to specify a different DOM event name:

  ```handlebars
  <div {{action "anActionName" on="doubleClick"}}>
    click me
  </div>
  ```

  See ["Event Names"](/ember/release/classes/Component) for a list of
  acceptable DOM event names.

  ### Specifying whitelisted modifier keys

  `{{action}}` helpers called in element space can specify modifier keys.
  By default the `{{action}}` helper will ignore click events with pressed modifier
  keys. You can supply an `allowedKeys` option to specify which keys should not be ignored.

  ```handlebars
  <div {{action "anActionName" allowedKeys="alt"}}>
    click me
  </div>
  ```

  This way the action will fire when clicking with the alt key pressed down.
  Alternatively, supply "any" to the `allowedKeys` option to accept any combination of modifier keys.

  ```handlebars
  <div {{action "anActionName" allowedKeys="any"}}>
    click me with any key pressed
  </div>
  ```

  ### Specifying a Target

  A `target` option can be provided to the helper to change
  which object will receive the method call. This option must be a path
  to an object, accessible in the current context:

  ```app/templates/application.hbs
  <div {{action "anActionName" target=someService}}>
    click me
  </div>
  ```

  ```app/controllers/application.js
  import Controller from '@ember/controller';
  import { service } from '@ember/service';

  export default class extends Controller {
    @service someService;
  }
  ```

  @method action
  @for Ember.Templates.helpers
  @public
*/
const action = internalHelper(args => {
  deprecateUntil(`Usage of the \`(action)\` helper is deprecated. Migrate to native functions and function invocation.`, DEPRECATIONS.DEPRECATE_TEMPLATE_ACTION);
  let {
    named,
    positional
  } = args;
  // The first two argument slots are reserved.
  // pos[0] is the context (or `this`)
  // pos[1] is the action name or function
  // Anything else is an action argument.
  let [context, action, ...restArgs] = positional;
  (isDevelopingApp() && !(context && action) && assert('hash position arguments', context && action));
  let debugKey = action.debugLabel;
  let target = 'target' in named ? named['target'] : context;
  let processArgs = makeArgsProcessor('value' in named && named['value'] || false, restArgs);
  let fn;
  if (isInvokableRef(action)) {
    fn = makeClosureAction(action, action, invokeRef, processArgs, debugKey);
  } else {
    fn = makeDynamicClosureAction(valueForRef(context),
    // SAFETY: glimmer-vm should expose narrowing utilities for references
    //         as is, `target` is still `Reference<unknown>`.
    //         however, we never even tried to narrow `target`, so this is potentially risky code.
    target,
    // SAFETY: glimmer-vm should expose narrowing utilities for references
    //         as is, `action` is still `Reference<unknown>`
    action, processArgs, debugKey);
  }
  ACTIONS.add(fn);
  return createUnboundRef(fn, '(result of an `action` helper)');
});
function NOOP(args) {
  return args;
}
function makeArgsProcessor(valuePathRef, actionArgsRef) {
  let mergeArgs;
  if (actionArgsRef.length > 0) {
    mergeArgs = args => {
      return actionArgsRef.map(valueForRef).concat(args);
    };
  }
  let readValue;
  if (valuePathRef) {
    readValue = args => {
      let valuePath = valueForRef(valuePathRef);
      if (valuePath && args.length > 0) {
        args[0] = get(args[0], valuePath);
      }
      return args;
    };
  }
  if (mergeArgs && readValue) {
    return args => {
      return readValue(mergeArgs(args));
    };
  } else {
    return mergeArgs || readValue || NOOP;
  }
}
function makeDynamicClosureAction(context, targetRef, actionRef, processArgs, debugKey) {
  const action = valueForRef(actionRef);

  // We don't allow undefined/null values, so this creates a throw-away action to trigger the assertions
  if (isDevelopingApp()) {
    makeClosureAction(context, valueForRef(targetRef), action, processArgs, debugKey);
  }
  return (...args) => {
    return makeClosureAction(context, valueForRef(targetRef), action, processArgs, debugKey)(...args);
  };
}
function makeClosureAction(context, target, action, processArgs, debugKey) {
  let self;
  let fn;
  (isDevelopingApp() && !(action !== undefined && action !== null) && assert(`Action passed is null or undefined in (action) from ${target}.`, action !== undefined && action !== null));
  if (typeof action === 'string') {
    (isDevelopingApp() && !(target !== null && typeof target === 'object') && assert('target must be an object', target !== null && typeof target === 'object'));
    self = target;
    let value = target.actions?.[action];
    (isDevelopingApp() && !(Boolean(value)) && assert(`An action named '${action}' was not found in ${target}`, Boolean(value)));
    (isDevelopingApp() && !(typeof value === 'function') && assert(`An action named '${action}' was found in ${target}, but is not a function`, typeof value === 'function'));
    fn = value;
  } else if (typeof action === 'function') {
    self = context;
    fn = action;
  } else {
    (isDevelopingApp() && !(false) && assert(`An action could not be made for \`${debugKey || action}\` in ${target}. Please confirm that you are using either a quoted action name (i.e. \`(action '${debugKey || 'myAction'}')\`) or a function available in ${target}.`, false));
  }
  return (...args) => {
    let payload = {
      target: self,
      args,
      label: '@glimmer/closure-action'
    };
    return flaggedInstrument('interaction.ember-action', payload, () => {
      return join(self, fn, ...processArgs(args));
    });
  };
}

// The code above:

// 1. Finds an action function, usually on the `actions` hash
// 2. Calls it with the target as the correct `this` context

// Previously, `UPDATE_REFERENCED_VALUE` was a method on the reference itself,
// so this made a bit more sense. Now, it isn't, and so we need to create a
// function that can have `this` bound to it when called. This allows us to use
// the same codepath to call `updateRef` on the reference.
function invokeRef(value) {
  updateRef(this, value);
}

function processComponentArgs(namedArgs) {
  let attrs = Object.create(null);
  let props = Object.create(null);
  props[ARGS] = namedArgs;
  for (let name in namedArgs) {
    let ref = namedArgs[name];
    (isDevelopingApp() && !(ref) && assert('expected ref', ref));
    let value = valueForRef(ref);
    let isAction = typeof value === 'function' && ACTIONS.has(value);
    if (isUpdatableRef(ref) && !isAction) {
      attrs[name] = new MutableCell(ref, value);
    } else {
      attrs[name] = value;
    }
    props[name] = value;
  }
  props.attrs = attrs;
  return props;
}
const REF = Symbol('REF');
class MutableCell {
  value;
  [MUTABLE_CELL];
  [REF];
  constructor(ref, value) {
    this[MUTABLE_CELL] = true;
    this[REF] = ref;
    this.value = value;
  }
  update(val) {
    updateRef(this[REF], val);
  }
}

const ARGS = enumerableSymbol('ARGS');
const HAS_BLOCK = enumerableSymbol('HAS_BLOCK');
const DIRTY_TAG = Symbol('DIRTY_TAG');
const IS_DISPATCHING_ATTRS = Symbol('IS_DISPATCHING_ATTRS');
const BOUNDS = Symbol('BOUNDS');
const EMBER_VIEW_REF = createPrimitiveRef('ember-view');
function aliasIdToElementId(args, props) {
  if (args.named.has('id')) {
    (isDevelopingApp() && !(!args.named.has('elementId')) && assert(`You cannot invoke a component with both 'id' and 'elementId' at the same time.`, !args.named.has('elementId')));
    props.elementId = props.id;
  }
}

// We must traverse the attributeBindings in reverse keeping track of
// what has already been applied. This is essentially refining the concatenated
// properties applying right to left.
function applyAttributeBindings(attributeBindings, component, rootRef, operations) {
  let seen = [];
  let i = attributeBindings.length - 1;
  while (i !== -1) {
    let binding = attributeBindings[i];
    (isDevelopingApp() && !(binding) && assert('has binding', binding));
    let parsed = parseAttributeBinding(binding);
    let attribute = parsed[1];
    if (seen.indexOf(attribute) === -1) {
      seen.push(attribute);
      installAttributeBinding(component, rootRef, parsed, operations);
    }
    i--;
  }
  if (seen.indexOf('id') === -1) {
    let id = component.elementId ? component.elementId : guidFor(component);
    operations.setAttribute('id', createPrimitiveRef(id), false, null);
  }
}
const EMPTY_POSITIONAL_ARGS = [];
debugFreeze(EMPTY_POSITIONAL_ARGS);
class CurlyComponentManager {
  templateFor(component) {
    let {
      layout,
      layoutName
    } = component;
    let owner = getOwner(component);
    (isDevelopingApp() && !(owner) && assert('Component is unexpectedly missing an owner', owner));
    let factory;
    if (layout === undefined) {
      if (layoutName !== undefined) {
        let _factory = owner.lookup(`template:${layoutName}`);
        (isDevelopingApp() && !(_factory !== undefined) && assert(`Layout \`${layoutName}\` not found!`, _factory !== undefined));
        factory = _factory;
      } else {
        return null;
      }
    } else if (isTemplateFactory(layout)) {
      factory = layout;
    } else {
      // no layout was found, use the default layout
      return null;
    }
    return unwrapTemplate(factory(owner)).asWrappedLayout();
  }
  getDynamicLayout(bucket) {
    return this.templateFor(bucket.component);
  }
  getTagName(state) {
    let {
      component,
      hasWrappedElement
    } = state;
    if (!hasWrappedElement) {
      return null;
    }
    return component && component.tagName || 'div';
  }
  getCapabilities() {
    return CURLY_CAPABILITIES;
  }
  prepareArgs(ComponentClass, args) {
    if (args.named.has('__ARGS__')) {
      (isDevelopingApp() && !(args.positional.length === 0) && assert('[BUG] cannot pass both __ARGS__ and positional arguments', args.positional.length === 0));
      let {
        __ARGS__,
        ...rest
      } = args.named.capture();
      (isDevelopingApp() && !(__ARGS__) && assert('[BUG] unexpectedly missing __ARGS__ after check', __ARGS__)); // does this need to be untracked?
      let __args__ = valueForRef(__ARGS__);
      let prepared = {
        positional: __args__.positional,
        named: {
          ...rest,
          ...__args__.named
        }
      };
      return prepared;
    }
    const {
      positionalParams
    } = ComponentClass.class ?? ComponentClass;

    // early exits
    if (positionalParams === undefined || positionalParams === null || args.positional.length === 0) {
      return null;
    }
    let named;
    if (typeof positionalParams === 'string') {
      (isDevelopingApp() && !(!args.named.has(positionalParams)) && assert(`You cannot specify positional parameters and the hash argument \`${positionalParams}\`.`, !args.named.has(positionalParams)));
      let captured = args.positional.capture();
      named = {
        [positionalParams]: createComputeRef(() => reifyPositional(captured))
      };
      Object.assign(named, args.named.capture());
    } else if (Array.isArray(positionalParams) && positionalParams.length > 0) {
      const count = Math.min(positionalParams.length, args.positional.length);
      named = {};
      Object.assign(named, args.named.capture());
      for (let i = 0; i < count; i++) {
        let name = positionalParams[i];
        (isDevelopingApp() && !(name) && assert('Expected at least one positional param', name));
        (isDevelopingApp() && !(!args.named.has(name)) && assert(`You cannot specify both a positional param (at position ${i}) and the hash argument \`${name}\`.`, !args.named.has(name)));
        named[name] = args.positional.at(i);
      }
    } else {
      return null;
    }
    return {
      positional: EMPTY_ARRAY$1,
      named
    };
  }

  /*
   * This hook is responsible for actually instantiating the component instance.
   * It also is where we perform additional bookkeeping to support legacy
   * features like exposed by view mixins like ChildViewSupport, ActionSupport,
   * etc.
   */
  create(owner, ComponentClass, args, {
    isInteractive
  }, dynamicScope, callerSelfRef, hasBlock) {
    // Get the nearest concrete component instance from the scope. "Virtual"
    // components will be skipped.
    let parentView = dynamicScope.view;

    // Capture the arguments, which tells Glimmer to give us our own, stable
    // copy of the Arguments object that is safe to hold on to between renders.
    let capturedArgs = args.named.capture();
    beginTrackFrame();
    let props = processComponentArgs(capturedArgs);
    let argsTag = endTrackFrame();

    // Alias `id` argument to `elementId` property on the component instance.
    aliasIdToElementId(args, props);

    // Set component instance's parentView property to point to nearest concrete
    // component.
    props.parentView = parentView;

    // Set whether this component was invoked with a block
    // (`{{#my-component}}{{/my-component}}`) or without one
    // (`{{my-component}}`).
    props[HAS_BLOCK] = hasBlock;

    // Save the current `this` context of the template as the component's
    // `_target`, so bubbled actions are routed to the right place.
    props._target = valueForRef(callerSelfRef);
    setOwner(props, owner);

    // caller:
    // <FaIcon @name="bug" />
    //
    // callee:
    // <i class="fa-{{@name}}"></i>

    // Now that we've built up all of the properties to set on the component instance,
    // actually create it.
    beginUntrackFrame();
    let component = ComponentClass.create(props);
    let finalizer = _instrumentStart('render.component', initialRenderInstrumentDetails, component);

    // We become the new parentView for downstream components, so save our
    // component off on the dynamic scope.
    dynamicScope.view = component;

    // Unless we're the root component, we need to add ourselves to our parent
    // component's childViews array.
    if (parentView !== null && parentView !== undefined) {
      addChildView(parentView, component);
    }
    component.trigger('didReceiveAttrs');
    let hasWrappedElement = component.tagName !== '';

    // We usually do this in the `didCreateElement`, but that hook doesn't fire for tagless components
    if (!hasWrappedElement) {
      if (isInteractive) {
        component.trigger('willRender');
      }
      component._transitionTo('hasElement');
      if (isInteractive) {
        component.trigger('willInsertElement');
      }
    }

    // Track additional lifecycle metadata about this component in a state bucket.
    // Essentially we're saving off all the state we'll need in the future.
    let bucket = new ComponentStateBucket(component, capturedArgs, argsTag, finalizer, hasWrappedElement, isInteractive);
    if (args.named.has('class')) {
      bucket.classRef = args.named.get('class');
    }
    if (isDevelopingApp()) {
      processComponentInitializationAssertions(component, props);
    }
    if (isInteractive && hasWrappedElement) {
      component.trigger('willRender');
    }
    endUntrackFrame();

    // consume every argument so we always run again
    consumeTag(bucket.argsTag);
    consumeTag(component[DIRTY_TAG]);
    return bucket;
  }
  getDebugName(definition) {
    return definition.fullName || definition.normalizedName || definition.class?.name || definition.name;
  }
  getSelf({
    rootRef
  }) {
    return rootRef;
  }
  didCreateElement({
    component,
    classRef,
    isInteractive,
    rootRef
  }, element, operations) {
    setViewElement(component, element);
    setElementView(element, component);
    let {
      attributeBindings,
      classNames,
      classNameBindings
    } = component;
    if (attributeBindings && attributeBindings.length) {
      applyAttributeBindings(attributeBindings, component, rootRef, operations);
    } else {
      let id = component.elementId ? component.elementId : guidFor(component);
      operations.setAttribute('id', createPrimitiveRef(id), false, null);
    }
    if (classRef) {
      const ref = createSimpleClassNameBindingRef(classRef);
      operations.setAttribute('class', ref, false, null);
    }
    if (classNames && classNames.length) {
      classNames.forEach(name => {
        operations.setAttribute('class', createPrimitiveRef(name), false, null);
      });
    }
    if (classNameBindings && classNameBindings.length) {
      classNameBindings.forEach(binding => {
        createClassNameBindingRef(rootRef, binding, operations);
      });
    }
    operations.setAttribute('class', EMBER_VIEW_REF, false, null);
    if ('ariaRole' in component) {
      operations.setAttribute('role', childRefFor(rootRef, 'ariaRole'), false, null);
    }
    component._transitionTo('hasElement');
    if (isInteractive) {
      beginUntrackFrame();
      component.trigger('willInsertElement');
      endUntrackFrame();
    }
  }
  didRenderLayout(bucket, bounds) {
    bucket.component[BOUNDS] = bounds;
    bucket.finalize();
  }
  didCreate({
    component,
    isInteractive
  }) {
    if (isInteractive) {
      component._transitionTo('inDOM');
      component.trigger('didInsertElement');
      component.trigger('didRender');
    }
  }
  update(bucket) {
    let {
      component,
      args,
      argsTag,
      argsRevision,
      isInteractive
    } = bucket;
    bucket.finalizer = _instrumentStart('render.component', rerenderInstrumentDetails, component);
    beginUntrackFrame();
    if (args !== null && !validateTag(argsTag, argsRevision)) {
      beginTrackFrame();
      let props = processComponentArgs(args);
      argsTag = bucket.argsTag = endTrackFrame();
      bucket.argsRevision = valueForTag(argsTag);
      component[IS_DISPATCHING_ATTRS] = true;
      component.setProperties(props);
      component[IS_DISPATCHING_ATTRS] = false;
      component.trigger('didUpdateAttrs');
      component.trigger('didReceiveAttrs');
    }
    if (isInteractive) {
      component.trigger('willUpdate');
      component.trigger('willRender');
    }
    endUntrackFrame();
    consumeTag(argsTag);
    consumeTag(component[DIRTY_TAG]);
  }
  didUpdateLayout(bucket) {
    bucket.finalize();
  }
  didUpdate({
    component,
    isInteractive
  }) {
    if (isInteractive) {
      component.trigger('didUpdate');
      component.trigger('didRender');
    }
  }
  getDestroyable(bucket) {
    return bucket;
  }
}
function processComponentInitializationAssertions(component, props) {
  (isDevelopingApp() && !((() => {
    let {
      classNameBindings
    } = component;
    for (let i = 0; i < classNameBindings.length; i++) {
      let binding = classNameBindings[i];
      if (typeof binding !== 'string' || binding.length === 0) {
        return false;
      }
    }
    return true;
  })()) && assert(`classNameBindings must be non-empty strings: ${component}`, (() => {
    let {
      classNameBindings
    } = component;
    for (let i = 0; i < classNameBindings.length; i++) {
      let binding = classNameBindings[i];
      if (typeof binding !== 'string' || binding.length === 0) {
        return false;
      }
    }
    return true;
  })()));
  (isDevelopingApp() && !((() => {
    let {
      classNameBindings
    } = component;
    for (let binding of classNameBindings) {
      if (binding.split(' ').length > 1) {
        return false;
      }
    }
    return true;
  })()) && assert(`classNameBindings must not have spaces in them: ${component}`, (() => {
    let {
      classNameBindings
    } = component;
    for (let binding of classNameBindings) {
      if (binding.split(' ').length > 1) {
        return false;
      }
    }
    return true;
  })()));
  (isDevelopingApp() && !(component.tagName !== '' || !component.classNameBindings || component.classNameBindings.length === 0) && assert(`You cannot use \`classNameBindings\` on a tag-less component: ${component}`, component.tagName !== '' || !component.classNameBindings || component.classNameBindings.length === 0));
  (isDevelopingApp() && !(component.tagName !== '' || props.id === component.elementId || !component.elementId && component.elementId !== '') && assert(`You cannot use \`elementId\` on a tag-less component: ${component}`, component.tagName !== '' || props.id === component.elementId || !component.elementId && component.elementId !== ''));
  (isDevelopingApp() && !(component.tagName !== '' || !component.attributeBindings || component.attributeBindings.length === 0) && assert(`You cannot use \`attributeBindings\` on a tag-less component: ${component}`, component.tagName !== '' || !component.attributeBindings || component.attributeBindings.length === 0));
}
function initialRenderInstrumentDetails(component) {
  return component.instrumentDetails({
    initialRender: true
  });
}
function rerenderInstrumentDetails(component) {
  return component.instrumentDetails({
    initialRender: false
  });
}
const CURLY_CAPABILITIES = {
  dynamicLayout: true,
  dynamicTag: true,
  prepareArgs: true,
  createArgs: true,
  attributeHook: true,
  elementHook: true,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: true,
  willDestroy: true,
  hasSubOwner: false
};
const CURLY_COMPONENT_MANAGER = new CurlyComponentManager();
function isCurlyManager(manager) {
  return manager === CURLY_COMPONENT_MANAGER;
}

let lazyEventsProcessed = new WeakMap();

/**
@module @ember/component
*/

// A zero-runtime-overhead private symbol to use in branding the component to
// preserve its type parameter.

/**
  A component is a reusable UI element that consists of a `.hbs` template and an
  optional JavaScript class that defines its behavior. For example, someone
  might make a `button` in the template and handle the click behavior in the
  JavaScript file that shares the same name as the template.

  Components are broken down into two categories:

  - Components _without_ JavaScript, that are based only on a template. These
    are called Template-only or TO components.
  - Components _with_ JavaScript, which consist of a template and a backing
    class.

  Ember ships with two types of JavaScript classes for components:

  1. Glimmer components, imported from `@glimmer/component`, which are the
     default component's for Ember Octane (3.15) and more recent editions.
  2. Classic components, imported from `@ember/component`, which were the
     default for older editions of Ember (pre 3.15).

  Below is the documentation for Classic components. If you are looking for the
  API documentation for Template-only or Glimmer components, it is
  [available here](/ember/release/modules/@glimmer%2Fcomponent).

  ## Defining a Classic Component

  If you want to customize the component in order to handle events, transform
  arguments or maintain internal state, you implement a subclass of `Component`.

  One example is to add computed properties to your component:

  ```app/components/person-profile.js
  import Component from '@ember/component';

  export default Component.extend({
    displayName: computed('person.title', 'person.firstName', 'person.lastName', function() {
      let { title, firstName, lastName } = this.person;

      if (title) {
        return `${title} ${lastName}`;
      } else {
        return `${firstName} ${lastName}`;
      }
    })
  });
  ```

  And then use it in the component's template:

  ```app/templates/components/person-profile.hbs
  <h1>{{this.displayName}}</h1>
  {{yield}}
  ```

  ## Customizing a Classic Component's HTML Element in JavaScript

  ### HTML Tag

  The default HTML tag name used for a component's HTML representation is `div`.
  This can be customized by setting the `tagName` property.

  Consider the following component class:

  ```app/components/emphasized-paragraph.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'em'
  });
  ```

  When invoked, this component would produce output that looks something like
  this:

  ```html
  <em id="ember1" class="ember-view"></em>
  ```

  ### HTML `class` Attribute

  The HTML `class` attribute of a component's tag can be set by providing a
  `classNames` property that is set to an array of strings:

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    classNames: ['my-class', 'my-other-class']
  });
  ```

  Invoking this component will produce output that looks like this:

  ```html
  <div id="ember1" class="ember-view my-class my-other-class"></div>
  ```

  `class` attribute values can also be set by providing a `classNameBindings`
  property set to an array of properties names for the component. The return
  value of these properties will be added as part of the value for the
  components's `class` attribute. These properties can be computed properties:

  ```app/components/my-widget.js
  import Component from '@ember/component';
  import { computed } from '@ember/object';

  export default Component.extend({
    classNames: ['my-class', 'my-other-class'],
    classNameBindings: ['propertyA', 'propertyB'],

    propertyA: 'from-a',
    propertyB: computed(function() {
      if (someLogic) { return 'from-b'; }
    })
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view my-class my-other-class from-a from-b"></div>
  ```

  Note that `classNames` and `classNameBindings` is in addition to the `class`
  attribute passed with the angle bracket invocation syntax. Therefore, if this
  component was invoked like so:

  ```handlebars
  <MyWidget class="from-invocation" />
  ```

  The resulting HTML will look similar to this:

  ```html
  <div id="ember1" class="from-invocation ember-view my-class my-other-class from-a from-b"></div>
  ```

  If the value of a class name binding returns a boolean the property name
  itself will be used as the class name if the property is true. The class name
  will not be added if the value is `false` or `undefined`.

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    classNameBindings: ['hovered'],

    hovered: true
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view hovered"></div>
  ```

  ### Custom Class Names for Boolean Values

  When using boolean class name bindings you can supply a string value other
  than the property name for use as the `class` HTML attribute by appending the
  preferred value after a ":" character when defining the binding:

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    classNameBindings: ['awesome:so-very-cool'],

    awesome: true
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view so-very-cool"></div>
  ```

  Boolean value class name bindings whose property names are in a
  camelCase-style format will be converted to a dasherized format:

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    classNameBindings: ['isUrgent'],

    isUrgent: true
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view is-urgent"></div>
  ```

  Class name bindings can also refer to object values that are found by
  traversing a path relative to the component itself:

  ```app/components/my-widget.js
  import Component from '@ember/component';
  import EmberObject from '@ember/object';

  export default Component.extend({
    classNameBindings: ['messages.empty'],

    messages: EmberObject.create({
      empty: true
    })
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view empty"></div>
  ```

  If you want to add a class name for a property which evaluates to true and
  and a different class name if it evaluates to false, you can pass a binding
  like this:

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    classNameBindings: ['isEnabled:enabled:disabled'],
    isEnabled: true
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view enabled"></div>
  ```

  When isEnabled is `false`, the resulting HTML representation looks like this:

  ```html
  <div id="ember1" class="ember-view disabled"></div>
  ```

  This syntax offers the convenience to add a class if a property is `false`:

  ```app/components/my-widget.js
  import Component from '@ember/component';

  // Applies no class when isEnabled is true and class 'disabled' when isEnabled is false
  export default Component.extend({
    classNameBindings: ['isEnabled::disabled'],
    isEnabled: true
  });
  ```

  Invoking this component when the `isEnabled` property is true will produce
  HTML that looks like:

  ```html
  <div id="ember1" class="ember-view"></div>
  ```

  Invoking it when the `isEnabled` property on the component is `false` will
  produce HTML that looks like:

  ```html
  <div id="ember1" class="ember-view disabled"></div>
  ```

  Updates to the value of a class name binding will result in automatic update
  of the  HTML `class` attribute in the component's rendered HTML
  representation. If the value becomes `false` or `undefined` the class name
  will be removed.

  Both `classNames` and `classNameBindings` are concatenated properties. See
  [EmberObject](/ember/release/classes/EmberObject) documentation for more
  information about concatenated properties.

  ### Other HTML Attributes

  The HTML attribute section of a component's tag can be set by providing an
  `attributeBindings` property set to an array of property names on the component.
  The return value of these properties will be used as the value of the component's
  HTML associated attribute:

  ```app/components/my-anchor.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'a',
    attributeBindings: ['href'],

    href: 'http://google.com'
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <a id="ember1" class="ember-view" href="http://google.com"></a>
  ```

  One property can be mapped on to another by placing a ":" between
  the source property and the destination property:

  ```app/components/my-anchor.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'a',
    attributeBindings: ['url:href'],

    url: 'http://google.com'
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <a id="ember1" class="ember-view" href="http://google.com"></a>
  ```

  HTML attributes passed with angle bracket invocations will take precedence
  over those specified in `attributeBindings`. Therefore, if this component was
  invoked like so:

  ```handlebars
  <MyAnchor href="http://bing.com" @url="http://google.com" />
  ```

  The resulting HTML will looks like this:

  ```html
  <a id="ember1" class="ember-view" href="http://bing.com"></a>
  ```

  Note that the `href` attribute is ultimately set to `http://bing.com`,
  despite it having attribute binidng to the `url` property, which was
  set to `http://google.com`.

  Namespaced attributes (e.g. `xlink:href`) are supported, but have to be
  mapped, since `:` is not a valid character for properties in Javascript:

  ```app/components/my-use.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'use',
    attributeBindings: ['xlinkHref:xlink:href'],

    xlinkHref: '#triangle'
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <use xlink:href="#triangle"></use>
  ```

  If the value of a property monitored by `attributeBindings` is a boolean, the
  attribute will be present or absent depending on the value:

  ```app/components/my-text-input.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'input',
    attributeBindings: ['disabled'],

    disabled: false
  });
  ```

  Invoking this component will produce HTML that looks like:

  ```html
  <input id="ember1" class="ember-view" />
  ```

  `attributeBindings` can refer to computed properties:

  ```app/components/my-text-input.js
  import Component from '@ember/component';
  import { computed } from '@ember/object';

  export default Component.extend({
    tagName: 'input',
    attributeBindings: ['disabled'],

    disabled: computed(function() {
      if (someLogic) {
        return true;
      } else {
        return false;
      }
    })
  });
  ```

  To prevent setting an attribute altogether, use `null` or `undefined` as the
  value of the property used in `attributeBindings`:

  ```app/components/my-text-input.js
  import Component from '@ember/component';

  export default Component.extend({
    tagName: 'form',
    attributeBindings: ['novalidate'],
    novalidate: null
  });
  ```

  Updates to the property of an attribute binding will result in automatic
  update of the  HTML attribute in the component's HTML output.

  `attributeBindings` is a concatenated property. See
  [EmberObject](/ember/release/classes/EmberObject) documentation for more
  information about concatenated properties.

  ## Layouts

  The `layout` property can be used to dynamically specify a template associated
  with a component class, instead of relying on Ember to link together a
  component class and a template based on file names.

  In general, applications should not use this feature, but it's commonly used
  in addons for historical reasons.

  The `layout` property should be set to the default export of a template
  module, which is the name of a template file without the `.hbs` extension.

  ```app/templates/components/person-profile.hbs
  <h1>Person's Title</h1>
  <div class='details'>{{yield}}</div>
  ```

  ```app/components/person-profile.js
    import Component from '@ember/component';
    import layout from '../templates/components/person-profile';

    export default Component.extend({
      layout
    });
  ```

  If you invoke the component:

  ```handlebars
  <PersonProfile>
    <h2>Chief Basket Weaver</h2>
    <h3>Fisherman Industries</h3>
  </PersonProfile>
  ```

  or

  ```handlebars
  {{#person-profile}}
    <h2>Chief Basket Weaver</h2>
    <h3>Fisherman Industries</h3>
  {{/person-profile}}
  ```

  It will result in the following HTML output:

  ```html
  <h1>Person's Title</h1>
    <div class="details">
    <h2>Chief Basket Weaver</h2>
    <h3>Fisherman Industries</h3>
  </div>
  ```

  ## Handling Browser Events

  Components can respond to user-initiated events in one of three ways: passing
  actions with angle bracket invocation, adding event handler methods to the
  component's class, or adding actions to the component's template.

  ### Passing Actions With Angle Bracket Invocation

  For one-off events specific to particular instance of a component, it is possible
  to pass actions to the component's element using angle bracket invocation syntax.

  ```handlebars
  <MyWidget {{action 'firstWidgetClicked'}} />

  <MyWidget {{action 'secondWidgetClicked'}} />
  ```

  In this case, when the first component is clicked on, Ember will invoke the
  `firstWidgetClicked` action. When the second component is clicked on, Ember
  will invoke the `secondWidgetClicked` action instead.

  Besides `{{action}}`, it is also possible to pass any arbitrary element modifiers
  using the angle bracket invocation syntax.

  ### Event Handler Methods

  Components can also respond to user-initiated events by implementing a method
  that matches the event name. This approach is appropriate when the same event
  should be handled by all instances of the same component.

  An event object will be passed as the argument to the event handler method.

  ```app/components/my-widget.js
  import Component from '@ember/component';

  export default Component.extend({
    click(event) {
      // `event.target` is either the component's element or one of its children
      let tag = event.target.tagName.toLowerCase();
      console.log('clicked on a `<${tag}>` HTML element!');
    }
  });
  ```

  In this example, whenever the user clicked anywhere inside the component, it
  will log a message to the console.

  It is possible to handle event types other than `click` by implementing the
  following event handler methods. In addition, custom events can be registered
  by using `Application.customEvents`.

  Touch events:

  * `touchStart`
  * `touchMove`
  * `touchEnd`
  * `touchCancel`

  Keyboard events:

  * `keyDown`
  * `keyUp`
  * `keyPress`

  Mouse events:

  * `mouseDown`
  * `mouseUp`
  * `contextMenu`
  * `click`
  * `doubleClick`
  * `focusIn`
  * `focusOut`

  Form events:

  * `submit`
  * `change`
  * `focusIn`
  * `focusOut`
  * `input`

  Drag and drop events:

  * `dragStart`
  * `drag`
  * `dragEnter`
  * `dragLeave`
  * `dragOver`
  * `dragEnd`
  * `drop`

  ### `{{action}}` Helper

  Instead of handling all events of a particular type anywhere inside the
  component's element, you may instead want to limit it to a particular
  element in the component's template. In this case, it would be more
  convenient to implement an action instead.

  For example, you could implement the action `hello` for the `person-profile`
  component:

  ```app/components/person-profile.js
  import Component from '@ember/component';

  export default Component.extend({
    actions: {
      hello(name) {
        console.log("Hello", name);
      }
    }
  });
  ```

  And then use it in the component's template:

  ```app/templates/components/person-profile.hbs
  <h1>{{@person.name}}</h1>

  <button {{action 'hello' @person.name}}>
    Say Hello to {{@person.name}}
  </button>
  ```

  When the user clicks the button, Ember will invoke the `hello` action,
  passing in the current value of `@person.name` as an argument.

  See [Ember.Templates.helpers.action](/ember/release/classes/Ember.Templates.helpers/methods/action?anchor=action).

  @class Component
  @extends Ember.CoreView
  @uses Ember.TargetActionSupport
  @uses Ember.ClassNamesSupport
  @uses Ember.ActionSupport
  @uses Ember.ViewMixin
  @uses Ember.ViewStateSupport
  @public
*/
// This type param is used in the class, so must appear here.
// eslint-disable-next-line @typescript-eslint/no-unused-vars

class Component extends CoreView.extend(ChildViewsSupport, ViewStateSupport, ClassNamesSupport, TargetActionSupport, ActionSupport, ViewMixin, {
  // These need to be overridable via extend/create but should still
  // have a default. Defining them here is the best way to achieve that.
  didReceiveAttrs() {},
  didRender() {},
  didUpdate() {},
  didUpdateAttrs() {},
  willRender() {},
  willUpdate() {}
}) {
  isComponent = true;

  // SAFETY: this has no runtime existence whatsoever; it is a "phantom type"
  // here to preserve the type param.

  // SAFTEY: This is set in `init`.

  init(properties) {
    super.init(properties);

    // Handle methods from ViewMixin.
    // The native class inheritance will not work for mixins. To work around this,
    // we copy the existing rerender method provided by the mixin and swap in the
    // new rerender method from our class.
    this._superRerender = this.rerender;
    this.rerender = this._rerender;
    this[IS_DISPATCHING_ATTRS] = false;
    this[DIRTY_TAG] = createTag();
    this[BOUNDS] = null;
    const eventDispatcher = this._dispatcher;
    if (eventDispatcher) {
      let lazyEventsProcessedForComponentClass = lazyEventsProcessed.get(eventDispatcher);
      if (!lazyEventsProcessedForComponentClass) {
        lazyEventsProcessedForComponentClass = new WeakSet();
        lazyEventsProcessed.set(eventDispatcher, lazyEventsProcessedForComponentClass);
      }
      let proto = Object.getPrototypeOf(this);
      if (!lazyEventsProcessedForComponentClass.has(proto)) {
        let lazyEvents = eventDispatcher.lazyEvents;
        lazyEvents.forEach((mappedEventName, event) => {
          if (mappedEventName !== null && typeof this[mappedEventName] === 'function') {
            eventDispatcher.setupHandlerForBrowserEvent(event);
          }
        });
        lazyEventsProcessedForComponentClass.add(proto);
      }
    }
    if (isDevelopingApp() && eventDispatcher && this.renderer._isInteractive && this.tagName === '') {
      let eventNames = [];
      let events = eventDispatcher.finalEventNameMapping;
      for (let key in events) {
        let methodName = events[key];
        if (methodName && typeof this[methodName] === 'function') {
          eventNames.push(methodName);
        }
      }
      // If in a tagless component, assert that no event handlers are defined
      (isDevelopingApp() && !(!eventNames.length) && assert(`You can not define \`${eventNames}\` function(s) to handle DOM event in the \`${this}\` tagless component since it doesn't have any DOM element.`, !eventNames.length));
    }
  }
  __dispatcher;
  get _dispatcher() {
    if (this.__dispatcher === undefined) {
      let owner = getOwner(this);
      (isDevelopingApp() && !(owner) && assert('Component is unexpectedly missing an owner', owner));
      if (owner.lookup('-environment:main').isInteractive) {
        let dispatcher = owner.lookup('event_dispatcher:main');
        (isDevelopingApp() && !(dispatcher instanceof EventDispatcher) && assert('Expected dispatcher to be an EventDispatcher', dispatcher instanceof EventDispatcher));
        this.__dispatcher = dispatcher;
      } else {
        // In FastBoot we have no EventDispatcher. Set to null to not try again to look it up.
        this.__dispatcher = null;
      }
    }
    return this.__dispatcher;
  }
  on(name, target, method) {
    this._dispatcher?.setupHandlerForEmberEvent(name);
    // The `on` method here comes from the Evented mixin. Since this mixin
    // is applied to the parent of this class, however, we are still able
    // to use `super`.
    return super.on(name, target, method);
  }

  // Changed to `rerender` on init
  _rerender() {
    DIRTY_TAG$1(this[DIRTY_TAG]);
    this._superRerender();
  }
  [PROPERTY_DID_CHANGE](key, value) {
    if (this[IS_DISPATCHING_ATTRS]) {
      return;
    }
    let args = this[ARGS];
    let reference = args !== undefined ? args[key] : undefined;
    if (reference !== undefined && isUpdatableRef(reference)) {
      updateRef(reference, arguments.length === 2 ? value : get(this, key));
    }
  }
  getAttr(key) {
    // TODO Intimate API should be deprecated
    return this.get(key);
  }

  /**
    Normally, Ember's component model is "write-only". The component takes a
    bunch of attributes that it got passed in, and uses them to render its
    template.
     One nice thing about this model is that if you try to set a value to the
    same thing as last time, Ember (through HTMLBars) will avoid doing any
    work on the DOM.
     This is not just a performance optimization. If an attribute has not
    changed, it is important not to clobber the element's "hidden state".
    For example, if you set an input's `value` to the same value as before,
    it will clobber selection state and cursor position. In other words,
    setting an attribute is not **always** idempotent.
     This method provides a way to read an element's attribute and also
    update the last value Ember knows about at the same time. This makes
    setting an attribute idempotent.
     In particular, what this means is that if you get an `<input>` element's
    `value` attribute and then re-render the template with the same value,
    it will avoid clobbering the cursor and selection position.
    Since most attribute sets are idempotent in the browser, you typically
    can get away with reading attributes using jQuery, but the most reliable
    way to do so is through this method.
    @method readDOMAttr
     @param {String} name the name of the attribute
    @return String
    @public
    */
  readDOMAttr(name) {
    // TODO revisit this
    let _element = getViewElement(this);
    (isDevelopingApp() && !(_element !== null) && assert(`Cannot call \`readDOMAttr\` on ${this} which does not have an element`, _element !== null));
    let element = _element;
    let isSVG = element.namespaceURI === 'http://www.w3.org/2000/svg';
    let {
      type,
      normalized
    } = normalizeProperty(element, name);
    if (isSVG || type === 'attr') {
      return element.getAttribute(normalized);
    }
    return element[normalized];
  }

  // --- Declarations which support mixins ---
  // We use `declare` on these properties, even though they are optional, so
  // that they do not get created on the class *at all* when emitting the
  // transpiled code. Otherwise, since declared class properties are equivalent
  // to calling `defineProperty` in the class constructor, they would "stomp"
  // the properties supplied by mixins.

  /**
   Enables components to take a list of parameters as arguments.
    For example, a component that takes two parameters with the names
    `name` and `age`:
     ```app/components/my-component.js
    import Component from '@ember/component';
     let MyComponent = Component.extend();
     MyComponent.reopenClass({
      positionalParams: ['name', 'age']
    });
     export default MyComponent;
    ```
     It can then be invoked like this:
     ```hbs
    {{my-component "John" 38}}
    ```
     The parameters can be referred to just like named parameters:
     ```hbs
    Name: {{name}}, Age: {{age}}.
    ```
     Using a string instead of an array allows for an arbitrary number of
    parameters:
     ```app/components/my-component.js
    import Component from '@ember/component';
     let MyComponent = Component.extend();
     MyComponent.reopenClass({
      positionalParams: 'names'
    });
     export default MyComponent;
    ```
     It can then be invoked like this:
     ```hbs
    {{my-component "John" "Michael" "Scott"}}
    ```
    The parameters can then be referred to by enumerating over the list:
     ```hbs
    {{#each names as |name|}}{{name}}{{/each}}
    ```
     @static
    @public
    @property positionalParams
    @since 1.13.0
    */ /**
       Enables components to take a list of parameters as arguments.
       For example, a component that takes two parameters with the names
       `name` and `age`:
       ```app/components/my-component.js
       import Component from '@ember/component';
       let MyComponent = Component.extend();
       MyComponent.reopenClass({
       positionalParams: ['name', 'age']
       });
       export default MyComponent;
       ```
       It can then be invoked like this:
       ```hbs
       {{my-component "John" 38}}
       ```
       The parameters can be referred to just like named parameters:
       ```hbs
       Name: {{name}}, Age: {{age}}.
       ```
       Using a string instead of an array allows for an arbitrary number of
       parameters:
       ```app/components/my-component.js
       import Component from '@ember/component';
       let MyComponent = Component.extend();
       MyComponent.reopenClass({
       positionalParams: 'names'
       });
       export default MyComponent;
       ```
       It can then be invoked like this:
       ```hbs
       {{my-component "John" "Michael" "Scott"}}
       ```
       The parameters can then be referred to by enumerating over the list:
       ```hbs
       {{#each names as |name|}}{{name}}{{/each}}
       ```
       @static
       @public
       @property positionalParams
       @since 1.13.0
       */

  /**
    Layout can be used to wrap content in a component.
    @property layout
    @type Function
    @public
  */

  /**
    The name of the layout to lookup if no layout is provided.
    By default `Component` will lookup a template with this name in
    `Ember.TEMPLATES` (a shared global object).
    @property layoutName
    @type String
    @default undefined
    @private
  */

  /**
   The WAI-ARIA role of the control represented by this view. For example, a
    button may have a role of type 'button', or a pane may have a role of
    type 'alertdialog'. This property is used by assistive software to help
    visually challenged users navigate rich web applications.
     The full list of valid WAI-ARIA roles is available at:
    [https://www.w3.org/TR/wai-aria/#roles_categorization](https://www.w3.org/TR/wai-aria/#roles_categorization)
     @property ariaRole
    @type String
    @default undefined
    @public
    */

  static isComponentFactory = true;
  static toString() {
    return '@ember/component';
  }
}

// We continue to use reopenClass here so that positionalParams can be overridden with reopenClass in subclasses.
Component.reopenClass({
  positionalParams: []
});
setInternalComponentManager(CURLY_COMPONENT_MANAGER, Component);

/**
@module @ember/component
*/

const RECOMPUTE_TAG = Symbol('RECOMPUTE_TAG');

// Signature type utilities

// Implements Ember's `Factory` interface and tags it for narrowing/checking.

const IS_CLASSIC_HELPER = Symbol('IS_CLASSIC_HELPER');

// A zero-runtime-overhead private symbol to use in branding the component to
// preserve its type parameter.

/**
  Ember Helpers are functions that can compute values, and are used in templates.
  For example, this code calls a helper named `format-currency`:

  ```app/templates/application.hbs
  <Cost @cents={{230}} />
  ```

  ```app/components/cost.hbs
  <div>{{format-currency @cents currency="$"}}</div>
  ```

  Additionally a helper can be called as a nested helper.
  In this example, we show the formatted currency value if the `showMoney`
  named argument is truthy.

  ```handlebars
  {{if @showMoney (format-currency @cents currency="$")}}
  ```

  Helpers defined using a class must provide a `compute` function. For example:

  ```app/helpers/format-currency.js
  import Helper from '@ember/component/helper';

  export default class extends Helper {
    compute([cents], { currency }) {
      return `${currency}${cents * 0.01}`;
    }
  }
  ```

  Each time the input to a helper changes, the `compute` function will be
  called again.

  As instances, these helpers also have access to the container and will accept
  injected dependencies.

  Additionally, class helpers can call `recompute` to force a new computation.

  @class Helper
  @extends CoreObject
  @public
  @since 1.13.0
*/
// ESLint doesn't understand declaration merging.
/* eslint-disable import/export */

class Helper extends FrameworkObject {
  static isHelperFactory = true;
  static [IS_CLASSIC_HELPER] = true;

  // `packages/ember/index.js` was setting `Helper.helper`. This seems like
  // a bad idea and probably not something we want. We've moved that definition
  // here, but it should definitely be reviewed and probably removed.
  /** @deprecated */
  static helper = helper$1;

  // SAFETY: this is initialized in `init`, rather than `constructor`. It is
  // safe to `declare` like this *if and only if* nothing uses the constructor
  // directly in this class, since nothing else can run before `init`.

  // SAFETY: this has no runtime existence whatsoever; it is a "phantom type"
  // here to preserve the type param.

  init(properties) {
    super.init(properties);
    this[RECOMPUTE_TAG] = createTag();
    (isDevelopingApp() && !(this.compute) && assert('expected compute to be defined', this.compute));
  }

  /**
    On a class-based helper, it may be useful to force a recomputation of that
    helpers value. This is akin to `rerender` on a component.
     For example, this component will rerender when the `currentUser` on a
    session service changes:
     ```app/helpers/current-user-email.js
    import Helper from '@ember/component/helper'
    import { service } from '@ember/service'
    import { observer } from '@ember/object'
     export default Helper.extend({
      session: service(),
       onNewUser: observer('session.currentUser', function() {
        this.recompute();
      }),
       compute() {
        return this.get('session.currentUser.email');
      }
    });
    ```
     @method recompute
    @public
    @since 1.13.0
  */
  recompute() {
    join(() => DIRTY_TAG$1(this[RECOMPUTE_TAG]));
  }
}
/* eslint-enable import/export */

function isClassicHelper(obj) {
  return obj[IS_CLASSIC_HELPER] === true;
}
class ClassicHelperManager {
  capabilities = helperCapabilities('3.23', {
    hasValue: true,
    hasDestroyable: true
  });
  ownerInjection;
  constructor(owner) {
    let ownerInjection = {};
    setOwner(ownerInjection, owner);
    this.ownerInjection = ownerInjection;
  }
  createHelper(definition, args) {
    let instance = isFactoryManager(definition) ? definition.create() : definition.create(this.ownerInjection);
    (isDevelopingApp() && !(function (instance) {
      if (instance !== null && typeof instance === 'object') {
        let cast = instance;
        return typeof cast.compute === 'function' && typeof cast.destroy === 'function';
      }
      return false;
    }(instance)) && assert('expected HelperInstance', function (instance) {
      if (instance !== null && typeof instance === 'object') {
        let cast = instance;
        return typeof cast.compute === 'function' && typeof cast.destroy === 'function';
      }
      return false;
    }(instance)));
    return {
      instance,
      args
    };
  }
  getDestroyable({
    instance
  }) {
    return instance;
  }
  getValue({
    instance,
    args
  }) {
    let {
      positional,
      named
    } = args;
    let ret = instance.compute(positional, named);
    consumeTag(instance[RECOMPUTE_TAG]);
    return ret;
  }
  getDebugName(definition) {
    return getDebugName((definition.class || definition)['prototype']);
  }
}
function isFactoryManager(obj) {
  return obj != null && 'class' in obj;
}
setHelperManager(owner => {
  return new ClassicHelperManager(owner);
}, Helper);
const CLASSIC_HELPER_MANAGER = getInternalHelperManager(Helper);

///////////

class Wrapper {
  isHelperFactory = true;
  constructor(compute) {
    this.compute = compute;
  }
  create() {
    // needs new instance or will leak containers
    return {
      compute: this.compute
    };
  }
}
class SimpleClassicHelperManager {
  capabilities = helperCapabilities('3.23', {
    hasValue: true
  });
  createHelper(definition, args) {
    return () => definition.compute.call(null, args.positional, args.named);
  }
  getValue(fn) {
    return fn();
  }
  getDebugName(definition) {
    return getDebugName(definition.compute);
  }
}
const SIMPLE_CLASSIC_HELPER_MANAGER = new SimpleClassicHelperManager();
setHelperManager(() => SIMPLE_CLASSIC_HELPER_MANAGER, Wrapper.prototype);

/*
  Function-based helpers need to present with a constructor signature so that
  type parameters can be preserved when `helper()` is passed a generic function
  (this is particularly key for checking helper invocations with Glint).
  Accordingly, we define an abstract class and declaration merge it with the
  interface; this inherently provides an `abstract` constructor. Since it is
  `abstract`, it is not callable, which is important since end users should not
  be able to do `let myHelper = helper(someFn); new myHelper()`.
 */

/**
 * The type of a function-based helper.
 *
 * @note This is *not* user-constructible: it is exported only so that the type
 *   returned by the `helper` function can be named (and indeed can be exported
 *   like `export default helper(...)` safely).
 */
// Making `FunctionBasedHelper` an alias this way allows callers to name it in
// terms meaningful to *them*, while preserving the type behavior described on
// the `abstract class FunctionBasedHelperInstance` below.

// This abstract class -- specifically, its `protected abstract __concrete__`
// member -- prevents subclasses from doing `class X extends helper(..)`, since
// that is an error at runtime. While it is rare that people would type that, it
// is not impossible and we use this to give them early signal via the types for
// a behavior which will break (and in a somewhat inscrutable way!) at runtime.
//
// This is needful because we lie about what this actually is for Glint's sake:
// a function-based helper returns a `Factory<SimpleHelper>`, which is designed
// to be "opaque" from a consumer's POV, i.e. not user-callable or constructible
// but only useable in a template (or via `invokeHelper()` which also treats it
// as a fully opaque `object` from a type POV). But Glint needs a `Helper<S>` to
// make it work the same way as class-based helpers. (Note that this does not
// hold for plain functions as helpers, which it can handle distinctly.) This
// signature thus makes it so that the item is usable *as* a `Helper` in Glint,
// but without letting end users treat it as a helper class instance.

/**
  In many cases it is not necessary to use the full `Helper` class.
  The `helper` method create pure-function helpers without instances.
  For example:

  ```app/helpers/format-currency.js
  import { helper } from '@ember/component/helper';

  export default helper(function([cents], {currency}) {
    return `${currency}${cents * 0.01}`;
  });
  ```

  @static
  @param {Function} helper The helper function
  @method helper
  @for @ember/component/helper
  @public
  @since 1.13.0
*/
// This overload allows users to write types directly on the callback passed to
// the `helper` function and infer the resulting type correctly.

// This overload allows users to provide a `Signature` type explicitly at the
// helper definition site, e.g. `helper<Sig>((pos, named) => {...})`. **Note:**
// this overload must appear second, since TS' inference engine will not
// correctly infer the type of `S` here from the types on the supplied callback.

function helper$1(helperFn) {
  // SAFETY: this is completely lies, in two ways:
  //
  // 1. `Wrapper` is a `Factory<SimpleHelper<S>>`, but from the perspective of
  //    any external callers (i.e. Ember *users*), it is quite important that
  //    the `Factory` relationship be hidden, because it is not public API for
  //    an end user to call `.create()` on a helper created this way. Instead,
  //    we provide them an `abstract new` signature (which means it cannot be
  //    directly constructed by calling `new` on it) and which does not have the
  //    `.create()` signature on it anymore.
  //
  // 2. The produced type here ends up being a subtype of `Helper`, which is not
  //    strictly true. This is necessary for the sake of Glint, which provides
  //    its information by way of a "declaration merge" with `Helper<S>` in the
  //    case of items produced by `helper()`.
  //
  // Long-term, this entire construct can go away in favor of deprecating the
  // `helper()` invocation in favor of using plain functions.
  return new Wrapper(helperFn);
}

/**
@module @ember/template
*/

/**
  A wrapper around a string that has been marked as safe ("trusted"). **When
  rendered in HTML, Ember will not perform any escaping.**

  Note:

  1. This does not *make* the string safe; it means that some code in your
     application has *marked* it as safe using the `htmlSafe()` function.

  2. The only public API for getting a `SafeString` is calling `htmlSafe()`. It
     is *not* user-constructible.

  If a string contains user inputs or other untrusted data, you must sanitize
  the string before using the `htmlSafe` method. Otherwise your code is
  vulnerable to [Cross-Site Scripting][xss]. There are many open source
  sanitization libraries to choose from, both for front end and server-side
  sanitization.

  [xss]: https://owasp.org/www-community/attacks/DOM_Based_XSS

  ```javascript
  import { htmlSafe } from '@ember/template';

  let someTrustedOrSanitizedString = "<div>Hello!</div>"

  htmlSafe(someTrustedorSanitizedString);
  ```

  @for @ember/template
  @class SafeString
  @since 4.12.0
  @public
 */
class SafeString {
  __string;
  constructor(string) {
    this.__string = string;
  }

  /**
    Get the string back to use as a string.
     @public
    @method toString
    @returns {String} The string marked as trusted
   */
  toString() {
    return `${this.__string}`;
  }

  /**
    Get the wrapped string as HTML to use without escaping.
     @public
    @method toHTML
    @returns {String} the trusted string, without any escaping applied
   */
  toHTML() {
    return this.toString();
  }
}
const escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};
const possible = /[&<>"'`=]/;
const badChars = /[&<>"'`=]/g;
function escapeChar(chr) {
  return escape[chr];
}
function escapeExpression(string) {
  let s;
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (isHTMLSafe(string)) {
      return string.toHTML();
    } else if (string === null || string === undefined) {
      return '';
    } else if (!string) {
      return String(string);
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    s = String(string);
  } else {
    s = string;
  }
  if (!possible.test(s)) {
    return s;
  }

  // SAFETY: this is technically a lie, but it's a true lie as long as the
  // invariant it depends on is upheld: `escapeChar` will always return a string
  // as long as its input is one of the characters in `escape`, and it will only
  // be called if it matches one of the characters in the `badChar` regex, which
  // is hand-maintained to match the set escaped. (It would be nice if TS could
  // "see" into the regex to see how this works, but that'd be quite a lot of
  // extra fanciness.)
  return s.replace(badChars, escapeChar);
}

/**
  Use this method to indicate that a string should be rendered as HTML
  when the string is used in a template. To say this another way,
  strings marked with `htmlSafe` will not be HTML escaped.

  A word of warning -   The `htmlSafe` method does not make the string safe;
  it only tells the framework to treat the string as if it is safe to render
  as HTML. If a string contains user inputs or other untrusted
  data, you must sanitize the string before using the `htmlSafe` method.
  Otherwise your code is vulnerable to
  [Cross-Site Scripting](https://owasp.org/www-community/attacks/DOM_Based_XSS).
  There are many open source sanitization libraries to choose from,
  both for front end and server-side sanitization.

  ```javascript
  import { htmlSafe } from '@ember/template';

  const someTrustedOrSanitizedString = "<div>Hello!</div>"

  htmlSafe(someTrustedorSanitizedString)
  ```

  @method htmlSafe
  @for @ember/template
  @param str {String} The string to treat as trusted.
  @static
  @return {SafeString} A string that will not be HTML escaped by Handlebars.
  @public
*/
function htmlSafe(str) {
  if (str === null || str === undefined) {
    str = '';
  } else if (typeof str !== 'string') {
    str = String(str);
  }
  return new SafeString(str);
}

/**
  Detects if a string was decorated using `htmlSafe`.

  ```javascript
  import { htmlSafe, isHTMLSafe } from '@ember/template';

  let plainString = 'plain string';
  let safeString = htmlSafe('<div>someValue</div>');

  isHTMLSafe(plainString); // false
  isHTMLSafe(safeString);  // true
  ```

  @method isHTMLSafe
  @for @ember/template
  @static
  @return {Boolean} `true` if the string was decorated with `htmlSafe`, `false` otherwise.
  @public
*/
function isHTMLSafe(str) {
  return str !== null && typeof str === 'object' && 'toHTML' in str && typeof str.toHTML === 'function';
}

function instrumentationPayload$1(def) {
  // "main" used to be the outlet name, keeping it around for compatibility
  return {
    object: `${def.name}:main`
  };
}
const CAPABILITIES$1 = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: false,
  attributeHook: false,
  elementHook: false,
  createCaller: false,
  dynamicScope: true,
  updateHook: false,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
class OutletComponentManager {
  create(_owner, definition, _args, env, dynamicScope) {
    let parentStateRef = dynamicScope.get('outletState');
    let currentStateRef = definition.ref;
    dynamicScope.set('outletState', currentStateRef);
    let state = {
      self: createConstRef(definition.controller, 'this'),
      finalize: _instrumentStart('render.outlet', instrumentationPayload$1, definition)
    };
    if (env.debugRenderTree !== undefined) {
      state.outletBucket = {};
      let parentState = valueForRef(parentStateRef);
      let parentOwner = parentState && parentState.render && parentState.render.owner;
      let currentOwner = valueForRef(currentStateRef).render.owner;
      if (parentOwner && parentOwner !== currentOwner) {
        (isDevelopingApp() && !(currentOwner instanceof EmberEngineInstance) && assert('Expected currentOwner to be an EngineInstance', currentOwner instanceof EmberEngineInstance));
        let mountPoint = currentOwner.mountPoint;
        state.engine = currentOwner;
        if (mountPoint) {
          state.engineBucket = {
            mountPoint
          };
        }
      }
    }
    return state;
  }
  getDebugName({
    name
  }) {
    return name;
  }
  getDebugCustomRenderTree(definition, state, args) {
    let nodes = [];
    (isDevelopingApp() && !(state.outletBucket) && assert('[BUG] outletBucket must be set', state.outletBucket));
    nodes.push({
      bucket: state.outletBucket,
      type: 'outlet',
      // "main" used to be the outlet name, keeping it around for compatibility
      name: 'main',
      args: EMPTY_ARGS,
      instance: undefined,
      template: undefined
    });
    if (state.engineBucket) {
      nodes.push({
        bucket: state.engineBucket,
        type: 'engine',
        name: state.engineBucket.mountPoint,
        args: EMPTY_ARGS,
        instance: state.engine,
        template: undefined
      });
    }
    nodes.push({
      bucket: state,
      type: 'route-template',
      name: definition.name,
      args: args,
      instance: definition.controller,
      template: unwrapTemplate(definition.template).moduleName
    });
    return nodes;
  }
  getCapabilities() {
    return CAPABILITIES$1;
  }
  getSelf({
    self
  }) {
    return self;
  }
  didCreate() {}
  didUpdate() {}
  didRenderLayout(state) {
    state.finalize();
  }
  didUpdateLayout() {}
  getDestroyable() {
    return null;
  }
}
const OUTLET_MANAGER = new OutletComponentManager();
class OutletComponentDefinition {
  // handle is not used by this custom definition
  handle = -1;
  resolvedName;
  compilable;
  capabilities;
  constructor(state, manager = OUTLET_MANAGER) {
    this.state = state;
    this.manager = manager;
    let capabilities = manager.getCapabilities();
    this.capabilities = capabilityFlagsFrom(capabilities);
    this.compilable = capabilities.wrapped ? unwrapTemplate(state.template).asWrappedLayout() : unwrapTemplate(state.template).asLayout();
    this.resolvedName = state.name;
  }
}
function createRootOutlet(outletView) {
  return new OutletComponentDefinition(outletView.state);
}

class RootComponentManager extends CurlyComponentManager {
  component;
  constructor(component) {
    super();
    this.component = component;
  }
  create(_owner, _state, _args, {
    isInteractive
  }, dynamicScope) {
    let component = this.component;
    let finalizer = _instrumentStart('render.component', initialRenderInstrumentDetails, component);
    dynamicScope.view = component;
    let hasWrappedElement = component.tagName !== '';

    // We usually do this in the `didCreateElement`, but that hook doesn't fire for tagless components
    if (!hasWrappedElement) {
      if (isInteractive) {
        component.trigger('willRender');
      }
      component._transitionTo('hasElement');
      if (isInteractive) {
        component.trigger('willInsertElement');
      }
    }
    if (isDevelopingApp()) {
      processComponentInitializationAssertions(component, {});
    }
    let bucket = new ComponentStateBucket(component, null, CONSTANT_TAG, finalizer, hasWrappedElement, isInteractive);
    consumeTag(component[DIRTY_TAG]);
    return bucket;
  }
}

// ROOT is the top-level template it has nothing but one yield.
// it is supposed to have a dummy element
const ROOT_CAPABILITIES = {
  dynamicLayout: true,
  dynamicTag: true,
  prepareArgs: false,
  createArgs: false,
  attributeHook: true,
  elementHook: true,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: true,
  willDestroy: false,
  hasSubOwner: false
};
class RootComponentDefinition {
  // handle is not used by this custom definition
  handle = -1;
  resolvedName = '-top-level';
  state;
  manager;
  capabilities = capabilityFlagsFrom(ROOT_CAPABILITIES);
  compilable = null;
  constructor(component) {
    this.manager = new RootComponentManager(component);
    let factory = getFactoryFor(component);
    (isDevelopingApp() && !(factory !== undefined) && assert('missing factory for component', factory !== undefined));
    this.state = factory;
  }
}

/**
@module ember
*/
class EachInWrapper {
  constructor(inner) {
    this.inner = inner;
  }
}
const eachIn = internalHelper(({
  positional
}) => {
  const inner = positional[0];
  (isDevelopingApp() && !(inner) && assert('expected at least one positional arg', inner));
  return createComputeRef(() => {
    let iterable = valueForRef(inner);
    consumeTag(tagForObject(iterable));
    if (isProxy(iterable)) {
      // this is because the each-in doesn't actually get(proxy, 'key') but bypasses it
      // and the proxy's tag is lazy updated on access
      iterable = contentFor(iterable);
    }
    return new EachInWrapper(iterable);
  });
});

function toIterator(iterable) {
  if (iterable instanceof EachInWrapper) {
    return toEachInIterator(iterable.inner);
  } else {
    return toEachIterator(iterable);
  }
}
function toEachInIterator(iterable) {
  if (!isIndexable(iterable)) {
    return null;
  }
  if (Array.isArray(iterable) || isEmberArray(iterable)) {
    return ObjectIterator.fromIndexable(iterable);
  } else if (isNativeIterable(iterable)) {
    return MapLikeNativeIterator.from(iterable);
  } else if (hasForEach(iterable)) {
    return ObjectIterator.fromForEachable(iterable);
  } else {
    return ObjectIterator.fromIndexable(iterable);
  }
}
function toEachIterator(iterable) {
  if (!isObject(iterable)) {
    return null;
  }
  if (Array.isArray(iterable)) {
    return ArrayIterator.from(iterable);
  } else if (isEmberArray(iterable)) {
    return EmberArrayIterator.from(iterable);
  } else if (isNativeIterable(iterable)) {
    return ArrayLikeNativeIterator.from(iterable);
  } else if (hasForEach(iterable)) {
    return ArrayIterator.fromForEachable(iterable);
  } else {
    return null;
  }
}
class BoundedIterator {
  position = 0;
  constructor(length) {
    this.length = length;
  }
  isEmpty() {
    return false;
  }
  memoFor(position) {
    return position;
  }
  next() {
    let {
      length,
      position
    } = this;
    if (position >= length) {
      return null;
    }
    let value = this.valueFor(position);
    let memo = this.memoFor(position);
    this.position++;
    return {
      value,
      memo
    };
  }
}
class ArrayIterator extends BoundedIterator {
  static from(iterable) {
    return iterable.length > 0 ? new this(iterable) : null;
  }
  static fromForEachable(object) {
    let array = [];
    object.forEach(item => array.push(item));
    return this.from(array);
  }
  constructor(array) {
    super(array.length);
    this.array = array;
  }
  valueFor(position) {
    return this.array[position];
  }
}
class EmberArrayIterator extends BoundedIterator {
  static from(iterable) {
    return iterable.length > 0 ? new this(iterable) : null;
  }
  constructor(array) {
    super(array.length);
    this.array = array;
  }
  valueFor(position) {
    return objectAt(this.array, position);
  }
}
class ObjectIterator extends BoundedIterator {
  static fromIndexable(obj) {
    let keys = Object.keys(obj);
    if (keys.length === 0) {
      return null;
    } else {
      let values = [];
      for (let key of keys) {
        let value;
        value = obj[key];

        // Add the tag of the returned value if it is an array, since arrays
        // should always cause updates if they are consumed and then changed
        if (isTracking()) {
          consumeTag(tagFor(obj, key));
          if (Array.isArray(value)) {
            consumeTag(tagFor(value, '[]'));
          }
        }
        values.push(value);
      }
      return new this(keys, values);
    }
  }
  static fromForEachable(obj) {
    let keys = [];
    let values = [];
    let length = 0;
    let isMapLike = false;

    // Not using an arrow function here so we can get an accurate `arguments`
    obj.forEach(function (value, key) {
      isMapLike = isMapLike || arguments.length >= 2;
      if (isMapLike) {
        keys.push(key);
      }
      values.push(value);
      length++;
    });
    if (length === 0) {
      return null;
    } else if (isMapLike) {
      return new this(keys, values);
    } else {
      return new ArrayIterator(values);
    }
  }
  constructor(keys, values) {
    super(values.length);
    this.keys = keys;
    this.values = values;
  }
  valueFor(position) {
    return this.values[position];
  }
  memoFor(position) {
    return this.keys[position];
  }
}
class NativeIterator {
  static from(iterable) {
    let iterator = iterable[Symbol.iterator]();
    let result = iterator.next();
    let {
      done
    } = result;
    if (done) {
      return null;
    } else {
      return new this(iterator, result);
    }
  }
  position = 0;
  constructor(iterable, result) {
    this.iterable = iterable;
    this.result = result;
  }
  isEmpty() {
    return false;
  }
  next() {
    let {
      iterable,
      result,
      position
    } = this;
    if (result.done) {
      return null;
    }
    let value = this.valueFor(result, position);
    let memo = this.memoFor(result, position);
    this.position++;
    this.result = iterable.next();
    return {
      value,
      memo
    };
  }
}
class ArrayLikeNativeIterator extends NativeIterator {
  valueFor(result) {
    return result.value;
  }
  memoFor(_result, position) {
    return position;
  }
}
class MapLikeNativeIterator extends NativeIterator {
  valueFor(result) {
    return result.value[1];
  }
  memoFor(result) {
    return result.value[0];
  }
}
function hasForEach(value) {
  return value != null && typeof value['forEach'] === 'function';
}
function isNativeIterable(value) {
  return value != null && typeof value[Symbol.iterator] === 'function';
}
function isIndexable(value) {
  return value !== null && (typeof value === 'object' || typeof value === 'function');
}

function toBool(predicate) {
  if (isProxy(predicate)) {
    consumeTag(tagForProperty(predicate, 'content'));
    return Boolean(get(predicate, 'isTruthy'));
  } else if (isArray(predicate)) {
    consumeTag(tagForProperty(predicate, '[]'));
    return predicate.length !== 0;
  } else if (isHTMLSafe(predicate)) {
    return Boolean(predicate.toString());
  } else {
    return Boolean(predicate);
  }
}

setGlobalContext({
  FEATURES: {
    DEFAULT_HELPER_MANAGER: true
  },
  scheduleRevalidate() {
    _backburner.ensureInstance();
  },
  toBool,
  toIterator,
  getProp: _getProp,
  setProp: _setProp,
  getPath: get,
  setPath: set,
  scheduleDestroy(destroyable, destructor) {
    schedule('actions', null, destructor, destroyable);
  },
  scheduleDestroyed(finalizeDestructor) {
    schedule('destroy', null, finalizeDestructor);
  },
  warnIfStyleNotTrusted(value) {
    (isDevelopingApp() && warn(constructStyleDeprecationMessage(String(value)), (() => {
      if (value === null || value === undefined || isHTMLSafe(value)) {
        return true;
      }
      return false;
    })(), {
      id: 'ember-htmlbars.style-xss-warning'
    }));
  },
  assert(test, msg, options) {
    if (isDevelopingApp()) {
      let id = options?.id;
      let override = VM_ASSERTION_OVERRIDES.filter(o => o.id === id)[0];
      (isDevelopingApp() && !(test) && assert(override?.message ?? msg, test));
    }
  },
  deprecate(msg, test, options) {
    if (isDevelopingApp()) {
      let {
        id
      } = options;
      if (id === 'argument-less-helper-paren-less-invocation') {
        throw new Error(`A resolved helper cannot be passed as a named argument as the syntax is ` + `ambiguously a pass-by-reference or invocation. Use the ` + `\`{{helper 'foo-helper}}\` helper to pass by reference or explicitly ` + `invoke the helper with parens: \`{{(fooHelper)}}\`.`);
      }
      let override = VM_DEPRECATION_OVERRIDES.filter(o => o.id === id)[0];
      if (!override) throw new Error(`deprecation override for ${id} not found`);

      // allow deprecations to be disabled in the VM_DEPRECATION_OVERRIDES array below
      if (!override.disabled) {
        (isDevelopingApp() && !(Boolean(test)) && deprecate(override.message ?? msg, Boolean(test), override));
      }
    }
  }
});
if (isDevelopingApp()) {
  debug?.setTrackingTransactionEnv?.({
    debugMessage(obj, keyName) {
      let dirtyString = keyName ? `\`${keyName}\` on \`${getDebugName?.(obj)}\`` : `\`${getDebugName?.(obj)}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }
  });
}

///////////

// VM Assertion/Deprecation overrides

const VM_DEPRECATION_OVERRIDES = [{
  id: 'setting-on-hash',
  until: '4.4.0',
  for: 'ember-source',
  since: {
    available: '3.28.0',
    enabled: '3.28.0'
  }
}];
const VM_ASSERTION_OVERRIDES = [];

///////////

// Define environment delegate

class EmberEnvironmentDelegate {
  enableDebugTooling = ENV._DEBUG_RENDER_TREE;
  constructor(owner, isInteractive) {
    this.owner = owner;
    this.isInteractive = isInteractive;
  }
  onTransactionCommit() {}
}

/**
@module ember
*/
const disallowDynamicResolution = internalHelper(({
  positional,
  named
}) => {
  const nameOrValueRef = positional[0];
  (isDevelopingApp() && !(positional.length === 1 && nameOrValueRef) && assert(`[BUG] wrong number of positional arguments, expecting 1, got ${positional.length}`, positional.length === 1 && nameOrValueRef));
  let typeRef = named['type'];
  let locRef = named['loc'];
  let originalRef = named['original'];
  (isDevelopingApp() && !(typeRef) && assert(`[BUG] expecting \`type\` named argument`, typeRef));
  (isDevelopingApp() && !(locRef) && assert(`[BUG] expecting \`loc\` named argument`, locRef));
  (isDevelopingApp() && !(originalRef) && assert(`[BUG] expecting \`original\` named argument`, originalRef)); // Bug: why do these fail?
  // assert('[BUG] expecting a string literal for the `type` argument', isConstRef(typeRef));
  // assert('[BUG] expecting a string literal for the `loc` argument', isConstRef(locRef));
  // assert('[BUG] expecting a string literal for the `original` argument', isConstRef(originalRef));
  const type = valueForRef(typeRef);
  const loc = valueForRef(locRef);
  const original = valueForRef(originalRef);
  (isDevelopingApp() && !(typeof type === 'string') && assert('[BUG] expecting a string literal for the `type` argument', typeof type === 'string'));
  (isDevelopingApp() && !(typeof loc === 'string') && assert('[BUG] expecting a string literal for the `loc` argument', typeof loc === 'string'));
  (isDevelopingApp() && !(typeof original === 'string') && assert('[BUG] expecting a string literal for the `original` argument', typeof original === 'string'));
  return createComputeRef(() => {
    let nameOrValue = valueForRef(nameOrValueRef);
    (isDevelopingApp() && !(typeof nameOrValue !== 'string') && assert(`Passing a dynamic string to the \`(${type})\` keyword is disallowed. ` + `(You specified \`(${type} ${original})\` and \`${original}\` evaluated into "${nameOrValue}".) ` + `This ensures we can statically analyze the template and determine which ${type}s are used. ` + `If the ${type} name is always the same, use a string literal instead, i.e. \`(${type} "${nameOrValue}")\`. ` + `Otherwise, import the ${type}s into JavaScript and pass them directly. ` + 'See https://github.com/emberjs/rfcs/blob/master/text/0496-handlebars-strict-mode.md#4-no-dynamic-resolution for details. ' + loc, typeof nameOrValue !== 'string'));
    return nameOrValue;
  });
});

let helper;
if (isDevelopingApp()) {
  helper = args => {
    const inner = args.positional[0];
    (isDevelopingApp() && !(inner) && assert('expected at least one positional arg', inner));
    return createComputeRef(() => {
      let value = valueForRef(inner);
      (isDevelopingApp() && !(value !== null && value !== undefined) && assert('You cannot pass a null or undefined destination element to in-element', value !== null && value !== undefined));
      return value;
    });
  };
} else {
  helper = args => {
    let arg = args.positional[0];
    (isDevelopingApp() && !(arg) && assert('expected at least one positional arg', arg));
    return arg;
  };
}
const inElementNullCheckHelper = internalHelper(helper);

const normalizeClassHelper = internalHelper(({
  positional
}) => {
  return createComputeRef(() => {
    let classNameArg = positional[0];
    let valueArg = positional[1];
    (isDevelopingApp() && !(classNameArg && valueArg) && assert('expected at least two positional args', classNameArg && valueArg));
    let classNameParts = valueForRef(classNameArg).split('.');
    let className = classNameParts[classNameParts.length - 1];
    (isDevelopingApp() && !(className) && assert('has className', className)); // Always at least one split result
    let value = valueForRef(valueArg);
    if (value === true) {
      return dasherize(className);
    } else if (!value && value !== 0) {
      return '';
    } else {
      return String(value);
    }
  });
});

/**
  @module ember
*/

const resolve = internalHelper(({
  positional
}, owner) => {
  // why is this allowed to be undefined in the first place?
  (isDevelopingApp() && !(owner) && assert('[BUG] missing owner', owner));
  (isDevelopingApp() && !(positional.length === 1) && assert(`[BUG] wrong number of positional arguments, expecting 1, got ${positional.length}`, positional.length === 1));
  let fullNameRef = positional[0];
  (isDevelopingApp() && !(fullNameRef && isConstRef(fullNameRef)) && assert('[BUG] expecting a string literal as argument', fullNameRef && isConstRef(fullNameRef)));
  let fullName = valueForRef(fullNameRef);
  (isDevelopingApp() && !(typeof fullName === 'string') && assert('[BUG] expecting a string literal as argument', typeof fullName === 'string'));
  (isDevelopingApp() && !((s => s.split(':').length === 2)(fullName)) && assert('[BUG] expecting a valid full name', (s => s.split(':').length === 2)(fullName)));
  if (isDevelopingApp()) {
    let [type, name] = fullName.split(':');
    (isDevelopingApp() && !(owner.hasRegistration(fullName)) && assert(`Attempted to invoke \`(-resolve "${fullName}")\`, but ${name} was not a valid ${type} name.`, owner.hasRegistration(fullName)));
  }
  return createConstRef(owner.factoryFor(fullName)?.class, `(-resolve "${fullName}")`);
});

/**
@module ember
*/
const trackArray = internalHelper(({
  positional
}) => {
  const inner = positional[0];
  (isDevelopingApp() && !(inner) && assert('expected at least one positional arg', inner));
  return createComputeRef(() => {
    let iterable = valueForRef(inner);
    if (isObject(iterable)) {
      consumeTag(tagForProperty(iterable, '[]'));
    }
    return iterable;
  });
});

/**
@module ember
*/
const mut = internalHelper(({
  positional
}) => {
  let ref = positional[0];
  (isDevelopingApp() && !(ref) && assert('expected at least one positional arg', ref)); // TODO: Improve this error message. This covers at least two distinct
  // cases:
  //
  // 1. (mut "not a path") – passing a literal, result from a helper
  //    invocation, etc
  //
  // 2. (mut receivedValue) – passing a value received from the caller
  //    that was originally derived from a literal, result from a helper
  //    invocation, etc
  //
  // This message is alright for the first case, but could be quite
  // confusing for the second case.
  (isDevelopingApp() && !(isUpdatableRef(ref)) && assert('You can only pass a path to mut', isUpdatableRef(ref)));
  return createInvokableRef(ref);
});

/**
@module ember
*/

const readonly = internalHelper(({
  positional
}) => {
  let firstArg = positional[0];
  (isDevelopingApp() && !(firstArg) && assert('has first arg', firstArg));
  return createReadOnlyRef(firstArg);
});

/**
@module ember
*/

const unbound = internalHelper(({
  positional,
  named
}) => {
  (isDevelopingApp() && !(positional.length === 1 && Object.keys(named).length === 0) && assert('unbound helper cannot be called with multiple params or hash params', positional.length === 1 && Object.keys(named).length === 0));
  return createUnboundRef(valueForRef(positional[0]), '(result of an `unbound` helper)');
});

/**
@module ember
*/

const uniqueId = internalHelper(() => {
  // SAFETY: glimmer-vm should change the signature of createUnboundRef to use a generic
  //         so that the type param to `Reference<?>` can infer from the first argument.
  //
  // NOTE: constRef is an optimization so we don't let the VM create extra wrappers,
  //       tracking frames, etc.
  return createConstRef(uniqueId$1(), 'unique-id');
});

// From https://gist.github.com/selfish/fef2c0ba6cdfe07af76e64cecd74888b
//
// This code should be reasonably fast, and provide a unique value every time
// it's called, which is what we need here. It produces a string formatted as a
// standard UUID, which avoids accidentally turning Ember-specific
// implementation details into an intimate API. It also ensures that the UUID
// always starts with a letter, to avoid creating invalid IDs with a numeric
// digit at the start.
function uniqueId$1() {
  // @ts-expect-error this one-liner abuses weird JavaScript semantics that
  // TypeScript (legitimately) doesn't like, but they're nonetheless valid and
  // specced.
  return ([3e7] + -1e3 + -4e3 + -2e3 + -1e11).replace(/[0-3]/g, a => (a * 4 ^ Math.random() * 16 >> (a & 2)).toString(16));
}

const MODIFIERS = ['alt', 'shift', 'meta', 'ctrl'];
const POINTER_EVENT_TYPE_REGEX = /^click|mouse|touch/;
function isAllowedEvent(event, allowedKeys) {
  if (allowedKeys === null || allowedKeys === undefined) {
    if (POINTER_EVENT_TYPE_REGEX.test(event.type)) {
      return isSimpleClick(event);
    } else {
      allowedKeys = '';
    }
  }
  if (allowedKeys.indexOf('any') >= 0) {
    return true;
  }
  for (let i = 0; i < MODIFIERS.length; i++) {
    if (event[MODIFIERS[i] + 'Key'] && allowedKeys.indexOf(MODIFIERS[i]) === -1) {
      return false;
    }
  }
  return true;
}
let ActionHelper = {
  // registeredActions is re-exported for compatibility with older plugins
  // that were using this undocumented API.
  registeredActions: ActionManager.registeredActions,
  registerAction(actionState) {
    let {
      actionId
    } = actionState;
    ActionManager.registeredActions[actionId] = actionState;
    return actionId;
  },
  unregisterAction(actionState) {
    let {
      actionId
    } = actionState;
    delete ActionManager.registeredActions[actionId];
  }
};
class ActionState {
  element;
  owner;
  actionId;
  actionName;
  actionArgs;
  namedArgs;
  positional;
  implicitTarget;
  eventName;
  tag = createUpdatableTag();
  constructor(element, owner, actionId, actionArgs, namedArgs, positionalArgs) {
    this.element = element;
    this.owner = owner;
    this.actionId = actionId;
    this.actionArgs = actionArgs;
    this.namedArgs = namedArgs;
    this.positional = positionalArgs;
    this.eventName = this.getEventName();
    registerDestructor(this, () => ActionHelper.unregisterAction(this));
  }
  getEventName() {
    let {
      on
    } = this.namedArgs;
    return on !== undefined ? valueForRef(on) : 'click';
  }
  getActionArgs() {
    let result = new Array(this.actionArgs.length);
    for (let i = 0; i < this.actionArgs.length; i++) {
      result[i] = valueForRef(this.actionArgs[i]);
    }
    return result;
  }
  getTarget() {
    let {
      implicitTarget,
      namedArgs
    } = this;
    let {
      target
    } = namedArgs;
    return target !== undefined ? valueForRef(target) : valueForRef(implicitTarget);
  }
  handler(event) {
    let {
      actionName,
      namedArgs
    } = this;
    let {
      bubbles,
      preventDefault,
      allowedKeys
    } = namedArgs;
    let bubblesVal = bubbles !== undefined ? valueForRef(bubbles) : undefined;
    let preventDefaultVal = preventDefault !== undefined ? valueForRef(preventDefault) : undefined;
    let allowedKeysVal = allowedKeys !== undefined ? valueForRef(allowedKeys) : undefined;
    let target = this.getTarget();
    let shouldBubble = bubblesVal !== false;
    if (!isAllowedEvent(event, allowedKeysVal)) {
      return true;
    }
    if (preventDefaultVal !== false) {
      event.preventDefault();
    }
    if (!shouldBubble) {
      event.stopPropagation();
    }
    join(() => {
      let args = this.getActionArgs();
      let payload = {
        args,
        target,
        name: null
      };
      if (isInvokableRef(actionName)) {
        flaggedInstrument('interaction.ember-action', payload, () => {
          updateRef(actionName, args[0]);
        });
        return;
      }
      if (typeof actionName === 'function') {
        flaggedInstrument('interaction.ember-action', payload, () => {
          actionName.apply(target, args);
        });
        return;
      }
      payload.name = actionName;
      if (target.send) {
        flaggedInstrument('interaction.ember-action', payload, () => {
          target.send.apply(target, [actionName, ...args]);
        });
      } else {
        (isDevelopingApp() && !(typeof target[actionName] === 'function') && assert(`The action '${actionName}' did not exist on ${target}`, typeof target[actionName] === 'function'));
        flaggedInstrument('interaction.ember-action', payload, () => {
          target[actionName].apply(target, args);
        });
      }
    });
    return shouldBubble;
  }
}
class ActionModifierManager {
  create(owner, element, _state, {
    named,
    positional
  }) {
    let actionArgs = [];
    // The first two arguments are (1) `this` and (2) the action name.
    // Everything else is a param.
    for (let i = 2; i < positional.length; i++) {
      actionArgs.push(positional[i]);
    }
    let actionId = uuid();
    return new ActionState(element, owner, actionId, actionArgs, named, positional);
  }
  getDebugInstance() {
    return null;
  }
  getDebugName() {
    return 'action';
  }
  install(actionState) {
    deprecateUntil(`Usage of the \`{{action}}\` modifier is deprecated. Migrate to native functions and function invocation.`, DEPRECATIONS.DEPRECATE_TEMPLATE_ACTION);
    let {
      element,
      actionId,
      positional
    } = actionState;
    let actionName;
    let actionNameRef;
    let implicitTarget;
    if (positional.length > 1) {
      implicitTarget = positional[0];
      actionNameRef = positional[1];
      if (isInvokableRef(actionNameRef)) {
        actionName = actionNameRef;
      } else {
        actionName = valueForRef(actionNameRef);
        if (isDevelopingApp()) {
          let actionPath = actionNameRef.debugLabel;
          let actionPathParts = actionPath.split('.');
          let actionLabel = actionPathParts[actionPathParts.length - 1];
          (isDevelopingApp() && !(typeof actionName === 'string' || typeof actionName === 'function') && assert('You specified a quoteless path, `' + actionPath + '`, to the ' + '{{action}} helper which did not resolve to an action name (a ' + 'string). Perhaps you meant to use a quoted actionName? (e.g. ' + '{{action "' + actionLabel + '"}}).', typeof actionName === 'string' || typeof actionName === 'function'));
        }
      }
    }
    actionState.actionName = actionName;
    actionState.implicitTarget = implicitTarget;
    this.ensureEventSetup(actionState);
    ActionHelper.registerAction(actionState);
    element.setAttribute('data-ember-action', '');
    element.setAttribute(`data-ember-action-${actionId}`, String(actionId));
  }
  update(actionState) {
    let {
      positional
    } = actionState;
    let actionNameRef = positional[1];
    (isDevelopingApp() && !(actionNameRef) && assert('Expected at least one positional arg', actionNameRef));
    if (!isInvokableRef(actionNameRef)) {
      actionState.actionName = valueForRef(actionNameRef);
    }
    let newEventName = actionState.getEventName();
    if (newEventName !== actionState.eventName) {
      this.ensureEventSetup(actionState);
      actionState.eventName = actionState.getEventName();
    }
  }
  ensureEventSetup(actionState) {
    let dispatcher = actionState.owner.lookup('event_dispatcher:main');
    (isDevelopingApp() && !(dispatcher instanceof EventDispatcher) && assert('Expected dispatcher to be an EventDispatcher', dispatcher instanceof EventDispatcher));
    dispatcher?.setupHandlerForEmberEvent(actionState.eventName);
  }
  getTag(actionState) {
    return actionState.tag;
  }
  getDestroyable(actionState) {
    return actionState;
  }
}
const ACTION_MODIFIER_MANAGER = new ActionModifierManager();
const actionModifier = setInternalModifierManager(ACTION_MODIFIER_MANAGER, {});

const CAPABILITIES = {
  dynamicLayout: true,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: true
};
class MountManager {
  getDynamicLayout(state) {
    let templateFactory = state.engine.lookup('template:application');
    return unwrapTemplate(templateFactory(state.engine)).asLayout();
  }
  getCapabilities() {
    return CAPABILITIES;
  }
  getOwner(state) {
    return state.engine;
  }
  create(owner, {
    name
  }, args, env) {
    // TODO
    // mount is a runtime helper, this shouldn't use dynamic layout
    // we should resolve the engine app template in the helper
    // it also should use the owner that looked up the mount helper.
    (isDevelopingApp() && !(owner instanceof EmberEngineInstance) && assert('Expected owner to be an EngineInstance', owner instanceof EmberEngineInstance));
    let engine = owner.buildChildEngineInstance(name);
    engine.boot();
    let applicationFactory = engine.factoryFor(`controller:application`);
    let controllerFactory = applicationFactory || generateControllerFactory(engine, 'application');
    let controller;
    let self;
    let bucket;
    let modelRef;
    if (args.named.has('model')) {
      modelRef = args.named.get('model');
    }
    if (modelRef === undefined) {
      controller = controllerFactory.create();
      self = createConstRef(controller, 'this');
      bucket = {
        engine,
        controller,
        self,
        modelRef
      };
    } else {
      let model = valueForRef(modelRef);
      controller = controllerFactory.create({
        model
      });
      self = createConstRef(controller, 'this');
      bucket = {
        engine,
        controller,
        self,
        modelRef
      };
    }
    if (env.debugRenderTree) {
      associateDestroyableChild(engine, controller);
    }
    return bucket;
  }
  getDebugName({
    name
  }) {
    return name;
  }
  getDebugCustomRenderTree(definition, state, args, templateModuleName) {
    return [{
      bucket: state.engine,
      instance: state.engine,
      type: 'engine',
      name: definition.name,
      args
    }, {
      bucket: state.controller,
      instance: state.controller,
      type: 'route-template',
      name: 'application',
      args,
      template: templateModuleName
    }];
  }
  getSelf({
    self
  }) {
    return self;
  }
  getDestroyable(bucket) {
    return bucket.engine;
  }
  didCreate() {}
  didUpdate() {}
  didRenderLayout() {}
  didUpdateLayout() {}
  update(bucket) {
    let {
      controller,
      modelRef
    } = bucket;
    if (modelRef !== undefined) {
      controller.set('model', valueForRef(modelRef));
    }
  }
}
const MOUNT_MANAGER = new MountManager();
class MountDefinition {
  // handle is not used by this custom definition
  handle = -1;
  state;
  manager = MOUNT_MANAGER;
  compilable = null;
  capabilities = capabilityFlagsFrom(CAPABILITIES);
  constructor(resolvedName) {
    this.resolvedName = resolvedName;
    this.state = {
      name: resolvedName
    };
  }
}

/**
@module ember
*/

const mountHelper = internalHelper((args, owner) => {
  (isDevelopingApp() && !(owner) && assert('{{mount}} must be used within a component that has an owner', owner));
  let nameRef = args.positional[0];
  let captured;
  (isDevelopingApp() && !(args.positional.length === 1) && assert('You can only pass a single positional argument to the {{mount}} helper, e.g. {{mount "chat-engine"}}.', args.positional.length === 1));
  if (isDevelopingApp() && args.named) {
    let keys = Object.keys(args.named);
    let extra = keys.filter(k => k !== 'model');
    (isDevelopingApp() && !(extra.length === 0) && assert('You can only pass a `model` argument to the {{mount}} helper, ' + 'e.g. {{mount "profile-engine" model=this.profile}}. ' + `You passed ${extra.join(',')}.`, extra.length === 0));
  }
  captured = createCapturedArgs(args.named, EMPTY_POSITIONAL);
  let lastName, lastDef;
  return createComputeRef(() => {
    let name = valueForRef(nameRef);
    if (typeof name === 'string') {
      if (lastName === name) {
        return lastDef;
      }
      (isDevelopingApp() && !(owner.hasRegistration(`engine:${name}`)) && assert(`You used \`{{mount '${name}'}}\`, but the engine '${name}' can not be found.`, owner.hasRegistration(`engine:${name}`)));
      lastName = name;
      lastDef = curry(CurriedTypes.Component, new MountDefinition(name), owner, captured, true);
      return lastDef;
    } else {
      (isDevelopingApp() && !(name === null || name === undefined) && assert(`Invalid engine name '${name}' specified, engine name must be either a string, null or undefined.`, name === null || name === undefined));
      lastDef = null;
      lastName = null;
      return null;
    }
  });
});

const outletHelper = internalHelper((_args, owner, scope) => {
  (isDevelopingApp() && !(owner) && assert('Expected owner to be present, {{outlet}} requires an owner', owner));
  (isDevelopingApp() && !(scope) && assert('Expected dynamic scope to be present. You may have attempted to use the {{outlet}} keyword dynamically. This keyword cannot be used dynamically.', scope));
  let outletRef = createComputeRef(() => {
    let state = valueForRef(scope.get('outletState'));
    return state?.outlets?.main;
  });
  let lastState = null;
  let definition = null;
  return createComputeRef(() => {
    let outletState = valueForRef(outletRef);
    let state = stateFor(outletRef, outletState);
    if (!validate(state, lastState)) {
      lastState = state;
      if (state !== null) {
        let named = dict();

        // Create a ref for the model
        let modelRef = childRefFromParts(outletRef, ['render', 'model']);

        // Store the value of the model
        let model = valueForRef(modelRef);

        // Create a compute ref which we pass in as the `{{@model}}` reference
        // for the outlet. This ref will update and return the value of the
        // model _until_ the outlet itself changes. Once the outlet changes,
        // dynamic scope also changes, and so the original model ref would not
        // provide the correct updated value. So we stop updating and return
        // the _last_ model value for that outlet.
        named['model'] = createComputeRef(() => {
          if (lastState === state) {
            model = valueForRef(modelRef);
          }
          return model;
        });
        if (isDevelopingApp()) {
          named['model'] = createDebugAliasRef('@model', named['model']);
        }
        let args = createCapturedArgs(named, EMPTY_POSITIONAL);
        definition = curry(CurriedTypes.Component, new OutletComponentDefinition(state), outletState?.render?.owner ?? owner, args, true);
      } else {
        definition = null;
      }
    }
    return definition;
  });
});
function stateFor(ref, outlet) {
  if (outlet === undefined) return null;
  let render = outlet.render;
  if (render === undefined) return null;
  let template = render.template;
  if (template === undefined) return null;
  if (isTemplateFactory(template)) {
    template = template(render.owner);
    if (isDevelopingApp()) {
      let message = 'The `template` property of `OutletState` should be a ' + '`Template` rather than a `TemplateFactory`. This is known to be a ' + "problem in older versions of `@ember/test-helpers`. If you haven't " + 'done so already, try upgrading to the latest version.\n\n';
      if (template.result === 'ok' && typeof template.moduleName === 'string') {
        message += 'The offending template has a moduleName `' + template.moduleName + '`, which might be helpful for identifying ' + 'source of this issue.\n\n';
      }
      message += 'Please note that `OutletState` is a private API in Ember.js ' + "and not meant to be used outside of the framework's internal code.";
      (isDevelopingApp() && !(false) && deprecate(message, false, {
        id: 'outlet-state-template-factory',
        until: '5.9.0',
        for: 'ember-source',
        since: {
          available: '5.6.0',
          enabled: '5.6.0'
        }
      }));
    }
  }
  return {
    ref,
    name: render.name,
    template,
    controller: render.controller,
    model: render.model
  };
}
function validate(state, lastState) {
  if (state === null) {
    return lastState === null;
  }
  if (lastState === null) {
    return false;
  }
  return state.template === lastState.template && state.controller === lastState.controller;
}

function instrumentationPayload(name) {
  return {
    object: `component:${name}`
  };
}
function componentFor(name, owner) {
  let fullName = `component:${name}`;
  return owner.factoryFor(fullName) || null;
}
function layoutFor(name, owner, options) {
  if (DEPRECATIONS.DEPRECATE_COMPONENT_TEMPLATE_RESOLVING.isRemoved) {
    return null;
  }
  let templateFullName = `template:components/${name}`;
  let result = owner.lookup(templateFullName, options) || null;
  if (result) {
    deprecateUntil(`Components with separately resolved templates are deprecated. Migrate to either co-located js/ts + hbs files or to gjs/gts. Tried to lookup '${templateFullName}'.`, DEPRECATIONS.DEPRECATE_COMPONENT_TEMPLATE_RESOLVING);
  }
  return result;
}
function lookupComponentPair(owner, name, options) {
  let component = componentFor(name, owner);
  if (isFactory(component) && component.class) {
    let layout = getComponentTemplate(component.class);
    if (layout !== undefined) {
      return {
        component,
        layout
      };
    }
  }
  let layout = layoutFor(name, owner, options);
  if (component === null && layout === null) {
    return null;
  } else {
    return {
      component,
      layout
    };
  }
}
const BUILTIN_KEYWORD_HELPERS = {
  action,
  mut,
  readonly,
  unbound,
  '-hash': hash,
  '-each-in': eachIn,
  '-normalize-class': normalizeClassHelper,
  '-resolve': resolve,
  '-track-array': trackArray,
  '-mount': mountHelper,
  '-outlet': outletHelper,
  '-in-el-null': inElementNullCheckHelper
};
const BUILTIN_HELPERS = {
  ...BUILTIN_KEYWORD_HELPERS,
  array,
  concat,
  fn,
  get: get$1,
  hash,
  'unique-id': uniqueId
};
if (isDevelopingApp()) {
  BUILTIN_HELPERS['-disallow-dynamic-resolution'] = disallowDynamicResolution;
} else {
  // Bug: this may be a quirk of our test setup?
  // In prod builds, this is a no-op helper and is unused in practice. We shouldn't need
  // to add it at all, but the current test build doesn't produce a "prod compiler", so
  // we ended up running the debug-build for the template compliler in prod tests. Once
  // that is fixed, this can be removed. For now, this allows the test to work and does
  // not really harm anything, since it's just a no-op pass-through helper and the bytes
  // has to be included anyway. In the future, perhaps we can avoid the latter by using
  // `import(...)`?
  BUILTIN_HELPERS['-disallow-dynamic-resolution'] = disallowDynamicResolution;
}
const BUILTIN_KEYWORD_MODIFIERS = {
  action: actionModifier
};
const BUILTIN_MODIFIERS = {
  ...BUILTIN_KEYWORD_MODIFIERS,
  on: on$1
};
const CLASSIC_HELPER_MANAGER_ASSOCIATED = new WeakSet();
class ResolverImpl {
  componentDefinitionCache = new Map();
  lookupPartial() {
    return null;
  }
  lookupHelper(name, owner) {
    (isDevelopingApp() && !(!(BUILTIN_HELPERS[name] && owner.hasRegistration(`helper:${name}`))) && assert(`You attempted to overwrite the built-in helper "${name}" which is not allowed. Please rename the helper.`, !(BUILTIN_HELPERS[name] && owner.hasRegistration(`helper:${name}`))));
    let helper = BUILTIN_HELPERS[name];
    if (helper !== undefined) {
      return helper;
    }
    let factory = owner.factoryFor(`helper:${name}`);
    if (factory === undefined) {
      return null;
    }
    let definition = factory.class;
    if (definition === undefined) {
      return null;
    }
    if (typeof definition === 'function' && isClassicHelper(definition)) {
      // For classic class based helpers, we need to pass the factoryFor result itself rather
      // than the raw value (`factoryFor(...).class`). This is because injections are already
      // bound in the factoryFor result, including type-based injections

      if (isDevelopingApp()) {
        // In DEBUG we need to only set the associated value once, otherwise
        // we'll trigger an assertion
        if (!CLASSIC_HELPER_MANAGER_ASSOCIATED.has(factory)) {
          CLASSIC_HELPER_MANAGER_ASSOCIATED.add(factory);
          setInternalHelperManager(CLASSIC_HELPER_MANAGER, factory);
        }
      } else {
        setInternalHelperManager(CLASSIC_HELPER_MANAGER, factory);
      }
      return factory;
    }
    return definition;
  }
  lookupBuiltInHelper(name) {
    return BUILTIN_KEYWORD_HELPERS[name] ?? null;
  }
  lookupModifier(name, owner) {
    let builtin = BUILTIN_MODIFIERS[name];
    if (builtin !== undefined) {
      return builtin;
    }
    let modifier = owner.factoryFor(`modifier:${name}`);
    if (modifier === undefined) {
      return null;
    }
    return modifier.class || null;
  }
  lookupBuiltInModifier(name) {
    return BUILTIN_KEYWORD_MODIFIERS[name] ?? null;
  }
  lookupComponent(name, owner) {
    let pair = lookupComponentPair(owner, name);
    if (pair === null) {
      (isDevelopingApp() && !(name !== 'text-area') && assert('Could not find component `<TextArea />` (did you mean `<Textarea />`?)', name !== 'text-area'));
      return null;
    }
    let template = null;
    let key;
    if (pair.component === null) {
      key = template = pair.layout(owner);
    } else {
      key = pair.component;
    }
    let cachedComponentDefinition = this.componentDefinitionCache.get(key);
    if (cachedComponentDefinition !== undefined) {
      return cachedComponentDefinition;
    }
    if (template === null && pair.layout !== null) {
      template = pair.layout(owner);
    }
    let finalizer = _instrumentStart('render.getComponentDefinition', instrumentationPayload, name);
    let definition = null;
    if (pair.component === null) {
      definition = {
        state: templateOnlyComponent(undefined, name),
        manager: TEMPLATE_ONLY_COMPONENT_MANAGER,
        template
      };
    } else {
      let factory = pair.component;
      (isDevelopingApp() && !(factory.class !== undefined) && assert(`missing component class ${name}`, factory.class !== undefined));
      let ComponentClass = factory.class;
      let manager = getInternalComponentManager(ComponentClass);
      definition = {
        state: isCurlyManager(manager) ? factory : ComponentClass,
        manager,
        template
      };
    }
    finalizer();
    this.componentDefinitionCache.set(key, definition);
    (isDevelopingApp() && !(!(definition === null && name === 'text-area')) && assert('Could not find component `<TextArea />` (did you mean `<Textarea />`?)', !(definition === null && name === 'text-area')));
    return definition;
  }
}

// We use the `InternalOwner` notion here because we actually need all of its
// API for using with renderers (normally, it will be `EngineInstance`).
// We use `getOwner` from our internal home for it rather than the narrower
// public API for the same reason.
const TOP_LEVEL_NAME = '-top-level';
class OutletView {
  static extend(injections) {
    return class extends OutletView {
      static create(options) {
        if (options) {
          return super.create(Object.assign({}, injections, options));
        } else {
          return super.create(injections);
        }
      }
    };
  }
  static reopenClass(injections) {
    Object.assign(this, injections);
  }
  static create(options) {
    let {
      environment: _environment,
      application: namespace,
      template: templateFactory
    } = options;
    let owner = getOwner(options);
    (isDevelopingApp() && !(owner) && assert('OutletView is unexpectedly missing an owner', owner));
    let template = templateFactory(owner);
    return new OutletView(_environment, owner, template, namespace);
  }
  ref;
  state;
  constructor(_environment, owner, template, namespace) {
    this._environment = _environment;
    this.owner = owner;
    this.template = template;
    this.namespace = namespace;
    let outletStateTag = createTag();
    let outletState = {
      outlets: {
        main: undefined
      },
      render: {
        owner: owner,
        into: undefined,
        outlet: 'main',
        name: TOP_LEVEL_NAME,
        controller: undefined,
        model: undefined,
        template
      }
    };
    let ref = this.ref = createComputeRef(() => {
      consumeTag(outletStateTag);
      return outletState;
    }, state => {
      DIRTY_TAG$1(outletStateTag);
      outletState.outlets['main'] = state;
    });
    this.state = {
      ref,
      name: TOP_LEVEL_NAME,
      template,
      controller: undefined,
      model: undefined
    };
  }
  appendTo(selector) {
    let target;
    if (this._environment.hasDOM) {
      target = typeof selector === 'string' ? document.querySelector(selector) : selector;
    } else {
      target = selector;
    }
    let renderer = this.owner.lookup('renderer:-dom');

    // SAFETY: It's not clear that this cast is safe.
    // The types for appendOutletView may be incorrect or this is a potential bug.
    schedule('render', renderer, 'appendOutletView', this, target);
  }
  rerender() {
    /**/
  }
  setOutletState(state) {
    updateRef(this.ref, state);
  }
  destroy() {
    /**/
  }
}

class DynamicScope {
  constructor(view, outletState) {
    this.view = view;
    this.outletState = outletState;
  }
  child() {
    return new DynamicScope(this.view, this.outletState);
  }
  get(key) {
    (isDevelopingApp() && !(key === 'outletState') && assert(`Using \`-get-dynamic-scope\` is only supported for \`outletState\` (you used \`${key}\`).`, key === 'outletState'));
    return this.outletState;
  }
  set(key, value) {
    (isDevelopingApp() && !(key === 'outletState') && assert(`Using \`-with-dynamic-scope\` is only supported for \`outletState\` (you used \`${key}\`).`, key === 'outletState'));
    this.outletState = value;
    return value;
  }
}
const NO_OP = () => {};

// This wrapper logic prevents us from rerendering in case of a hard failure
// during render. This prevents infinite revalidation type loops from occuring,
// and ensures that errors are not swallowed by subsequent follow on failures.
function errorLoopTransaction(fn) {
  if (isDevelopingApp()) {
    return () => {
      let didError = true;
      try {
        fn();
        didError = false;
      } finally {
        if (didError) {
          // Noop the function so that we won't keep calling it and causing
          // infinite looping failures;
          fn = () => {
            // eslint-disable-next-line no-console
            console.warn('Attempted to rerender, but the Ember application has had an unrecoverable error occur during render. You should reload the application after fixing the cause of the error.');
          };
        }
      }
    };
  } else {
    return fn;
  }
}
class RootState {
  id;
  result;
  destroyed;
  render;
  constructor(root, runtime, context, owner, template, self, parentElement, dynamicScope, builder) {
    this.root = root;
    this.runtime = runtime;
    (isDevelopingApp() && !(template !== undefined) && assert(`You cannot render \`${valueForRef(self)}\` without a template.`, template !== undefined));
    this.id = root instanceof OutletView ? guidFor(root) : getViewId(root);
    this.result = undefined;
    this.destroyed = false;
    this.render = errorLoopTransaction(() => {
      let layout = unwrapTemplate(template).asLayout();
      let iterator = renderMain(runtime, context, owner, self, builder(runtime.env, {
        element: parentElement,
        nextSibling: null
      }), layout, dynamicScope);
      let result = this.result = iterator.sync();

      // override .render function after initial render
      this.render = errorLoopTransaction(() => result.rerender({
        alwaysRevalidate: false
      }));
    });
  }
  isFor(possibleRoot) {
    return this.root === possibleRoot;
  }
  destroy() {
    let {
      result,
      runtime: {
        env
      }
    } = this;
    this.destroyed = true;
    this.runtime = undefined;
    this.root = null;
    this.result = undefined;
    this.render = undefined;
    if (result !== undefined) {
      /*
       Handles these scenarios:
        * When roots are removed during standard rendering process, a transaction exists already
         `.begin()` / `.commit()` are not needed.
       * When roots are being destroyed manually (`component.append(); component.destroy() case), no
         transaction exists already.
       * When roots are being destroyed during `Renderer#destroy`, no transaction exists
        */

      inTransaction(env, () => destroy(result));
    }
  }
}
const renderers = [];
function _resetRenderers() {
  renderers.length = 0;
}
function register(renderer) {
  (isDevelopingApp() && !(renderers.indexOf(renderer) === -1) && assert('Cannot register the same renderer twice', renderers.indexOf(renderer) === -1));
  renderers.push(renderer);
}
function deregister(renderer) {
  let index = renderers.indexOf(renderer);
  (isDevelopingApp() && !(index !== -1) && assert('Cannot deregister unknown unregistered renderer', index !== -1));
  renderers.splice(index, 1);
}
function loopBegin() {
  for (let renderer of renderers) {
    renderer._scheduleRevalidate();
  }
}
let renderSettledDeferred = null;
/*
  Returns a promise which will resolve when rendering has settled. Settled in
  this context is defined as when all of the tags in use are "current" (e.g.
  `renderers.every(r => r._isValid())`). When this is checked at the _end_ of
  the run loop, this essentially guarantees that all rendering is completed.

  @method renderSettled
  @returns {Promise<void>} a promise which fulfills when rendering has settled
*/
function renderSettled() {
  if (renderSettledDeferred === null) {
    renderSettledDeferred = RSVP.defer();
    // if there is no current runloop, the promise created above will not have
    // a chance to resolve (because its resolved in backburner's "end" event)
    if (!_getCurrentRunLoop()) {
      // ensure a runloop has been kicked off
      _backburner.schedule('actions', null, NO_OP);
    }
  }
  return renderSettledDeferred.promise;
}
function resolveRenderPromise() {
  if (renderSettledDeferred !== null) {
    let resolve = renderSettledDeferred.resolve;
    renderSettledDeferred = null;
    _backburner.join(null, resolve);
  }
}
let loops = 0;
function loopEnd() {
  for (let renderer of renderers) {
    if (!renderer._isValid()) {
      if (loops > ENV._RERENDER_LOOP_LIMIT) {
        loops = 0;
        // TODO: do something better
        renderer.destroy();
        throw new Error('infinite rendering invalidation detected');
      }
      loops++;
      return _backburner.join(null, NO_OP);
    }
  }
  loops = 0;
  resolveRenderPromise();
}
_backburner.on('begin', loopBegin);
_backburner.on('end', loopEnd);
class Renderer {
  _rootTemplate;
  _viewRegistry;
  _roots;
  _removedRoots;
  _builder;
  _inRenderTransaction = false;
  _owner;
  _context;
  _runtime;
  _lastRevision = -1;
  _destroyed = false;

  /** @internal */
  _isInteractive;
  _runtimeResolver;
  static create(props) {
    let {
      _viewRegistry
    } = props;
    let owner = getOwner(props);
    (isDevelopingApp() && !(owner) && assert('Renderer is unexpectedly missing an owner', owner));
    let document = owner.lookup('service:-document');
    let env = owner.lookup('-environment:main');
    let rootTemplate = owner.lookup(privatize`template:-root`);
    let builder = owner.lookup('service:-dom-builder');
    return new this(owner, document, env, rootTemplate, _viewRegistry, builder);
  }
  constructor(owner, document, env, rootTemplate, viewRegistry, builder = clientBuilder) {
    this._owner = owner;
    this._rootTemplate = rootTemplate(owner);
    this._viewRegistry = viewRegistry || owner.lookup('-view-registry:main');
    this._roots = [];
    this._removedRoots = [];
    this._builder = builder;
    this._isInteractive = env.isInteractive;

    // resolver is exposed for tests
    let resolver = this._runtimeResolver = new ResolverImpl();
    let sharedArtifacts = artifacts();
    this._context = programCompilationContext(sharedArtifacts, resolver, heap => new RuntimeOpImpl(heap));
    let runtimeEnvironmentDelegate = new EmberEnvironmentDelegate(owner, env.isInteractive);
    this._runtime = runtimeContext({
      appendOperations: env.hasDOM ? new DOMTreeConstruction(document) : new NodeDOMTreeConstruction(document),
      updateOperations: new DOMChanges(document)
    }, runtimeEnvironmentDelegate, sharedArtifacts, resolver);
  }
  get debugRenderTree() {
    let {
      debugRenderTree
    } = this._runtime.env;
    (isDevelopingApp() && !(debugRenderTree) && assert('Attempted to access the DebugRenderTree, but it did not exist. Is the Ember Inspector open?', debugRenderTree));
    return debugRenderTree;
  }

  // renderer HOOKS

  appendOutletView(view, target) {
    let definition = createRootOutlet(view);
    this._appendDefinition(view, curry(CurriedTypes.Component, definition, view.owner, null, true), target);
  }
  appendTo(view, target) {
    let definition = new RootComponentDefinition(view);
    this._appendDefinition(view, curry(CurriedTypes.Component, definition, this._owner, null, true), target);
  }
  _appendDefinition(root, definition, target) {
    let self = createConstRef(definition, 'this');
    let dynamicScope = new DynamicScope(null, UNDEFINED_REFERENCE);
    let rootState = new RootState(root, this._runtime, this._context, this._owner, this._rootTemplate, self, target, dynamicScope, this._builder);
    this._renderRoot(rootState);
  }
  rerender() {
    this._scheduleRevalidate();
  }
  register(view) {
    let id = getViewId(view);
    (isDevelopingApp() && !(!this._viewRegistry[id]) && assert('Attempted to register a view with an id already in use: ' + id, !this._viewRegistry[id]));
    this._viewRegistry[id] = view;
  }
  unregister(view) {
    delete this._viewRegistry[getViewId(view)];
  }
  remove(view) {
    view._transitionTo('destroying');
    this.cleanupRootFor(view);
    if (this._isInteractive) {
      view.trigger('didDestroyElement');
    }
  }
  cleanupRootFor(view) {
    // no need to cleanup roots if we have already been destroyed
    if (this._destroyed) {
      return;
    }
    let roots = this._roots;

    // traverse in reverse so we can remove items
    // without mucking up the index
    let i = this._roots.length;
    while (i--) {
      let root = roots[i];
      (isDevelopingApp() && !(root) && assert('has root', root));
      if (root.isFor(view)) {
        root.destroy();
        roots.splice(i, 1);
      }
    }
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this._destroyed = true;
    this._clearAllRoots();
  }
  getElement(view) {
    if (this._isInteractive) {
      return getViewElement(view);
    } else {
      throw new Error('Accessing `this.element` is not allowed in non-interactive environments (such as FastBoot).');
    }
  }
  getBounds(view) {
    let bounds = view[BOUNDS];
    (isDevelopingApp() && !(bounds) && assert('object passed to getBounds must have the BOUNDS symbol as a property', bounds));
    let parentElement = bounds.parentElement();
    let firstNode = bounds.firstNode();
    let lastNode = bounds.lastNode();
    return {
      parentElement,
      firstNode,
      lastNode
    };
  }
  createElement(tagName) {
    return this._runtime.env.getAppendOperations().createElement(tagName);
  }
  _renderRoot(root) {
    let {
      _roots: roots
    } = this;
    roots.push(root);
    if (roots.length === 1) {
      register(this);
    }
    this._renderRootsTransaction();
  }
  _renderRoots() {
    let {
      _roots: roots,
      _runtime: runtime,
      _removedRoots: removedRoots
    } = this;
    let initialRootsLength;
    do {
      initialRootsLength = roots.length;
      inTransaction(runtime.env, () => {
        // ensure that for the first iteration of the loop
        // each root is processed
        for (let i = 0; i < roots.length; i++) {
          let root = roots[i];
          (isDevelopingApp() && !(root) && assert('has root', root));
          if (root.destroyed) {
            // add to the list of roots to be removed
            // they will be removed from `this._roots` later
            removedRoots.push(root);

            // skip over roots that have been marked as destroyed
            continue;
          }

          // when processing non-initial reflush loops,
          // do not process more roots than needed
          if (i >= initialRootsLength) {
            continue;
          }
          root.render();
        }
        this._lastRevision = valueForTag(CURRENT_TAG);
      });
    } while (roots.length > initialRootsLength);

    // remove any roots that were destroyed during this transaction
    while (removedRoots.length) {
      let root = removedRoots.pop();
      let rootIndex = roots.indexOf(root);
      roots.splice(rootIndex, 1);
    }
    if (this._roots.length === 0) {
      deregister(this);
    }
  }
  _renderRootsTransaction() {
    if (this._inRenderTransaction) {
      // currently rendering roots, a new root was added and will
      // be processed by the existing _renderRoots invocation
      return;
    }

    // used to prevent calling _renderRoots again (see above)
    // while we are actively rendering roots
    this._inRenderTransaction = true;
    let completedWithoutError = false;
    try {
      this._renderRoots();
      completedWithoutError = true;
    } finally {
      if (!completedWithoutError) {
        this._lastRevision = valueForTag(CURRENT_TAG);
      }
      this._inRenderTransaction = false;
    }
  }
  _clearAllRoots() {
    let roots = this._roots;
    for (let root of roots) {
      root.destroy();
    }
    this._removedRoots.length = 0;
    this._roots = [];

    // if roots were present before destroying
    // deregister this renderer instance
    if (roots.length) {
      deregister(this);
    }
  }
  _scheduleRevalidate() {
    _backburner.scheduleOnce('render', this, this._revalidate);
  }
  _isValid() {
    return this._destroyed || this._roots.length === 0 || validateTag(CURRENT_TAG, this._lastRevision);
  }
  _revalidate() {
    if (this._isValid()) {
      return;
    }
    this._renderRootsTransaction();
  }
}

const OutletTemplate = templateFactory(
/*
  {{component (outletHelper)}}
*/
{
  "id": "2c6+lAmT",
  "block": "[[[46,[28,[32,0],null,null],null,null,null]],[],false,[\"component\"]]",
  "moduleName": "packages/@ember/-internals/glimmer/lib/templates/outlet.hbs",
  "scope": () => [outletHelper],
  "isStrictMode": true
});

function setupApplicationRegistry(registry) {
  // because we are using injections we can't use instantiate false
  // we need to use bind() to copy the function so factory for
  // association won't leak
  registry.register('service:-dom-builder', {
    // Additionally, we *must* constrain this to require `props` on create, else
    // we *know* it cannot have an owner.
    create(props) {
      let owner = getOwner(props);
      (isDevelopingApp() && !(owner) && assert('DomBuilderService is unexpectedly missing an owner', owner));
      let env = owner.lookup('-environment:main');
      switch (env._renderMode) {
        case 'serialize':
          return serializeBuilder.bind(null);
        case 'rehydrate':
          return rehydrationBuilder.bind(null);
        default:
          return clientBuilder.bind(null);
      }
    }
  });
  registry.register(privatize`template:-root`, RootTemplate);
  registry.register('renderer:-dom', Renderer);
}
function setupEngineRegistry(registry) {
  registry.optionsForType('template', {
    instantiate: false
  });
  registry.register('view:-outlet', OutletView);
  registry.register('template:-outlet', OutletTemplate);
  registry.optionsForType('helper', {
    instantiate: false
  });
  registry.register('component:input', Input);
  registry.register('component:link-to', LinkTo);
  registry.register('component:textarea', Textarea);
}

function props(obj) {
  let properties = [];
  for (let key in obj) {
    properties.push(key);
  }
  return properties;
}

/**
@module @ember/engine
*/

/**
  The `Engine` class contains core functionality for both applications and
  engines.

  Each engine manages a registry that's used for dependency injection and
  exposed through `RegistryProxy`.

  Engines also manage initializers and instance initializers.

  Engines can spawn `EngineInstance` instances via `buildInstance()`.

  @class Engine
  @extends Ember.Namespace
  @uses RegistryProxyMixin
  @public
*/
// eslint-disable-next-line @typescript-eslint/no-empty-interface

class Engine extends Namespace.extend(RegistryProxyMixin) {
  static initializers = Object.create(null);
  static instanceInitializers = Object.create(null);

  /**
    The goal of initializers should be to register dependencies and injections.
    This phase runs once. Because these initializers may load code, they are
    allowed to defer application readiness and advance it. If you need to access
    the container or store you should use an InstanceInitializer that will be run
    after all initializers and therefore after all code is loaded and the app is
    ready.
     Initializer receives an object which has the following attributes:
    `name`, `before`, `after`, `initialize`. The only required attribute is
    `initialize`, all others are optional.
     * `name` allows you to specify under which name the initializer is registered.
    This must be a unique name, as trying to register two initializers with the
    same name will result in an error.
     ```app/initializer/named-initializer.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Running namedInitializer!');
    }
     export default {
      name: 'named-initializer',
      initialize
    };
    ```
     * `before` and `after` are used to ensure that this initializer is ran prior
    or after the one identified by the value. This value can be a single string
    or an array of strings, referencing the `name` of other initializers.
     An example of ordering initializers, we create an initializer named `first`:
     ```app/initializer/first.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('First initializer!');
    }
     export default {
      name: 'first',
      initialize
    };
    ```
     ```bash
    // DEBUG: First initializer!
    ```
     We add another initializer named `second`, specifying that it should run
    after the initializer named `first`:
     ```app/initializer/second.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Second initializer!');
    }
     export default {
      name: 'second',
      after: 'first',
      initialize
    };
    ```
     ```
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    ```
     Afterwards we add a further initializer named `pre`, this time specifying
    that it should run before the initializer named `first`:
     ```app/initializer/pre.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Pre initializer!');
    }
     export default {
      name: 'pre',
      before: 'first',
      initialize
    };
    ```
     ```bash
    // DEBUG: Pre initializer!
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    ```
     Finally we add an initializer named `post`, specifying it should run after
    both the `first` and the `second` initializers:
     ```app/initializer/post.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Post initializer!');
    }
     export default {
      name: 'post',
      after: ['first', 'second'],
      initialize
    };
    ```
     ```bash
    // DEBUG: Pre initializer!
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    // DEBUG: Post initializer!
    ```
     * `initialize` is a callback function that receives one argument,
      `application`, on which you can operate.
     Example of using `application` to register an adapter:
     ```app/initializer/api-adapter.js
    import ApiAdapter from '../utils/api-adapter';
     export function initialize(application) {
      application.register('api-adapter:main', ApiAdapter);
    }
     export default {
      name: 'post',
      after: ['first', 'second'],
      initialize
    };
    ```
     @method initializer
    @param initializer {Object}
    @public
  */

  static initializer = buildInitializerMethod('initializers', 'initializer');

  /**
    Instance initializers run after all initializers have run. Because
    instance initializers run after the app is fully set up. We have access
    to the store, container, and other items. However, these initializers run
    after code has loaded and are not allowed to defer readiness.
     Instance initializer receives an object which has the following attributes:
    `name`, `before`, `after`, `initialize`. The only required attribute is
    `initialize`, all others are optional.
     * `name` allows you to specify under which name the instanceInitializer is
    registered. This must be a unique name, as trying to register two
    instanceInitializer with the same name will result in an error.
     ```app/initializer/named-instance-initializer.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Running named-instance-initializer!');
    }
     export default {
      name: 'named-instance-initializer',
      initialize
    };
    ```
     * `before` and `after` are used to ensure that this initializer is ran prior
    or after the one identified by the value. This value can be a single string
    or an array of strings, referencing the `name` of other initializers.
     * See Application.initializer for discussion on the usage of before
    and after.
     Example instanceInitializer to preload data into the store.
     ```app/initializer/preload-data.js
     export function initialize(application) {
        var userConfig, userConfigEncoded, store;
        // We have a HTML escaped JSON representation of the user's basic
        // configuration generated server side and stored in the DOM of the main
        // index.html file. This allows the app to have access to a set of data
        // without making any additional remote calls. Good for basic data that is
        // needed for immediate rendering of the page. Keep in mind, this data,
        // like all local models and data can be manipulated by the user, so it
        // should not be relied upon for security or authorization.
         // Grab the encoded data from the meta tag
        userConfigEncoded = document.querySelector('head meta[name=app-user-config]').attr('content');
         // Unescape the text, then parse the resulting JSON into a real object
        userConfig = JSON.parse(unescape(userConfigEncoded));
         // Lookup the store
        store = application.lookup('service:store');
         // Push the encoded JSON into the store
        store.pushPayload(userConfig);
    }
     export default {
      name: 'named-instance-initializer',
      initialize
    };
    ```
     @method instanceInitializer
    @param instanceInitializer
    @public
  */
  static instanceInitializer = buildInitializerMethod('instanceInitializers', 'instance initializer');

  /**
    This creates a registry with the default Ember naming conventions.
     It also configures the registry:
     * registered views are created every time they are looked up (they are
      not singletons)
    * registered templates are not factories; the registered value is
      returned directly.
    * the router receives the application as its `namespace` property
    * all controllers receive the router as their `target` and `controllers`
      properties
    * all controllers receive the application as their `namespace` property
    * the application view receives the application controller as its
      `controller` property
    * the application view receives the application template as its
      `defaultTemplate` property
     @method buildRegistry
    @static
    @param {Application} namespace the application for which to
      build the registry
    @return {Ember.Registry} the built registry
    @private
  */
  static buildRegistry(namespace) {
    let registry = new Registry({
      resolver: resolverFor(namespace)
    });
    registry.set = set;
    registry.register('application:main', namespace, {
      instantiate: false
    });
    commonSetupRegistry(registry);
    setupEngineRegistry(registry);
    return registry;
  }

  /**
    Set this to provide an alternate class to `DefaultResolver`
     @property resolver
    @public
  */

  init(properties) {
    super.init(properties);
    this.buildRegistry();
  }

  /**
    A private flag indicating whether an engine's initializers have run yet.
     @private
    @property _initializersRan
  */
  _initializersRan = false;

  /**
    Ensure that initializers are run once, and only once, per engine.
     @private
    @method ensureInitializers
  */
  ensureInitializers() {
    if (!this._initializersRan) {
      this.runInitializers();
      this._initializersRan = true;
    }
  }

  /**
    Create an EngineInstance for this engine.
     @public
    @method buildInstance
    @return {EngineInstance} the engine instance
  */
  buildInstance(options = {}) {
    this.ensureInitializers();
    return EmberEngineInstance.create({
      ...options,
      base: this
    });
  }

  /**
    Build and configure the registry for the current engine.
     @private
    @method buildRegistry
    @return {Ember.Registry} the configured registry
  */
  buildRegistry() {
    let registry = this.__registry__ = this.constructor.buildRegistry(this);
    return registry;
  }

  /**
    @private
    @method initializer
  */
  initializer(initializer) {
    this.constructor.initializer(initializer);
  }

  /**
    @private
    @method instanceInitializer
  */
  instanceInitializer(initializer) {
    this.constructor.instanceInitializer(initializer);
  }

  /**
    @private
    @method runInitializers
  */
  runInitializers() {
    this._runInitializer('initializers', (name, initializer) => {
      (isDevelopingApp() && !(initializer) && assert(`No application initializer named '${name}'`, initializer));
      initializer.initialize(this);
    });
  }

  /**
    @private
    @since 1.12.0
    @method runInstanceInitializers
  */
  runInstanceInitializers(instance) {
    this._runInitializer('instanceInitializers', (name, initializer) => {
      (isDevelopingApp() && !(initializer) && assert(`No instance initializer named '${name}'`, initializer));
      initializer.initialize(instance);
    });
  }
  _runInitializer(bucketName, cb) {
    let initializersByName = get(this.constructor, bucketName);
    let initializers = props(initializersByName);
    let graph = new DAG();
    let initializer;
    for (let name of initializers) {
      initializer = initializersByName[name];
      (isDevelopingApp() && !(initializer) && assert(`missing ${bucketName}: ${name}`, initializer));
      graph.add(initializer.name, initializer, initializer.before, initializer.after);
    }
    graph.topsort(cb);
  }
}

/**
  This function defines the default lookup rules for container lookups:

  * templates are looked up on `Ember.TEMPLATES`
  * other names are looked up on the application after classifying the name.
    For example, `controller:post` looks up `App.PostController` by default.
  * if the default lookup fails, look for registered classes on the container

  This allows the application to register default injections in the container
  that could be overridden by the normal naming convention.

  @private
  @method resolverFor
  @param {Ember.Enginer} namespace the namespace to look for classes
  @return {*} the resolved value for a given lookup
*/
function resolverFor(namespace) {
  let ResolverClass = namespace.Resolver;
  let props = {
    namespace
  };
  return ResolverClass.create(props);
}

/** @internal */
function buildInitializerMethod(bucketName, humanName) {
  return function (initializer) {
    // If this is the first initializer being added to a subclass, we are going to reopen the class
    // to make sure we have a new `initializers` object, which extends from the parent class' using
    // prototypal inheritance. Without this, attempting to add initializers to the subclass would
    // pollute the parent class as well as other subclasses.
    // SAFETY: The superclass may be an Engine, we don't call unless we confirmed it was ok.
    let superclass = this.superclass;
    if (superclass[bucketName] !== undefined && superclass[bucketName] === this[bucketName]) {
      let attrs = {
        [bucketName]: Object.create(this[bucketName])
      };
      this.reopenClass(attrs);
    }
    (isDevelopingApp() && !(!this[bucketName][initializer.name]) && assert(`The ${humanName} '${initializer.name}' has already been registered`, !this[bucketName][initializer.name]));
    (isDevelopingApp() && !(canInvoke(initializer, 'initialize')) && assert(`An ${humanName} cannot be registered without an initialize function`, canInvoke(initializer, 'initialize')));
    (isDevelopingApp() && !(initializer.name !== undefined) && assert(`An ${humanName} cannot be registered without a name property`, initializer.name !== undefined));
    let initializers = this[bucketName];
    initializers[initializer.name] = initializer;
  };
}
function commonSetupRegistry(registry) {
  registry.optionsForType('component', {
    singleton: false
  });
  registry.optionsForType('view', {
    singleton: false
  });
  registry.register('controller:basic', Controller, {
    instantiate: false
  });

  // Register the routing service...
  registry.register('service:-routing', RoutingService);

  // DEBUGGING
  registry.register('resolver-for-debugging:main', registry.resolver, {
    instantiate: false
  });
  registry.register('container-debug-adapter:main', ContainerDebugAdapter);
  registry.register('component-lookup:main', ComponentLookup);
}

/**
@module @ember/engine
*/

class EngineInstance extends EmberObject.extend(RegistryProxyMixin, ContainerProxyMixin) {
  /**
   @private
   @method setupRegistry
   @param {Registry} registry
   @param {BootOptions} options
   */
  // This is effectively an "abstract" method: it defines the contract a
  // subclass (e.g. `ApplicationInstance`) must follow to implement this
  // behavior, but an `EngineInstance` has no behavior of its own here.
  static setupRegistry(_registry, _options) {}

  /**
    The base `Engine` for which this is an instance.
     @property {Engine} engine
    @private
  */

  [ENGINE_PARENT];
  _booted = false;
  init(properties) {
    super.init(properties);

    // Ensure the guid gets setup for this instance
    guidFor(this);
    this.base ??= this.application;

    // Create a per-instance registry that will use the application's registry
    // as a fallback for resolving registrations.
    let registry = this.__registry__ = new Registry({
      fallback: this.base.__registry__
    });

    // Create a per-instance container from the instance's registry
    this.__container__ = registry.container({
      owner: this
    });
    this._booted = false;
  }
  _bootPromise = null;

  /**
    Initialize the `EngineInstance` and return a promise that resolves
    with the instance itself when the boot process is complete.
     The primary task here is to run any registered instance initializers.
     See the documentation on `BootOptions` for the options it takes.
     @public
    @method boot
    @param options {Object}
    @return {Promise<EngineInstance,Error>}
  */
  boot(options) {
    if (this._bootPromise) {
      return this._bootPromise;
    }
    this._bootPromise = new RSVP$1.Promise(resolve => {
      resolve(this._bootSync(options));
    });
    return this._bootPromise;
  }

  /**
    Unfortunately, a lot of existing code assumes booting an instance is
    synchronous – specifically, a lot of tests assume the last call to
    `app.advanceReadiness()` or `app.reset()` will result in a new instance
    being fully-booted when the current runloop completes.
     We would like new code (like the `visit` API) to stop making this
    assumption, so we created the asynchronous version above that returns a
    promise. But until we have migrated all the code, we would have to expose
    this method for use *internally* in places where we need to boot an instance
    synchronously.
     @private
  */
  _bootSync(options) {
    if (this._booted) {
      return this;
    }
    (isDevelopingApp() && !(getEngineParent(this)) && assert("An engine instance's parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.", getEngineParent(this)));
    this.cloneParentDependencies();
    this.setupRegistry(options);
    this.base.runInstanceInitializers(this);
    this._booted = true;
    return this;
  }
  setupRegistry(options = this.__container__.lookup('-environment:main')) {
    this.constructor.setupRegistry(this.__registry__, options);
  }

  /**
   Unregister a factory.
    Overrides `RegistryProxy#unregister` in order to clear any cached instances
   of the unregistered factory.
    @public
   @method unregister
   @param {String} fullName
   */
  unregister(fullName) {
    this.__container__.reset(fullName);

    // We overwrote this method from RegistryProxyMixin.
    this.__registry__.unregister(fullName);
  }

  /**
    Build a new `EngineInstance` that's a child of this instance.
     Engines must be registered by name with their parent engine
    (or application).
     @private
    @method buildChildEngineInstance
    @param name {String} the registered name of the engine.
    @param options {Object} options provided to the engine instance.
    @return {EngineInstance,Error}
  */
  buildChildEngineInstance(name, options = {}) {
    let ChildEngine = this.lookup(`engine:${name}`);
    if (!ChildEngine) {
      throw new Error(`You attempted to mount the engine '${name}', but it is not registered with its parent.`);
    }
    (isDevelopingApp() && !(ChildEngine instanceof Engine) && assert('expected an Engine', ChildEngine instanceof Engine));
    let engineInstance = ChildEngine.buildInstance(options);
    setEngineParent(engineInstance, this);
    return engineInstance;
  }

  /**
    Clone dependencies shared between an engine instance and its parent.
     @private
    @method cloneParentDependencies
  */
  cloneParentDependencies() {
    const parent = getEngineParent(this);
    (isDevelopingApp() && !(parent) && assert('expected parent', parent));
    let registrations = ['route:basic', 'service:-routing'];
    registrations.forEach(key => {
      let registration = parent.resolveRegistration(key);
      (isDevelopingApp() && !(isFactory(registration)) && assert('expected registration to be a factory', isFactory(registration)));
      this.register(key, registration);
    });
    let env = parent.lookup('-environment:main');
    this.register('-environment:main', env, {
      instantiate: false
    });

    // The type annotation forces TS to (a) validate that these match and (b)
    // *notice* that they match, e.g. below on the `singletons.push()`.
    let singletons = ['router:main', privatize`-bucket-cache:main`, '-view-registry:main', `renderer:-dom`, 'service:-document'];
    if (env['isInteractive']) {
      singletons.push('event_dispatcher:main');
    }
    singletons.forEach(key => {
      // SAFETY: We already expect this to be a singleton
      let singleton = parent.lookup(key);
      this.register(key, singleton, {
        instantiate: false
      });
    });
  }
}
const EmberEngineInstance = EngineInstance;

const ALL_PERIODS_REGEX = /\./g;
function extractRouteArgs(args) {
  // SAFETY: This should just be the same thing
  args = args.slice();
  let possibleOptions = args[args.length - 1];
  let queryParams;
  if (isRouteOptions(possibleOptions)) {
    args.pop(); // Remove options
    queryParams = possibleOptions.queryParams;
  } else {
    queryParams = {};
  }
  let routeName;
  if (typeof args[0] === 'string') {
    routeName = args.shift();
    // We just checked this!
    (isDevelopingApp() && !(typeof routeName === 'string') && assert('routeName is a string', typeof routeName === 'string'));
  }

  // SAFTEY: We removed the name and options if they existed, only models left.
  let models = args;
  return {
    routeName,
    models,
    queryParams
  };
}
function getActiveTargetName(router) {
  let routeInfos = router.activeTransition ? router.activeTransition[STATE_SYMBOL].routeInfos : router.state.routeInfos;
  let lastRouteInfo = routeInfos[routeInfos.length - 1];
  (isDevelopingApp() && !(lastRouteInfo) && assert('has last route info', lastRouteInfo));
  return lastRouteInfo.name;
}
function stashParamNames(router, routeInfos) {
  if (routeInfos['_namesStashed']) {
    return;
  }

  // This helper exists because router.js/route-recognizer.js awkwardly
  // keeps separate a routeInfo's list of parameter names depending
  // on whether a URL transition or named transition is happening.
  // Hopefully we can remove this in the future.
  let routeInfo = routeInfos[routeInfos.length - 1];
  (isDevelopingApp() && !(routeInfo) && assert('has route info', routeInfo));
  let targetRouteName = routeInfo.name;
  let recogHandlers = router._routerMicrolib.recognizer.handlersFor(targetRouteName);
  let dynamicParent;
  for (let i = 0; i < routeInfos.length; ++i) {
    let routeInfo = routeInfos[i];
    (isDevelopingApp() && !(routeInfo) && assert('has route info', routeInfo));
    let names = recogHandlers[i].names;
    if (names.length) {
      dynamicParent = routeInfo;
    }
    routeInfo['_names'] = names;
    let route = routeInfo.route;
    route._stashNames(routeInfo, dynamicParent);
  }
  routeInfos['_namesStashed'] = true;
}
function _calculateCacheValuePrefix(prefix, part) {
  // calculates the dot separated sections from prefix that are also
  // at the start of part - which gives us the route name

  // given : prefix = site.article.comments, part = site.article.id
  //      - returns: site.article (use get(values[site.article], 'id') to get the dynamic part - used below)

  // given : prefix = site.article, part = site.article.id
  //      - returns: site.article. (use get(values[site.article], 'id') to get the dynamic part - used below)

  let prefixParts = prefix.split('.');
  let currPrefix = '';
  for (let i = 0; i < prefixParts.length; i++) {
    let currPart = prefixParts.slice(0, i + 1).join('.');
    if (part.indexOf(currPart) !== 0) {
      break;
    }
    currPrefix = currPart;
  }
  return currPrefix;
}

/*
  Stolen from Controller
*/
function calculateCacheKey(prefix, parts = [], values) {
  let suffixes = '';
  for (let part of parts) {
    let cacheValuePrefix = _calculateCacheValuePrefix(prefix, part);
    let value;
    if (values) {
      if (cacheValuePrefix && cacheValuePrefix in values) {
        let partRemovedPrefix = part.indexOf(cacheValuePrefix) === 0 ? part.substring(cacheValuePrefix.length + 1) : part;
        value = get(values[cacheValuePrefix], partRemovedPrefix);
      } else {
        value = get(values, part);
      }
    }
    suffixes += `::${part}:${value}`;
  }
  return prefix + suffixes.replace(ALL_PERIODS_REGEX, '-');
}

/*
  Controller-defined query parameters can come in three shapes:

  Array
    queryParams: ['foo', 'bar']
  Array of simple objects where value is an alias
    queryParams: [
      {
        'foo': 'rename_foo_to_this'
      },
      {
        'bar': 'call_bar_this_instead'
      }
    ]
  Array of fully defined objects
    queryParams: [
      {
        'foo': {
          as: 'rename_foo_to_this'
        },
      }
      {
        'bar': {
          as: 'call_bar_this_instead',
          scope: 'controller'
        }
      }
    ]

  This helper normalizes all three possible styles into the
  'Array of fully defined objects' style.
*/
function normalizeControllerQueryParams(queryParams) {
  let qpMap = {};
  for (let queryParam of queryParams) {
    accumulateQueryParamDescriptors(queryParam, qpMap);
  }
  return qpMap;
}
function accumulateQueryParamDescriptors(_desc, accum) {
  let desc = typeof _desc === 'string' ? {
    [_desc]: {
      as: null
    }
  } : _desc;
  for (let key in desc) {
    if (!Object.prototype.hasOwnProperty.call(desc, key)) {
      return;
    }
    let _singleDesc = desc[key];
    let singleDesc = typeof _singleDesc === 'string' ? {
      as: _singleDesc
    } : _singleDesc;
    let partialVal = accum[key] || {
      as: null,
      scope: 'model'
    };
    let val = {
      ...partialVal,
      ...singleDesc
    };
    accum[key] = val;
  }
}

/*
  Check if a routeName resembles a url instead

  @private
*/
function resemblesURL(str) {
  return typeof str === 'string' && (str === '' || str[0] === '/');
}

/*
  Returns an arguments array where the route name arg is prefixed based on the mount point

  @private
*/
function prefixRouteNameArg(route, args) {
  let routeName;
  let owner = getOwner(route);
  (isDevelopingApp() && !(owner instanceof EmberEngineInstance) && assert('Expected route to have EngineInstance as owner', owner instanceof EmberEngineInstance));
  let prefix = owner.mountPoint;

  // only alter the routeName if it's actually referencing a route.
  if (owner.routable && typeof args[0] === 'string') {
    routeName = args[0];
    if (resemblesURL(routeName)) {
      throw new Error('Programmatic transitions by URL cannot be used within an Engine. Please use the route name instead.');
    } else {
      routeName = `${prefix}.${routeName}`;
      args[0] = routeName;
    }
  }
  return args;
}
function shallowEqual(a, b) {
  let aCount = 0;
  let bCount = 0;
  for (let kA in a) {
    if (Object.prototype.hasOwnProperty.call(a, kA)) {
      if (a[kA] !== b[kA]) {
        return false;
      }
      aCount++;
    }
  }
  for (let kB in b) {
    if (Object.prototype.hasOwnProperty.call(b, kB)) {
      bCount++;
    }
  }
  return aCount === bCount;
}
function isRouteOptions(value) {
  if (value && typeof value === 'object') {
    let qps = value.queryParams;
    if (qps && typeof qps === 'object') {
      return Object.keys(qps).every(k => typeof k === 'string');
    }
  }
  return false;
}

class RouterState {
  router;
  emberRouter;
  routerJsState;
  constructor(emberRouter, router, routerJsState) {
    this.emberRouter = emberRouter;
    this.router = router;
    this.routerJsState = routerJsState;
  }
  isActiveIntent(routeName, models, queryParams) {
    let state = this.routerJsState;
    if (!this.router.isActiveIntent(routeName, models, undefined, state)) {
      return false;
    }
    if (queryParams !== undefined && Object.keys(queryParams).length > 0) {
      let visibleQueryParams = Object.assign({}, queryParams);
      this.emberRouter._prepareQueryParams(routeName, models, visibleQueryParams);
      return shallowEqual(visibleQueryParams, state.queryParams);
    }
    return true;
  }
}

function isStoreLike(store) {
  return typeof store === 'object' && store !== null && typeof store.find === 'function';
}
const RENDER = Symbol('render');
const RENDER_STATE = Symbol('render-state');

/**
@module @ember/routing/route
*/

/**
  The `Route` class is used to define individual routes. Refer to
  the [routing guide](https://guides.emberjs.com/release/routing/) for documentation.

  @class Route
  @extends EmberObject
  @uses ActionHandler
  @uses Evented
  @since 1.0.0
  @public
*/

class Route extends EmberObject.extend(ActionHandler, Evented) {
  static isRouteFactory = true;

  // These properties will end up appearing in the public interface because we
  // `implements IRoute` from `router.js`, which has them as part of *its*
  // public contract. We mark them as `@internal` so they at least signal to
  // people subclassing `Route` that they should not use them.
  /** @internal */
  context = {};
  /** @internal */

  /** @internal */
  _bucketCache;
  /** @internal */
  _internalName;
  _names;
  _router;
  constructor(owner) {
    super(owner);
    if (owner) {
      let router = owner.lookup('router:main');
      let bucketCache = owner.lookup(privatize`-bucket-cache:main`);
      (isDevelopingApp() && !(router instanceof EmberRouter$1 && bucketCache instanceof BucketCache) && assert('ROUTER BUG: Expected route injections to be defined on the route. This is an internal bug, please open an issue on Github if you see this message!', router instanceof EmberRouter$1 && bucketCache instanceof BucketCache));
      this._router = router;
      this._bucketCache = bucketCache;
      this._topLevelViewTemplate = owner.lookup('template:-outlet');
      this._environment = owner.lookup('-environment:main');
    }
  }

  /**
    A hook you can implement to convert the route's model into parameters
    for the URL.
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     ```
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      model({ post_id }) {
        // the server returns `{ id: 12 }`
        return fetch(`/posts/${post_id}`;
      }
       serialize(model) {
        // this will make the URL `/posts/12`
        return { post_id: model.id };
      }
    }
    ```
     The default `serialize` method will insert the model's `id` into the
    route's dynamic segment (in this case, `:post_id`) if the segment contains '_id'.
    If the route has multiple dynamic segments or does not contain '_id', `serialize`
    will return `getProperties(model, params)`
     This method is called when `transitionTo` is called with a context
    in order to populate the URL.
     @method serialize
    @param {Object} model the routes model
    @param {Array} params an Array of parameter names for the current
      route (in the example, `['post_id']`.
    @return {Object} the serialized parameters
    @since 1.0.0
    @public
  */
  serialize(model, params) {
    if (params.length < 1 || !model) {
      return;
    }
    let object = {};
    if (params.length === 1) {
      let [name] = params;
      (isDevelopingApp() && !(name) && assert('has name', name));
      if (typeof model === 'object' && name in model) {
        object[name] = get(model, name);
      } else if (/_id$/.test(name)) {
        object[name] = get(model, 'id');
      } else if (isProxy(model)) {
        object[name] = get(model, name);
      }
    } else {
      object = getProperties(model, params);
    }
    return object;
  }

  /**
    Configuration hash for this route's queryParams. The possible
    configuration options and their defaults are as follows
    (assuming a query param whose controller property is `page`):
     ```javascript
    queryParams = {
      page: {
        // By default, controller query param properties don't
        // cause a full transition when they are changed, but
        // rather only cause the URL to update. Setting
        // `refreshModel` to true will cause an "in-place"
        // transition to occur, whereby the model hooks for
        // this route (and any child routes) will re-fire, allowing
        // you to reload models (e.g., from the server) using the
        // updated query param values.
        refreshModel: false,
         // By default, changes to controller query param properties
        // cause the URL to update via `pushState`, which means an
        // item will be added to the browser's history, allowing
        // you to use the back button to restore the app to the
        // previous state before the query param property was changed.
        // Setting `replace` to true will use `replaceState` (or its
        // hash location equivalent), which causes no browser history
        // item to be added. This options name and default value are
        // the same as the `link-to` helper's `replace` option.
        replace: false,
         // By default, the query param URL key is the same name as
        // the controller property name. Use `as` to specify a
        // different URL key.
        as: 'page'
      }
    };
    ```
     @property queryParams
    @for Route
    @type Object
    @since 1.6.0
    @public
  */
  // Set in reopen so it can be overriden with extend

  /**
    The name of the template to use by default when rendering this route's
    template.
     ```app/routes/posts/list.js
    import Route from '@ember/routing/route';
     export default class PostsListRoute extends Route {
      templateName = 'posts/list';
    }
    ```
     ```app/routes/posts/index.js
    import PostsListRoute from '../posts/list';
     export default class PostsIndexRoute extends PostsListRoute {};
    ```
     ```app/routes/posts/archived.js
    import PostsListRoute from '../posts/list';
     export default class PostsArchivedRoute extends PostsListRoute {};
    ```
     @property templateName
    @type String
    @default null
    @since 1.4.0
    @public
  */
  // Set in reopen so it can be overriden with extend

  /**
    The name of the controller to associate with this route.
     By default, Ember will lookup a route's controller that matches the name
    of the route (i.e. `posts.new`). However,
    if you would like to define a specific controller to use, you can do so
    using this property.
     This is useful in many ways, as the controller specified will be:
     * passed to the `setupController` method.
    * used as the controller for the template being rendered by the route.
    * returned from a call to `controllerFor` for the route.
     @property controllerName
    @type String
    @default null
    @since 1.4.0
    @public
  */
  // Set in reopen so it can be overriden with extend

  /**
    The controller associated with this route.
     Example
     ```app/routes/form.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class FormRoute extends Route {
      @action
      willTransition(transition) {
        if (this.controller.get('userHasEnteredData') &&
            !confirm('Are you sure you want to abandon progress?')) {
          transition.abort();
        } else {
          // Bubble the `willTransition` action so that
          // parent routes can decide whether or not to abort.
          return true;
        }
      }
    }
    ```
     @property controller
    @type Controller
    @since 1.6.0
    @public
  */

  /**
    The name of the route, dot-delimited.
     For example, a route found at `app/routes/posts/post.js` will have
    a `routeName` of `posts.post`.
     @property routeName
    @for Route
    @type String
    @since 1.0.0
    @public
  */

  /**
    The name of the route, dot-delimited, including the engine prefix
    if applicable.
     For example, a route found at `addon/routes/posts/post.js` within an
    engine named `admin` will have a `fullRouteName` of `admin.posts.post`.
     @property fullRouteName
    @for Route
    @type String
    @since 2.10.0
    @public
  */

  /**
    Sets the name for this route, including a fully resolved name for routes
    inside engines.
     @private
    @method _setRouteName
    @param {String} name
  */
  _setRouteName(name) {
    this.routeName = name;
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner instanceof EmberEngineInstance) && assert('Expected route to have EngineInstance as owner', owner instanceof EmberEngineInstance));
    this.fullRouteName = getEngineRouteName(owner, name);
  }

  /**
    @private
     @method _stashNames
  */
  _stashNames(routeInfo, dynamicParent) {
    if (this._names) {
      return;
    }
    let names = this._names = routeInfo['_names'];
    if (!names.length) {
      routeInfo = dynamicParent;
      names = routeInfo && routeInfo['_names'] || [];
    }

    // SAFETY: Since `_qp` is protected we can't infer the type
    let qps = get(this, '_qp').qps;
    let namePaths = new Array(names.length);
    for (let a = 0; a < names.length; ++a) {
      namePaths[a] = `${routeInfo.name}.${names[a]}`;
    }
    for (let qp of qps) {
      if (qp.scope === 'model') {
        qp.parts = namePaths;
      }
    }
  }

  /**
    @private
     @property _activeQPChanged
  */
  _activeQPChanged(qp, value) {
    this._router._activeQPChanged(qp.scopedPropertyName, value);
  }

  /**
    @private
    @method _updatingQPChanged
  */
  _updatingQPChanged(qp) {
    this._router._updatingQPChanged(qp.urlKey);
  }

  /**
    Returns a hash containing the parameters of an ancestor route.
     You may notice that `this.paramsFor` sometimes works when referring to a
    child route, but this behavior should not be relied upon as only ancestor
    routes are certain to be loaded in time.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('member', { path: ':name' }, function() {
        this.route('interest', { path: ':interest' });
      });
    });
    ```
     ```app/routes/member.js
    import Route from '@ember/routing/route';
     export default class MemberRoute extends Route {
      queryParams = {
        memberQp: { refreshModel: true }
      }
    }
    ```
     ```app/routes/member/interest.js
    import Route from '@ember/routing/route';
     export default class MemberInterestRoute extends Route {
      queryParams = {
        interestQp: { refreshModel: true }
      }
       model() {
        return this.paramsFor('member');
      }
    }
    ```
     If we visit `/turing/maths?memberQp=member&interestQp=interest` the model for
    the `member.interest` route is a hash with:
     * `name`: `turing`
    * `memberQp`: `member`
     @method paramsFor
    @param {String} name
    @return {Object} hash containing the parameters of the route `name`
    @since 1.4.0
    @public
  */
  paramsFor(name) {
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
    let route = owner.lookup(`route:${name}`);
    if (route === undefined) {
      return {};
    }
    let transition = this._router._routerMicrolib.activeTransition;
    let state = transition ? transition[STATE_SYMBOL] : this._router._routerMicrolib.state;
    let fullName = route.fullRouteName;
    let params = {
      ...state.params[fullName]
    };
    let queryParams = getQueryParamsFor(route, state);
    return Object.entries(queryParams).reduce((params, [key, value]) => {
      (isDevelopingApp() && !(!params[key]) && assert(`The route '${this.routeName}' has both a dynamic segment and query param with name '${key}'. Please rename one to avoid collisions.`, !params[key]));
      params[key] = value;
      return params;
    }, params);
  }

  /**
    Serializes the query parameter key
     @method serializeQueryParamKey
    @param {String} controllerPropertyName
    @private
  */
  serializeQueryParamKey(controllerPropertyName) {
    return controllerPropertyName;
  }

  /**
    Serializes value of the query parameter based on defaultValueType
     @method serializeQueryParam
    @param {Object} value
    @param {String} urlKey
    @param {String} defaultValueType
    @private
  */
  serializeQueryParam(value, _urlKey, defaultValueType) {
    // urlKey isn't used here, but anyone overriding
    // can use it to provide serialization specific
    // to a certain query param.
    return this._router._serializeQueryParam(value, defaultValueType);
  }

  /**
    Deserializes value of the query parameter based on defaultValueType
     @method deserializeQueryParam
    @param {Object} value
    @param {String} urlKey
    @param {String} defaultValueType
    @private
  */
  deserializeQueryParam(value, _urlKey, defaultValueType) {
    // urlKey isn't used here, but anyone overriding
    // can use it to provide deserialization specific
    // to a certain query param.
    return this._router._deserializeQueryParam(value, defaultValueType);
  }

  /**
    @private
     @property _optionsForQueryParam
  */
  _optionsForQueryParam(qp) {
    const queryParams = get(this, 'queryParams');
    return get(queryParams, qp.urlKey) || get(queryParams, qp.prop) || queryParams[qp.urlKey] || queryParams[qp.prop] || {};
  }

  /**
    A hook you can use to reset controller values either when the model
    changes or the route is exiting.
     ```app/routes/articles.js
    import Route from '@ember/routing/route';
     export default class ArticlesRoute extends Route {
      resetController(controller, isExiting, transition) {
        if (isExiting && transition.targetName !== 'error') {
          controller.set('page', 1);
        }
      }
    }
    ```
     @method resetController
    @param {Controller} controller instance
    @param {Boolean} isExiting
    @param {Object} transition
    @since 1.7.0
    @public
  */
  resetController(_controller, _isExiting, _transition) {
    // We document that subclasses do not have to return *anything* and in fact
    // do not even have to call super, so whiel we *do* return `this`, we need
    // to be explicit in the types that our return type is *effectively* `void`.
    return this;
  }

  /**
    @private
     @method exit
  */
  exit(transition) {
    this.deactivate(transition);
    this.trigger('deactivate', transition);
    this.teardownViews();
  }

  /**
    @private
     @method _internalReset
    @since 3.6.0
  */
  _internalReset(isExiting, transition) {
    let controller = this.controller;
    // SAFETY: Since `_qp` is protected we can't infer the type
    controller['_qpDelegate'] = get(this, '_qp').states.inactive;
    this.resetController(controller, isExiting, transition);
  }

  /**
    @private
     @method enter
  */
  enter(transition) {
    this[RENDER_STATE] = undefined;
    this.activate(transition);
    this.trigger('activate', transition);
  }

  /**
    This event is triggered when the router enters the route. It is
    not executed when the model for the route changes.
     ```app/routes/application.js
    import { on } from '@ember/object/evented';
    import Route from '@ember/routing/route';
     export default Route.extend({
      collectAnalytics: on('activate', function(){
        collectAnalytics();
      })
    });
    ```
     @event activate
    @since 1.9.0
    @public
  */

  /**
    This event is triggered when the router completely exits this
    route. It is not executed when the model for the route changes.
     ```app/routes/index.js
    import { on } from '@ember/object/evented';
    import Route from '@ember/routing/route';
     export default Route.extend({
      trackPageLeaveAnalytics: on('deactivate', function(){
        trackPageLeaveAnalytics();
      })
    });
    ```
     @event deactivate
    @since 1.9.0
    @public
  */

  /**
    This hook is executed when the router completely exits this route. It is
    not executed when the model for the route changes.
     @method deactivate
    @param {Transition} transition
    @since 1.0.0
    @public
  */
  deactivate(_transition) {}

  /**
    This hook is executed when the router enters the route. It is not executed
    when the model for the route changes.
     @method activate
    @param {Transition} transition
    @since 1.0.0
    @public
  */
  activate(_transition) {}

  /**
    Perform a synchronous transition into another route without attempting
    to resolve promises, update the URL, or abort any currently active
    asynchronous transitions (i.e. regular transitions caused by
    `transitionTo` or URL changes).
     This method is handy for performing intermediate transitions on the
    way to a final destination route, and is called internally by the
    default implementations of the `error` and `loading` handlers.
     @method intermediateTransitionTo
    @param {String} name the name of the route
    @param {...Object} models the model(s) to be used while transitioning
    to the route.
    @since 1.2.0
    @public
   */
  intermediateTransitionTo(...args) {
    let [name, ...preparedArgs] = prefixRouteNameArg(this, args);
    this._router.intermediateTransitionTo(name, ...preparedArgs);
  }

  /**
    Refresh the model on this route and any child routes, firing the
    `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
    to how routes are entered when transitioning in from other route.
    The current route params (e.g. `article_id`) will be passed in
    to the respective model hooks, and if a different model is returned,
    `setupController` and associated route hooks will re-fire as well.
     An example usage of this method is re-querying the server for the
    latest information using the same parameters as when the route
    was first entered.
     Note that this will cause `model` hooks to fire even on routes
    that were provided a model object when the route was initially
    entered.
     @method refresh
    @return {Transition} the transition object associated with this
      attempted transition
    @since 1.4.0
    @public
   */
  refresh() {
    return this._router._routerMicrolib.refresh(this);
  }

  /**
    This hook is the entry point for router.js
     @private
    @method setup
  */
  setup(context, transition) {
    let controllerName = this.controllerName || this.routeName;
    let definedController = this.controllerFor(controllerName, true);
    let controller = definedController ?? this.generateController(controllerName);

    // SAFETY: Since `_qp` is protected we can't infer the type
    let queryParams = get(this, '_qp');

    // Assign the route's controller so that it can more easily be
    // referenced in action handlers. Side effects. Side effects everywhere.
    if (!this.controller) {
      let propNames = queryParams.propertyNames;
      addQueryParamsObservers(controller, propNames);
      this.controller = controller;
    }
    let states = queryParams.states;
    controller._qpDelegate = states.allowOverrides;
    if (transition) {
      // Update the model dep values used to calculate cache keys.
      stashParamNames(this._router, transition[STATE_SYMBOL].routeInfos);
      let cache = this._bucketCache;
      let params = transition[PARAMS_SYMBOL];
      let allParams = queryParams.propertyNames;
      allParams.forEach(prop => {
        let aQp = queryParams.map[prop];
        (isDevelopingApp() && !(aQp) && assert('expected aQp', aQp));
        aQp.values = params;
        let cacheKey = calculateCacheKey(aQp.route.fullRouteName, aQp.parts, aQp.values);
        let value = cache.lookup(cacheKey, prop, aQp.undecoratedDefaultValue);
        set(controller, prop, value);
      });
      let qpValues = getQueryParamsFor(this, transition[STATE_SYMBOL]);
      setProperties(controller, qpValues);
    }
    this.setupController(controller, context, transition);
    if (this._environment.options.shouldRender) {
      this[RENDER]();
    }

    // Setup can cause changes to QPs which need to be propogated immediately in
    // some situations. Eventually, we should work on making these async somehow.
    flushAsyncObservers(false);
  }

  /*
    Called when a query parameter for this route changes, regardless of whether the route
    is currently part of the active route hierarchy. This will update the query parameter's
    value in the cache so if this route becomes active, the cache value has been updated.
  */
  _qpChanged(prop, value, qp) {
    if (!qp) {
      return;
    }

    // Update model-dep cache
    let cache = this._bucketCache;
    let cacheKey = calculateCacheKey(qp.route.fullRouteName, qp.parts, qp.values);
    cache.stash(cacheKey, prop, value);
  }

  /**
    This hook is the first of the route entry validation hooks
    called when an attempt is made to transition into a route
    or one of its children. It is called before `model` and
    `afterModel`, and is appropriate for cases when:
     1) A decision can be made to redirect elsewhere without
       needing to resolve the model first.
    2) Any async operations need to occur first before the
       model is attempted to be resolved.
     This hook is provided the current `transition` attempt
    as a parameter, which can be used to `.abort()` the transition,
    save it for a later `.retry()`, or retrieve values set
    on it from a previous hook. You can also just call
    `router.transitionTo` to another route to implicitly
    abort the `transition`.
     You can return a promise from this hook to pause the
    transition until the promise resolves (or rejects). This could
    be useful, for instance, for retrieving async code from
    the server that is required to enter a route.
     @method beforeModel
    @param {Transition} transition
    @return {any | Promise<any>} if the value returned from this hook is
      a promise, the transition will pause until the transition
      resolves. Otherwise, non-promise return values are not
      utilized in any way.
    @since 1.0.0
    @public
  */

  beforeModel(_transition) {}

  /**
    This hook is called after this route's model has resolved.
    It follows identical async/promise semantics to `beforeModel`
    but is provided the route's resolved model in addition to
    the `transition`, and is therefore suited to performing
    logic that can only take place after the model has already
    resolved.
     ```app/routes/posts.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PostsRoute extends Route {
      @service router;
       afterModel(posts, transition) {
        if (posts.get('length') === 1) {
          this.router.transitionTo('post.show', posts.get('firstObject'));
        }
      }
    }
    ```
     Refer to documentation for `beforeModel` for a description
    of transition-pausing semantics when a promise is returned
    from this hook.
     @method afterModel
    @param {Object} resolvedModel the value returned from `model`,
      or its resolved value if it was a promise
    @param {Transition} transition
    @return {any | Promise<any>} if the value returned from this hook is
      a promise, the transition will pause until the transition
      resolves. Otherwise, non-promise return values are not
      utilized in any way.
    @since 1.0.0
    @public
   */

  afterModel(_resolvedModel, _transition) {}

  /**
    A hook you can implement to optionally redirect to another route.
     Calling `this.router.transitionTo` from inside of the `redirect` hook will
    abort the current transition (into the route that has implemented `redirect`).
     `redirect` and `afterModel` behave very similarly and are
    called almost at the same time, but they have an important
    distinction when calling `this.router.transitionTo` to a child route
    of the current route. From `afterModel`, this new transition
    invalidates the current transition, causing `beforeModel`,
    `model`, and `afterModel` hooks to be called again. But the
    same transition started from `redirect` does _not_ invalidate
    the current transition. In other words, by the time the `redirect`
    hook has been called, both the resolved model and the attempted
    entry into this route are considered fully validated.
     @method redirect
    @param {Object} model the model for this route
    @param {Transition} transition the transition object associated with the current transition
    @since 1.0.0
    @public
  */
  redirect(_model, _transition) {}

  /**
    Called when the context is changed by router.js.
     @private
    @method contextDidChange
  */
  contextDidChange() {
    this.currentModel = this.context;
  }

  /**
    A hook you can implement to convert the URL into the model for
    this route.
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     export default Router;
    ```
     Note that for routes with dynamic segments, this hook is not always
    executed. If the route is entered through a transition (e.g. when
    using the `link-to` Handlebars helper or the `transitionTo` method
    of routes), and a model context is already provided this hook
    is not called.
     A model context does not include a primitive string or number,
    which does cause the model hook to be called.
     Routes without dynamic segments will always execute the model hook.
     ```javascript
    // no dynamic segment, model hook always called
    this.router.transitionTo('posts');
     // model passed in, so model hook not called
    thePost = store.findRecord('post', 1);
    this.router.transitionTo('post', thePost);
     // integer passed in, model hook is called
    this.router.transitionTo('post', 1);
     // model id passed in, model hook is called
    // useful for forcing the hook to execute
    thePost = store.findRecord('post', 1);
    this.router.transitionTo('post', thePost.id);
    ```
     This hook follows the asynchronous/promise semantics
    described in the documentation for `beforeModel`. In particular,
    if a promise returned from `model` fails, the error will be
    handled by the `error` hook on `Route`.
     Note that the legacy behavior of automatically defining a model
    hook when a dynamic segment ending in `_id` is present is
    [deprecated](https://deprecations.emberjs.com/v5.x#toc_deprecate-implicit-route-model).
    You should explicitly define a model hook whenever any segments are
    present.
     Example
     ```app/routes/post.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PostRoute extends Route {
      @service store;
       model(params) {
        return this.store.findRecord('post', params.post_id);
      }
    }
    ```
     @method model
    @param {Object} params the parameters extracted from the URL
    @param {Transition} transition
    @return {any | Promise<any>} the model for this route. If
      a promise is returned, the transition will pause until
      the promise resolves, and the resolved value of the promise
      will be used as the model for this route.
    @since 1.0.0
    @public
  */
  model(params, transition) {
    let name, sawParams, value;
    // SAFETY: Since `_qp` is protected we can't infer the type
    let queryParams = get(this, '_qp').map;
    for (let prop in params) {
      if (prop === 'queryParams' || queryParams && prop in queryParams) {
        continue;
      }
      let match = prop.match(/^(.*)_id$/);
      if (match !== null) {
        name = match[1];
        value = params[prop];
      }
      sawParams = true;
    }
    if (!name) {
      if (sawParams) {
        // SAFETY: This should be equivalent
        return Object.assign({}, params);
      } else {
        if (transition.resolveIndex < 1) {
          return;
        }
        // SAFETY: This should be correct, but TS is unable to infer this.
        return transition[STATE_SYMBOL].routeInfos[transition.resolveIndex - 1].context;
      }
    }
    return this.findModel(name, value);
  }

  /**
    @private
    @method deserialize
    @param {Object} params the parameters extracted from the URL
    @param {Transition} transition
    @return {any | Promise<any>} the model for this route.
     Router.js hook.
   */
  deserialize(_params, transition) {
    return this.model(this._paramsFor(this.routeName, _params), transition);
  }

  /**
     @method findModel
    @param {String} type the model type
    @param {Object} value the value passed to find
    @private
  */
  findModel(type, value) {
    if (ENV._NO_IMPLICIT_ROUTE_MODEL) {
      return;
    }
    deprecateUntil(`The implicit model loading behavior for routes is deprecated. ` + `Please define an explicit model hook for ${this.fullRouteName}.`, DEPRECATIONS.DEPRECATE_IMPLICIT_ROUTE_MODEL);
    const store = 'store' in this ? this.store : get(this, '_store');
    (isDevelopingApp() && !(isStoreLike(store)) && assert('Expected route to have a store with a find method', isStoreLike(store))); // SAFETY: We don't actually know it will return this, but this code path is also deprecated.
    return store.find(type, value);
  }

  /**
    A hook you can use to setup the controller for the current route.
     This method is called with the controller for the current route and the
    model supplied by the `model` hook.
     By default, the `setupController` hook sets the `model` property of
    the controller to the specified `model` when it is not `undefined`.
     If you implement the `setupController` hook in your Route, it will
    prevent this default behavior. If you want to preserve that behavior
    when implementing your `setupController` function, make sure to call
    `super`:
     ```app/routes/photos.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PhotosRoute extends Route {
      @service store;
       model() {
        return this.store.findAll('photo');
      }
       setupController(controller, model) {
        super.setupController(controller, model);
         this.controllerFor('application').set('showingPhotos', true);
      }
    }
    ```
     The provided controller will be one resolved based on the name
    of this route.
     If no explicit controller is defined, Ember will automatically create one.
     As an example, consider the router:
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     export default Router;
    ```
     If you have defined a file for the post controller,
    the framework will use it.
    If it is not defined, a basic `Controller` instance would be used.
     @example Behavior of a basic Controller
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      setupController(controller, model) {
        controller.set('model', model);
      }
    });
    ```
     @method setupController
    @param {Controller} controller instance
    @param {Object} model
    @param {Transition} [transition]
    @since 1.0.0
    @public
  */
  setupController(controller, context, _transition) {
    if (controller && context !== undefined) {
      set(controller, 'model', context);
    }
  }

  /**
    Returns the controller of the current route, or a parent (or any ancestor)
    route in a route hierarchy.
     The controller instance must already have been created, either through entering the
    associated route or using `generateController`.
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      setupController(controller, post) {
        super.setupController(controller, post);
         this.controllerFor('posts').set('currentPost', post);
      }
    }
    ```
     @method controllerFor
    @param {String} name the name of the route or controller
    @return {Controller | undefined}
    @since 1.0.0
    @public
  */

  controllerFor(name, _skipAssert = false) {
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
    let route = owner.lookup(`route:${name}`);
    if (route && route.controllerName) {
      name = route.controllerName;
    }
    let controller = owner.lookup(`controller:${name}`);

    // NOTE: We're specifically checking that skipAssert is true, because according
    //   to the old API the second parameter was model. We do not want people who
    //   passed a model to skip the assertion.
    (isDevelopingApp() && !(controller !== undefined || _skipAssert === true) && assert(`The controller named '${name}' could not be found. Make sure that this route exists and has already been entered at least once. If you are accessing a controller not associated with a route, make sure the controller class is explicitly defined.`, controller !== undefined || _skipAssert === true));
    (isDevelopingApp() && !(controller === undefined || controller instanceof Controller) && assert(`Expected controller:${name} to be an instance of Controller`, controller === undefined || controller instanceof Controller));
    return controller;
  }

  /**
    Generates a controller for a route.
     Example
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class Post extends Route {
      setupController(controller, post) {
        super.setupController(controller, post);
         this.generateController('posts');
      }
    }
    ```
     @method generateController
    @param {String} name the name of the controller
    @private
  */
  generateController(name) {
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
    return generateController(owner, name);
  }

  /**
    Returns the resolved model of a parent (or any ancestor) route
    in a route hierarchy.  During a transition, all routes
    must resolve a model object, and if a route
    needs access to a parent route's model in order to
    resolve a model (or just reuse the model from a parent),
    it can call `this.modelFor(theNameOfParentRoute)` to
    retrieve it. If the ancestor route's model was a promise,
    its resolved result is returned.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' }, function() {
        this.route('comments');
      });
    });
     export default Router;
    ```
     ```app/routes/post/comments.js
    import Route from '@ember/routing/route';
     export default class PostCommentsRoute extends Route {
      model() {
        let post = this.modelFor('post');
         return post.comments;
      }
    }
    ```
     @method modelFor
    @param {String} name the name of the route
    @return {Object} the model object
    @since 1.0.0
    @public
  */
  modelFor(_name) {
    let name;
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner instanceof EmberEngineInstance) && assert('Expected router owner to be an EngineInstance', owner instanceof EmberEngineInstance));
    let transition = this._router && this._router._routerMicrolib ? this._router._routerMicrolib.activeTransition : undefined;

    // Only change the route name when there is an active transition.
    // Otherwise, use the passed in route name.
    if (owner.routable && transition !== undefined) {
      name = getEngineRouteName(owner, _name);
    } else {
      name = _name;
    }
    let route = owner.lookup(`route:${name}`);
    // If we are mid-transition, we want to try and look up
    // resolved parent contexts on the current transitionEvent.
    if (transition !== undefined && transition !== null) {
      let modelLookupName = route && route.routeName || name;
      if (Object.prototype.hasOwnProperty.call(transition.resolvedModels, modelLookupName)) {
        return transition.resolvedModels[modelLookupName];
      }
    }
    return route?.currentModel;
  }
  [RENDER_STATE] = undefined;

  /**
    `this[RENDER]` is used to set up the rendering option for the outlet state.
    @method this[RENDER]
    @private
   */
  [RENDER]() {
    this[RENDER_STATE] = buildRenderState(this);
    once(this._router, '_setOutlets');
  }
  willDestroy() {
    this.teardownViews();
  }

  /**
    @private
     @method teardownViews
  */
  teardownViews() {
    if (this[RENDER_STATE]) {
      this[RENDER_STATE] = undefined;
      once(this._router, '_setOutlets');
    }
  }

  /**
    Allows you to produce custom metadata for the route.
    The return value of this method will be attached to
    its corresponding RouteInfoWithAttributes object.
     Example
     ```app/routes/posts/index.js
    import Route from '@ember/routing/route';
     export default class PostsIndexRoute extends Route {
      buildRouteInfoMetadata() {
        return { title: 'Posts Page' }
      }
    }
    ```
     ```app/routes/application.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class ApplicationRoute extends Route {
      @service router
       constructor() {
        super(...arguments);
         this.router.on('routeDidChange', transition => {
          document.title = transition.to.metadata.title;
          // would update document's title to "Posts Page"
        });
      }
    }
    ```
    @method buildRouteInfoMetadata
    @return any
    @since 3.10.0
    @public
   */

  buildRouteInfoMetadata() {}
  _paramsFor(routeName, params) {
    let transition = this._router._routerMicrolib.activeTransition;
    if (transition !== undefined) {
      return this.paramsFor(routeName);
    }
    return params;
  }

  /** @deprecated Manually define your own store, such as with `@service store` */
  get _store() {
    const owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
    let routeName = this.routeName;
    return {
      find(name, value) {
        let modelClass = owner.factoryFor(`model:${name}`);
        (isDevelopingApp() && !(Boolean(modelClass)) && assert(`You used the dynamic segment \`${name}_id\` in your route ` + `\`${routeName}\` for which Ember requires you provide a ` + `data-loading implementation. Commonly, that is done by ` + `adding a model hook implementation on the route ` + `(\`model({${name}_id}) {\`) or by injecting an implemention of ` + `a data store: \`@service store;\`.`, Boolean(modelClass)));
        if (!modelClass) {
          return;
        }
        modelClass = modelClass.class;
        (isDevelopingApp() && !(typeof modelClass.find === 'function') && assert(`You used the dynamic segment \`${name}_id\` in your route ` + `\`${routeName}\` for which Ember requires you provide a ` + `data-loading implementation. Commonly, that is done by ` + `adding a model hook implementation on the route ` + `(\`model({${name}_id}) {\`) or by injecting an implemention of ` + `a data store: \`@service store;\`.\n\n` + `Rarely, applications may attempt to use a legacy behavior where ` + `the model class (in this case \`${name}\`) is resolved and the ` + `\`find\` method on that class is invoked to load data. In this ` + `application, a model of \`${name}\` was found but it did not ` + `provide a \`find\` method. You should not add a \`find\` ` + `method to your model. Instead, please implement an appropriate ` + `\`model\` hook on the \`${routeName}\` route.`, typeof modelClass.find === 'function'));
        return modelClass.find(value);
      }
    };
  }

  /**
    @private
    @property _qp
    */
  static {
    decorateMethodV2(this.prototype, "_store", [computed]);
  }
  get _qp() {
    let combinedQueryParameterConfiguration = {};
    let controllerName = this.controllerName || this.routeName;
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
    let controller = owner.lookup(`controller:${controllerName}`);
    let queryParameterConfiguraton = get(this, 'queryParams');
    let hasRouterDefinedQueryParams = Object.keys(queryParameterConfiguraton).length > 0;
    if (controller) {
      (isDevelopingApp() && !(controller instanceof Controller) && assert('Expected an instance of controller', controller instanceof Controller)); // the developer has authored a controller class in their application for
      // this route find its query params and normalize their object shape them
      // merge in the query params for the route. As a mergedProperty,
      // Route#queryParams is always at least `{}`
      let controllerDefinedQueryParameterConfiguration = get(controller, 'queryParams') || [];
      let normalizedControllerQueryParameterConfiguration = normalizeControllerQueryParams(controllerDefinedQueryParameterConfiguration);
      combinedQueryParameterConfiguration = mergeEachQueryParams(normalizedControllerQueryParameterConfiguration, queryParameterConfiguraton);
    } else if (hasRouterDefinedQueryParams) {
      // the developer has not defined a controller but *has* supplied route query params.
      // Generate a class for them so we can later insert default values
      controller = generateController(owner, controllerName);
      combinedQueryParameterConfiguration = queryParameterConfiguraton;
    }
    let qps = [];
    let map = {};
    let propertyNames = [];
    for (let propName in combinedQueryParameterConfiguration) {
      if (!Object.prototype.hasOwnProperty.call(combinedQueryParameterConfiguration, propName)) {
        continue;
      }

      // to support the dubious feature of using unknownProperty
      // on queryParams configuration
      if (propName === 'unknownProperty' || propName === '_super') {
        // possible todo: issue deprecation warning?
        continue;
      }
      let desc = combinedQueryParameterConfiguration[propName];
      (isDevelopingApp() && !(desc) && assert(`[BUG] missing query parameter configuration for ${propName}`, desc));
      let scope = desc.scope || 'model';
      let parts = undefined;
      if (scope === 'controller') {
        parts = [];
      }
      let urlKey = desc.as || this.serializeQueryParamKey(propName);
      let defaultValue = get(controller, propName);
      defaultValue = copyDefaultValue(defaultValue);
      let type = desc.type || typeOf(defaultValue);
      let defaultValueSerialized = this.serializeQueryParam(defaultValue, urlKey, type);
      let scopedPropertyName = `${controllerName}:${propName}`;
      let qp = {
        undecoratedDefaultValue: get(controller, propName),
        defaultValue,
        serializedDefaultValue: defaultValueSerialized,
        serializedValue: defaultValueSerialized,
        type,
        urlKey,
        prop: propName,
        scopedPropertyName,
        controllerName,
        route: this,
        parts,
        // provided later when stashNames is called if 'model' scope
        values: null,
        // provided later when setup is called. no idea why.
        scope
      };
      map[propName] = map[urlKey] = map[scopedPropertyName] = qp;
      qps.push(qp);
      propertyNames.push(propName);
    }
    return {
      qps,
      map,
      propertyNames,
      states: {
        /*
          Called when a query parameter changes in the URL, this route cares
          about that query parameter, but the route is not currently
          in the active route hierarchy.
        */
        inactive: (prop, value) => {
          let qp = map[prop];
          (isDevelopingApp() && !(qp) && assert('expected inactive callback to only be called for registered qps', qp));
          this._qpChanged(prop, value, qp);
        },
        /*
          Called when a query parameter changes in the URL, this route cares
          about that query parameter, and the route is currently
          in the active route hierarchy.
        */
        active: (prop, value) => {
          let qp = map[prop];
          (isDevelopingApp() && !(qp) && assert('expected active callback to only be called for registered qps', qp));
          this._qpChanged(prop, value, qp);
          return this._activeQPChanged(qp, value);
        },
        /*
          Called when a value of a query parameter this route handles changes in a controller
          and the route is currently in the active route hierarchy.
        */
        allowOverrides: (prop, value) => {
          let qp = map[prop];
          (isDevelopingApp() && !(qp) && assert('expected allowOverrides callback to only be called for registered qps', qp));
          this._qpChanged(prop, value, qp);
          return this._updatingQPChanged(qp);
        }
      }
    };
  }

  // Set in reopen
  static {
    decorateMethodV2(this.prototype, "_qp", [computed]);
  }
  /**
    Sends an action to the router, which will delegate it to the currently
    active route hierarchy per the bubbling rules explained under `actions`.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('index');
    });
     export default Router;
    ```
     ```app/routes/application.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class ApplicationRoute extends Route {
      @action
      track(arg) {
        console.log(arg, 'was clicked');
      }
    }
    ```
     ```app/routes/index.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class IndexRoute extends Route {
      @action
      trackIfDebug(arg) {
        if (debug) {
          this.send('track', arg);
        }
      }
    }
    ```
     @method send
    @param {String} name the name of the action to trigger
    @param {...*} args
    @since 1.0.0
    @public
  */
  // Set with reopen to override parent behavior
}
function getRenderState(route) {
  return route[RENDER_STATE];
}
function buildRenderState(route) {
  let owner = getOwner(route);
  (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
  let name = route.routeName;
  let controller = owner.lookup(`controller:${route.controllerName || name}`);
  (isDevelopingApp() && !(controller instanceof Controller) && assert('Expected an instance of controller', controller instanceof Controller));
  let model = route.currentModel;
  let template = owner.lookup(`template:${route.templateName || name}`);
  let render = {
    owner,
    into: undefined,
    outlet: 'main',
    name,
    controller,
    model,
    template: template?.(owner) ?? route._topLevelViewTemplate(owner)
  };
  if (isDevelopingApp()) {
    let LOG_VIEW_LOOKUPS = get(route._router, 'namespace.LOG_VIEW_LOOKUPS');
    if (LOG_VIEW_LOOKUPS && !template) {
      info(`Could not find "${name}" template. Nothing will be rendered`, {
        fullName: `template:${name}`
      });
    }
  }
  return render;
}
function getFullQueryParams(router, state) {
  if (state.fullQueryParams) {
    return state.fullQueryParams;
  }
  let haveAllRouteInfosResolved = state.routeInfos.every(routeInfo => routeInfo.route);
  let fullQueryParamsState = {
    ...state.queryParams
  };
  router._deserializeQueryParams(state.routeInfos, fullQueryParamsState);

  // only cache query params state if all routeinfos have resolved; it's possible
  // for lazy routes to not have resolved when `getFullQueryParams` is called, so
  // we wait until all routes have resolved prior to caching query params state
  if (haveAllRouteInfosResolved) {
    state.fullQueryParams = fullQueryParamsState;
  }
  return fullQueryParamsState;
}
function getQueryParamsFor(route, state) {
  state.queryParamsFor = state.queryParamsFor || {};
  let name = route.fullRouteName;
  let existing = state.queryParamsFor[name];
  if (existing) {
    return existing;
  }
  let fullQueryParams = getFullQueryParams(route._router, state);
  let params = state.queryParamsFor[name] = {};

  // Copy over all the query params for this route/controller into params hash.
  // SAFETY: Since `_qp` is protected we can't infer the type
  let qps = get(route, '_qp').qps;
  for (let qp of qps) {
    // Put deserialized qp on params hash.
    let qpValueWasPassedIn = (qp.prop in fullQueryParams);
    params[qp.prop] = qpValueWasPassedIn ? fullQueryParams[qp.prop] : copyDefaultValue(qp.defaultValue);
  }
  return params;
}

// FIXME: This should probably actually return a `NativeArray` if the passed in value is an Array.
function copyDefaultValue(value) {
  if (Array.isArray(value)) {
    // SAFETY: We lost the type data about the array if we don't cast.
    return A(value.slice());
  }
  return value;
}

/*
  Merges all query parameters from a controller with those from
  a route, returning a new object and avoiding any mutations to
  the existing objects.
*/
function mergeEachQueryParams(controllerQP, routeQP) {
  let qps = {};
  let keysAlreadyMergedOrSkippable = {
    defaultValue: true,
    type: true,
    scope: true,
    as: true
  };

  // first loop over all controller qps, merging them with any matching route qps
  // into a new empty object to avoid mutating.
  for (let cqpName in controllerQP) {
    if (!Object.prototype.hasOwnProperty.call(controllerQP, cqpName)) {
      continue;
    }
    qps[cqpName] = {
      ...controllerQP[cqpName],
      ...routeQP[cqpName]
    };

    // allows us to skip this QP when we check route QPs.
    keysAlreadyMergedOrSkippable[cqpName] = true;
  }

  // loop over all route qps, skipping those that were merged in the first pass
  // because they also appear in controller qps
  for (let rqpName in routeQP) {
    if (!Object.prototype.hasOwnProperty.call(routeQP, rqpName) || keysAlreadyMergedOrSkippable[rqpName]) {
      continue;
    }
    qps[rqpName] = {
      ...routeQP[rqpName],
      ...controllerQP[rqpName]
    };
  }
  return qps;
}
function addQueryParamsObservers(controller, propNames) {
  propNames.forEach(prop => {
    if (descriptorForProperty(controller, prop) === undefined) {
      let desc = lookupDescriptor(controller, prop);
      if (desc !== null && (typeof desc.get === 'function' || typeof desc.set === 'function')) {
        defineProperty(controller, prop, dependentKeyCompat({
          get: desc.get,
          set: desc.set
        }));
      }
    }
    addObserver(controller, `${prop}.[]`, controller, controller._qpChanged, false);
  });
}
function getEngineRouteName(engine, routeName) {
  if (engine.routable) {
    let prefix = engine.mountPoint;
    if (routeName === 'application') {
      return prefix;
    } else {
      return `${prefix}.${routeName}`;
    }
  }
  return routeName;
}
const defaultSerialize = Route.prototype.serialize;
function hasDefaultSerialize(route) {
  return route.serialize === defaultSerialize;
}

// Set these here so they can be overridden with extend
Route.reopen({
  mergedProperties: ['queryParams'],
  queryParams: {},
  templateName: null,
  controllerName: null,
  send(...args) {
    (isDevelopingApp() && !(!this.isDestroying && !this.isDestroyed) && assert(`Attempted to call .send() with the action '${args[0]}' on the destroyed route '${this.routeName}'.`, !this.isDestroying && !this.isDestroyed));
    if (this._router && this._router._routerMicrolib || !isTesting()) {
      this._router.send(...args);
    } else {
      let name = args.shift();
      let action = this.actions[name];
      if (action) {
        return action.apply(this, args);
      }
    }
  },
  /**
    The controller associated with this route.
     Example
     ```app/routes/form.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class FormRoute extends Route {
      @action
      willTransition(transition) {
        if (this.controller.get('userHasEnteredData') &&
            !confirm('Are you sure you want to abandon progress?')) {
          transition.abort();
        } else {
          // Bubble the `willTransition` action so that
          // parent routes can decide whether or not to abort.
          return true;
        }
      }
    }
    ```
     @property controller
    @type Controller
    @since 1.6.0
    @public
  */

  actions: {
    /**
    This action is called when one or more query params have changed. Bubbles.
     @method queryParamsDidChange
    @param changed {Object} Keys are names of query params that have changed.
    @param totalPresent {Object} Keys are names of query params that are currently set.
    @param removed {Object} Keys are names of query params that have been removed.
    @returns {boolean}
    @private
    */
    queryParamsDidChange(changed, _totalPresent, removed) {
      // SAFETY: Since `_qp` is protected we can't infer the type
      let qpMap = get(this, '_qp').map;
      let totalChanged = Object.keys(changed).concat(Object.keys(removed));
      for (let change of totalChanged) {
        let qp = qpMap[change];
        if (qp) {
          let options = this._optionsForQueryParam(qp);
          (isDevelopingApp() && !(options && typeof options === 'object') && assert('options exists', options && typeof options === 'object'));
          if (get(options, 'refreshModel') && this._router.currentState) {
            this.refresh();
            break;
          }
        }
      }
      return true;
    },
    finalizeQueryParamChange(params, finalParams, transition) {
      if (this.fullRouteName !== 'application') {
        return true;
      }

      // Transition object is absent for intermediate transitions.
      if (!transition) {
        return;
      }
      let routeInfos = transition[STATE_SYMBOL].routeInfos;
      let router = this._router;
      let qpMeta = router._queryParamsFor(routeInfos);
      let changes = router._qpUpdates;
      let qpUpdated = false;
      let replaceUrl;
      stashParamNames(router, routeInfos);
      for (let qp of qpMeta.qps) {
        let route = qp.route;
        let controller = route.controller;
        let presentKey = qp.urlKey in params && qp.urlKey;

        // Do a reverse lookup to see if the changed query
        // param URL key corresponds to a QP property on
        // this controller.
        let value;
        let svalue;
        if (changes.has(qp.urlKey)) {
          // Value updated in/before setupController
          value = get(controller, qp.prop);
          svalue = route.serializeQueryParam(value, qp.urlKey, qp.type);
        } else {
          if (presentKey) {
            svalue = params[presentKey];
            if (svalue !== undefined) {
              value = route.deserializeQueryParam(svalue, qp.urlKey, qp.type);
            }
          } else {
            // No QP provided; use default value.
            svalue = qp.serializedDefaultValue;
            value = copyDefaultValue(qp.defaultValue);
          }
        }

        // SAFETY: Since `_qp` is protected we can't infer the type
        controller._qpDelegate = get(route, '_qp').states.inactive;
        let thisQueryParamChanged = svalue !== qp.serializedValue;
        if (thisQueryParamChanged) {
          if (transition.queryParamsOnly && replaceUrl !== false) {
            let options = route._optionsForQueryParam(qp);
            let replaceConfigValue = get(options, 'replace');
            if (replaceConfigValue) {
              replaceUrl = true;
            } else if (replaceConfigValue === false) {
              // Explicit pushState wins over any other replaceStates.
              replaceUrl = false;
            }
          }
          set(controller, qp.prop, value);
          qpUpdated = true;
        }

        // Stash current serialized value of controller.
        qp.serializedValue = svalue;
        let thisQueryParamHasDefaultValue = qp.serializedDefaultValue === svalue;
        if (!thisQueryParamHasDefaultValue) {
          finalParams.push({
            value: svalue,
            visible: true,
            key: presentKey || qp.urlKey
          });
        }
      }

      // Some QPs have been updated, and those changes need to be propogated
      // immediately. Eventually, we should work on making this async somehow.
      if (qpUpdated === true) {
        flushAsyncObservers(false);
      }
      if (replaceUrl) {
        transition.method('replace');
      }
      qpMeta.qps.forEach(qp => {
        // SAFETY: Since `_qp` is protected we can't infer the type
        let routeQpMeta = get(qp.route, '_qp');
        let finalizedController = qp.route.controller;
        finalizedController['_qpDelegate'] = get(routeQpMeta, 'states.active');
      });
      router._qpUpdates.clear();
      return;
    }
  }
});

/**
@module @ember/routing/router
*/

function defaultDidTransition(infos) {
  updatePaths(this);
  this._cancelSlowTransitionTimer();
  this.notifyPropertyChange('url');
  this.set('currentState', this.targetState);
  if (isDevelopingApp()) {
    // @ts-expect-error namespace isn't public
    if (this.namespace.LOG_TRANSITIONS) {
      // eslint-disable-next-line no-console
      console.log(`Transitioned into '${EmberRouter._routePath(infos)}'`);
    }
  }
}
function defaultWillTransition(oldInfos, newInfos) {
  if (isDevelopingApp()) {
    // @ts-expect-error namespace isn't public
    if (this.namespace.LOG_TRANSITIONS) {
      // eslint-disable-next-line no-console
      console.log(`Preparing to transition from '${EmberRouter._routePath(oldInfos)}' to '${EmberRouter._routePath(newInfos)}'`);
    }
  }
}
let freezeRouteInfo;
if (isDevelopingApp()) {
  freezeRouteInfo = transition => {
    if (transition.from !== null && !Object.isFrozen(transition.from)) {
      Object.freeze(transition.from);
    }
    if (transition.to !== null && !Object.isFrozen(transition.to)) {
      Object.freeze(transition.to);
    }
  };
}
function K() {
  return this;
}
const {
  slice
} = Array.prototype;

/**
  The `EmberRouter` class manages the application state and URLs. Refer to
  the [routing guide](https://guides.emberjs.com/release/routing/) for documentation.

  @class EmberRouter
  @extends EmberObject
  @uses Evented
  @public
*/
class EmberRouter extends EmberObject.extend(Evented) {
  /**
   Represents the URL of the root of the application, often '/'. This prefix is
    assumed on all routes defined on this router.
     @property rootURL
    @default '/'
    @public
  */
  // Set with reopen to allow overriding via extend

  /**
   The `location` property determines the type of URL's that your
    application will use.
     The following location types are currently available:
     * `history` - use the browser's history API to make the URLs look just like any standard URL
    * `hash` - use `#` to separate the server part of the URL from the Ember part: `/blog/#/posts/new`
    * `none` - do not store the Ember URL in the actual browser URL (mainly used for testing)
    * `auto` - use the best option based on browser capabilities: `history` if possible, then `hash` if possible, otherwise `none`
     This value is defaulted to `history` by the `locationType` setting of `/config/environment.js`
     @property location
    @default 'hash'
    @see {Location}
    @public
  */
  // Set with reopen to allow overriding via extend

  _routerMicrolib;
  _didSetupRouter = false;
  _initialTransitionStarted = false;
  currentURL = null;
  currentRouteName = null;
  currentPath = null;
  currentRoute = null;
  _qpCache = Object.create(null);

  // Set of QueryParam['urlKey']
  _qpUpdates = new Set();
  _queuedQPChanges = {};
  _bucketCache;
  _toplevelView = null;
  _handledErrors = new Set();
  _engineInstances = Object.create(null);
  _engineInfoByRoute = Object.create(null);
  _routerService;
  _slowTransitionTimer = null;
  namespace;

  // Begin Evented

  // End Evented

  // Set with reopenClass
  static dslCallbacks;

  /**
    The `Router.map` function allows you to define mappings from URLs to routes
    in your application. These mappings are defined within the
    supplied callback function using `this.route`.
     The first parameter is the name of the route which is used by default as the
    path name as well.
     The second parameter is the optional options hash. Available options are:
       * `path`: allows you to provide your own path as well as mark dynamic
        segments.
      * `resetNamespace`: false by default; when nesting routes, ember will
        combine the route names to form the fully-qualified route name, which is
        used with `{{link-to}}` or manually transitioning to routes. Setting
        `resetNamespace: true` will cause the route not to inherit from its
        parent route's names. This is handy for preventing extremely long route names.
        Keep in mind that the actual URL path behavior is still retained.
     The third parameter is a function, which can be used to nest routes.
    Nested routes, by default, will have the parent route tree's route name and
    path prepended to it's own.
     ```app/router.js
    Router.map(function(){
      this.route('post', { path: '/post/:post_id' }, function() {
        this.route('edit');
        this.route('comments', { resetNamespace: true }, function() {
          this.route('new');
        });
      });
    });
    ```
     @method map
    @param callback
    @public
  */
  static map(callback) {
    if (!this.dslCallbacks) {
      this.dslCallbacks = [];
      // FIXME: Can we remove this?
      this.reopenClass({
        dslCallbacks: this.dslCallbacks
      });
    }
    this.dslCallbacks.push(callback);
    return this;
  }
  static _routePath(routeInfos) {
    let path = [];

    // We have to handle coalescing resource names that
    // are prefixed with their parent's names, e.g.
    // ['foo', 'foo.bar.baz'] => 'foo.bar.baz', not 'foo.foo.bar.baz'

    function intersectionMatches(a1, a2) {
      for (let i = 0; i < a1.length; ++i) {
        if (a1[i] !== a2[i]) {
          return false;
        }
      }
      return true;
    }
    let name, nameParts, oldNameParts;
    for (let i = 1; i < routeInfos.length; i++) {
      let routeInfo = routeInfos[i];
      (isDevelopingApp() && !(routeInfo) && assert('has routeInfo', routeInfo));
      name = routeInfo.name;
      nameParts = name.split('.');
      oldNameParts = slice.call(path);
      while (oldNameParts.length) {
        if (intersectionMatches(oldNameParts, nameParts)) {
          break;
        }
        oldNameParts.shift();
      }
      path.push(...nameParts.slice(oldNameParts.length));
    }
    return path.join('.');
  }

  // Note that owner is actually required in this scenario, but since it is strictly
  // optional in other contexts trying to make it required here confuses TS.
  constructor(owner) {
    super(owner);
    (isDevelopingApp() && !(owner) && assert('BUG: Missing owner', owner));
    this._resetQueuedQueryParameterChanges();
    this.namespace = owner.lookup('application:main');
    let bucketCache = owner.lookup(privatize`-bucket-cache:main`);
    (isDevelopingApp() && !(bucketCache instanceof BucketCache) && assert('BUG: BucketCache should always be present', bucketCache instanceof BucketCache));
    this._bucketCache = bucketCache;
    let routerService = owner.lookup('service:router');
    (isDevelopingApp() && !(routerService !== undefined) && assert('BUG: RouterService should always be present', routerService !== undefined));
    this._routerService = routerService;
  }
  _initRouterJs() {
    let location = get(this, 'location');
    let router = this;
    const owner = getOwner$1(this);
    (isDevelopingApp() && !(owner) && assert('Router is unexpectedly missing an owner', owner));
    let seen = Object.create(null);
    class PrivateRouter extends Router {
      getRoute(name) {
        let routeName = name;
        let routeOwner = owner;
        let engineInfo = router._engineInfoByRoute[routeName];
        if (engineInfo) {
          let engineInstance = router._getEngineInstance(engineInfo);
          routeOwner = engineInstance;
          routeName = engineInfo.localFullName;
        }
        let fullRouteName = `route:${routeName}`;
        (isDevelopingApp() && !(routeOwner) && assert('Route is unexpectedly missing an owner', routeOwner));
        let route = routeOwner.lookup(fullRouteName);
        if (seen[name]) {
          (isDevelopingApp() && !(route) && assert('seen routes should exist', route));
          return route;
        }
        seen[name] = true;
        if (!route) {
          // SAFETY: this is configured in `commonSetupRegistry` in the
          // `@ember/application/lib` package.
          let DefaultRoute = routeOwner.factoryFor('route:basic').class;
          routeOwner.register(fullRouteName, DefaultRoute.extend());
          route = routeOwner.lookup(fullRouteName);
          if (isDevelopingApp()) {
            if (router.namespace.LOG_ACTIVE_GENERATION) {
              info(`generated -> ${fullRouteName}`, {
                fullName: fullRouteName
              });
            }
          }
        }
        route._setRouteName(routeName);
        if (engineInfo && !hasDefaultSerialize(route)) {
          throw new Error('Defining a custom serialize method on an Engine route is not supported.');
        }
        return route;
      }
      getSerializer(name) {
        let engineInfo = router._engineInfoByRoute[name];

        // If this is not an Engine route, we fall back to the handler for serialization
        if (!engineInfo) {
          return;
        }
        return engineInfo.serializeMethod || defaultSerialize;
      }
      updateURL(path) {
        once(() => {
          location.setURL(path);
          set(router, 'currentURL', path);
        });
      }

      // TODO: merge into routeDidChange
      didTransition(infos) {
        (isDevelopingApp() && !(router.didTransition === defaultDidTransition) && assert('You attempted to override the "didTransition" method which has been deprecated. Please inject the router service and listen to the "routeDidChange" event.', router.didTransition === defaultDidTransition));
        router.didTransition(infos);
      }

      // TODO: merge into routeWillChange
      willTransition(oldInfos, newInfos) {
        (isDevelopingApp() && !(router.willTransition === defaultWillTransition) && assert('You attempted to override the "willTransition" method which has been deprecated. Please inject the router service and listen to the "routeWillChange" event.', router.willTransition === defaultWillTransition));
        router.willTransition(oldInfos, newInfos);
      }
      triggerEvent(routeInfos, ignoreFailure, name, args) {
        return triggerEvent.bind(router)(routeInfos, ignoreFailure, name, args);
      }
      routeWillChange(transition) {
        router.trigger('routeWillChange', transition);
        if (isDevelopingApp()) {
          freezeRouteInfo(transition);
        }
        router._routerService.trigger('routeWillChange', transition);

        // in case of intermediate transition we update the current route
        // to make router.currentRoute.name consistent with router.currentRouteName
        // see https://github.com/emberjs/ember.js/issues/19449
        if (transition.isIntermediate) {
          router.set('currentRoute', transition.to);
        }
      }
      routeDidChange(transition) {
        router.set('currentRoute', transition.to);
        once(() => {
          router.trigger('routeDidChange', transition);
          if (isDevelopingApp()) {
            freezeRouteInfo(transition);
          }
          router._routerService.trigger('routeDidChange', transition);
        });
      }
      transitionDidError(error, transition) {
        if (error.wasAborted || transition.isAborted) {
          // If the error was a transition erorr or the transition aborted
          // log the abort.
          return logAbort(transition);
        } else {
          // Otherwise trigger the "error" event to attempt an intermediate
          // transition into an error substate
          transition.trigger(false, 'error', error.error, transition, error.route);
          if (router._isErrorHandled(error.error)) {
            // If we handled the error with a substate just roll the state back on
            // the transition and send the "routeDidChange" event for landing on
            // the error substate and return the error.
            transition.rollback();
            this.routeDidChange(transition);
            return error.error;
          } else {
            // If it was not handled, abort the transition completely and return
            // the error.
            transition.abort();
            return error.error;
          }
        }
      }
      replaceURL(url) {
        if (location.replaceURL) {
          let doReplaceURL = () => {
            location.replaceURL(url);
            set(router, 'currentURL', url);
          };
          once(doReplaceURL);
        } else {
          this.updateURL(url);
        }
      }
    }
    let routerMicrolib = this._routerMicrolib = new PrivateRouter();
    let dslCallbacks = this.constructor.dslCallbacks || [K];
    let dsl = this._buildDSL();
    dsl.route('application', {
      path: '/',
      resetNamespace: true,
      overrideNameAssertion: true
    }, function () {
      for (let i = 0; i < dslCallbacks.length; i++) {
        dslCallbacks[i].call(this);
      }
    });
    if (isDevelopingApp()) {
      if (this.namespace.LOG_TRANSITIONS_INTERNAL) {
        routerMicrolib.log = console.log.bind(console); // eslint-disable-line no-console
      }
    }
    routerMicrolib.map(dsl.generate());
  }
  _buildDSL() {
    let enableLoadingSubstates = this._hasModuleBasedResolver();
    let router = this;
    const owner = getOwner$1(this);
    (isDevelopingApp() && !(owner) && assert('Router is unexpectedly missing an owner', owner));
    let options = {
      enableLoadingSubstates,
      resolveRouteMap(name) {
        return owner.factoryFor(`route-map:${name}`);
      },
      addRouteForEngine(name, engineInfo) {
        if (!router._engineInfoByRoute[name]) {
          router._engineInfoByRoute[name] = engineInfo;
        }
      }
    };
    return new DSLImpl(null, options);
  }

  /*
    Resets all pending query parameter changes.
    Called after transitioning to a new route
    based on query parameter changes.
  */
  _resetQueuedQueryParameterChanges() {
    this._queuedQPChanges = {};
  }
  _hasModuleBasedResolver() {
    let owner = getOwner$1(this);
    (isDevelopingApp() && !(owner) && assert('Router is unexpectedly missing an owner', owner));
    let resolver = get(owner, 'application.__registry__.resolver.moduleBasedResolver');
    return Boolean(resolver);
  }

  /**
    Initializes the current router instance and sets up the change handling
    event listeners used by the instances `location` implementation.
     A property named `initialURL` will be used to determine the initial URL.
    If no value is found `/` will be used.
     @method startRouting
    @private
  */
  startRouting() {
    if (this.setupRouter()) {
      let initialURL = get(this, 'initialURL');
      if (initialURL === undefined) {
        initialURL = get(this, 'location').getURL();
      }
      let initialTransition = this.handleURL(initialURL);
      if (initialTransition && initialTransition.error) {
        throw initialTransition.error;
      }
    }
  }
  setupRouter() {
    if (this._didSetupRouter) {
      return false;
    }
    this._didSetupRouter = true;
    this._setupLocation();
    let location = get(this, 'location');

    // Allow the Location class to cancel the router setup while it refreshes
    // the page
    if (get(location, 'cancelRouterSetup')) {
      return false;
    }
    this._initRouterJs();
    location.onUpdateURL(url => {
      this.handleURL(url);
    });
    return true;
  }
  _setOutlets() {
    // This is triggered async during Route#willDestroy.
    // If the router is also being destroyed we do not want to
    // to create another this._toplevelView (and leak the renderer)
    if (this.isDestroying || this.isDestroyed) {
      return;
    }
    let routeInfos = this._routerMicrolib.currentRouteInfos;
    if (!routeInfos) {
      return;
    }
    let root = null;
    let parent = null;
    for (let routeInfo of routeInfos) {
      let route = routeInfo.route;
      let render = getRenderState(route);
      if (render) {
        let state = {
          render,
          outlets: {
            main: undefined
          }
        };
        if (parent) {
          parent.outlets.main = state;
        } else {
          root = state;
        }
        parent = state;
      } else {
        // It used to be that we would create a stub entry and keep traversing,
        // but I don't think that is necessary anymore – if a parent route did
        // not render, then the child routes have nowhere to render into these
        // days. That wasn't always the case since in the past any route can
        // render into any other route's outlets.
        break;
      }
    }

    // when a transitionTo happens after the validation phase
    // during the initial transition _setOutlets is called
    // when no routes are active. However, it will get called
    // again with the correct values during the next turn of
    // the runloop
    if (root === null) {
      return;
    }
    if (!this._toplevelView) {
      let owner = getOwner$1(this);
      (isDevelopingApp() && !(owner) && assert('Router is unexpectedly missing an owner', owner)); // SAFETY: we don't presently have any type registries internally to make
      // this safe, so in each of these cases we assume that nothing *else* is
      // registered at this `FullName`, and simply check to make sure that
      // *something* is.
      let OutletView = owner.factoryFor('view:-outlet');
      (isDevelopingApp() && !(OutletView !== undefined) && assert('[BUG] unexpectedly missing `view:-outlet`', OutletView !== undefined));
      let application = owner.lookup('application:main');
      (isDevelopingApp() && !(application !== undefined) && assert('[BUG] unexpectedly missing `application:-main`', application !== undefined));
      let environment = owner.lookup('-environment:main');
      (isDevelopingApp() && !(environment !== undefined) && assert('[BUG] unexpectedly missing `-environment:main`', environment !== undefined));
      let template = owner.lookup('template:-outlet');
      (isDevelopingApp() && !(template !== undefined) && assert('[BUG] unexpectedly missing `template:-outlet`', template !== undefined));
      this._toplevelView = OutletView.create({
        environment,
        template,
        application
      });
      this._toplevelView.setOutletState(root);

      // TODO(SAFETY): At least one test runs without this set correctly. At a
      // later time, update the test to configure this correctly. The test ID:
      // `Router Service - non application test:  RouterService#transitionTo with basic route`
      let instance = owner.lookup('-application-instance:main');
      // let instance = owner.lookup('-application-instance:main') as ApplicationInstance | undefined;
      // assert('[BUG] unexpectedly missing `-application-instance:main`', instance !== undefined);

      if (instance) {
        // SAFETY: LOL. This is calling a deprecated API with a type that we
        // cannot actually confirm at a type level *is* a `ViewMixin`. Seems:
        // not great on multiple fronts!
        instance.didCreateRootView(this._toplevelView);
      }
    } else {
      this._toplevelView.setOutletState(root);
    }
  }
  handleURL(url) {
    // Until we have an ember-idiomatic way of accessing #hashes, we need to
    // remove it because router.js doesn't know how to handle it.
    let _url = url.split(/#(.+)?/)[0];
    return this._doURLTransition('handleURL', _url);
  }
  _doURLTransition(routerJsMethod, url) {
    this._initialTransitionStarted = true;
    let transition = this._routerMicrolib[routerJsMethod](url || '/');
    didBeginTransition(transition, this);
    return transition;
  }

  /**
    Transition the application into another route. The route may
    be either a single route or route path:
     @method transitionTo
    @param {String} [name] the name of the route or a URL
    @param {...Object} models the model(s) or identifier(s) to be used while
      transitioning to the route.
    @param {Object} [options] optional hash with a queryParams property
      containing a mapping of query parameters
    @return {Transition} the transition object associated with this
      attempted transition
    @public
  */
  transitionTo(...args) {
    if (resemblesURL(args[0])) {
      (isDevelopingApp() && !(!this.isDestroying && !this.isDestroyed) && assert(`A transition was attempted from '${this.currentRouteName}' to '${args[0]}' but the application instance has already been destroyed.`, !this.isDestroying && !this.isDestroyed));
      return this._doURLTransition('transitionTo', args[0]);
    }
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    (isDevelopingApp() && !(!this.isDestroying && !this.isDestroyed) && assert(`A transition was attempted from '${this.currentRouteName}' to '${routeName}' but the application instance has already been destroyed.`, !this.isDestroying && !this.isDestroyed));
    return this._doTransition(routeName, models, queryParams);
  }
  intermediateTransitionTo(name, ...args) {
    this._routerMicrolib.intermediateTransitionTo(name, ...args);
    updatePaths(this);
    if (isDevelopingApp()) {
      let infos = this._routerMicrolib.currentRouteInfos;
      if (this.namespace.LOG_TRANSITIONS) {
        (isDevelopingApp() && !(infos) && assert('expected infos to be set', infos)); // eslint-disable-next-line no-console
        console.log(`Intermediate-transitioned into '${EmberRouter._routePath(infos)}'`);
      }
    }
  }

  /**
    Similar to `transitionTo`, but instead of adding the destination to the browser's URL history,
    it replaces the entry for the current route.
    When the user clicks the "back" button in the browser, there will be fewer steps.
    This is most commonly used to manage redirects in a way that does not cause confusing additions
    to the user's browsing history.
     @method replaceWith
    @param {String} [name] the name of the route or a URL
    @param {...Object} models the model(s) or identifier(s) to be used while
      transitioning to the route.
    @param {Object} [options] optional hash with a queryParams property
      containing a mapping of query parameters
    @return {Transition} the transition object associated with this
      attempted transition
    @public
  */
  replaceWith(...args) {
    return this.transitionTo(...args).method('replace');
  }
  generate(name, ...args) {
    let url = this._routerMicrolib.generate(name, ...args);
    (isDevelopingApp() && !(typeof this.location !== 'string') && assert('expected non-string location', typeof this.location !== 'string'));
    return this.location.formatURL(url);
  }

  /**
    Determines if the supplied route is currently active.
     @method isActive
    @param routeName
    @return {Boolean}
    @private
  */
  isActive(routeName) {
    return this._routerMicrolib.isActive(routeName);
  }

  /**
    An alternative form of `isActive` that doesn't require
    manual concatenation of the arguments into a single
    array.
     @method isActiveIntent
    @param routeName
    @param models
    @param queryParams
    @return {Boolean}
    @private
    @since 1.7.0
  */
  isActiveIntent(routeName, models, queryParams) {
    return this.currentState.isActiveIntent(routeName, models, queryParams);
  }
  send(name, ...args) {
    /*name, context*/
    this._routerMicrolib.trigger(name, ...args);
  }

  /**
    Does this router instance have the given route.
     @method hasRoute
    @return {Boolean}
    @private
  */
  hasRoute(route) {
    return this._routerMicrolib.hasRoute(route);
  }

  /**
    Resets the state of the router by clearing the current route
    handlers and deactivating them.
     @private
    @method reset
   */
  reset() {
    this._didSetupRouter = false;
    this._initialTransitionStarted = false;
    if (this._routerMicrolib) {
      this._routerMicrolib.reset();
    }
  }
  willDestroy() {
    if (this._toplevelView) {
      this._toplevelView.destroy();
      this._toplevelView = null;
    }
    super.willDestroy();
    this.reset();
    let instances = this._engineInstances;
    for (let name in instances) {
      let instanceMap = instances[name];
      (isDevelopingApp() && !(instanceMap) && assert('has instanceMap', instanceMap));
      for (let id in instanceMap) {
        let instance = instanceMap[id];
        (isDevelopingApp() && !(instance) && assert('has instance', instance));
        run(instance, 'destroy');
      }
    }
  }

  /*
    Called when an active route's query parameter has changed.
    These changes are batched into a runloop run and trigger
    a single transition.
  */
  _activeQPChanged(queryParameterName, newValue) {
    this._queuedQPChanges[queryParameterName] = newValue;
    once(this, this._fireQueryParamTransition);
  }

  // The queryParameterName is QueryParam['urlKey']
  _updatingQPChanged(queryParameterName) {
    this._qpUpdates.add(queryParameterName);
  }

  /*
    Triggers a transition to a route based on query parameter changes.
    This is called once per runloop, to batch changes.
     e.g.
     if these methods are called in succession:
    this._activeQPChanged('foo', '10');
      // results in _queuedQPChanges = { foo: '10' }
    this._activeQPChanged('bar', false);
      // results in _queuedQPChanges = { foo: '10', bar: false }
     _queuedQPChanges will represent both of these changes
    and the transition using `transitionTo` will be triggered
    once.
  */
  _fireQueryParamTransition() {
    this.transitionTo({
      queryParams: this._queuedQPChanges
    });
    this._resetQueuedQueryParameterChanges();
  }
  _setupLocation() {
    let location = this.location;
    let rootURL = this.rootURL;
    let owner = getOwner$1(this);
    (isDevelopingApp() && !(owner) && assert('Router is unexpectedly missing an owner', owner));
    if ('string' === typeof location) {
      let resolvedLocation = owner.lookup(`location:${location}`);
      (isDevelopingApp() && !(resolvedLocation) && assert(`Could not resolve a location class at 'location:${location}'`, resolvedLocation));
      location = set(this, 'location', resolvedLocation);
    }
    if (location !== null && typeof location === 'object') {
      if (rootURL) {
        set(location, 'rootURL', rootURL);
      }

      // ensure that initState is called AFTER the rootURL is set on
      // the location instance
      if (typeof location.initState === 'function') {
        location.initState();
      }
    }
  }

  /**
    Serializes the given query params according to their QP meta information.
     @private
    @method _serializeQueryParams
    @param {Arrray<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _serializeQueryParams(routeInfos, queryParams) {
    forEachQueryParam(this, routeInfos, queryParams, (key, value, qp) => {
      if (qp) {
        delete queryParams[key];
        queryParams[qp.urlKey] = qp.route.serializeQueryParam(value, qp.urlKey, qp.type);
      } else if (value === undefined) {
        return; // We don't serialize undefined values
      } else {
        queryParams[key] = this._serializeQueryParam(value, typeOf(value));
      }
    });
  }

  /**
    Serializes the value of a query parameter based on a type
     @private
    @method _serializeQueryParam
    @param {Object} value
    @param {String} type
  */
  _serializeQueryParam(value, type) {
    if (value === null || value === undefined) {
      return value;
    } else if (type === 'array') {
      return JSON.stringify(value);
    }
    return `${value}`;
  }

  /**
    Deserializes the given query params according to their QP meta information.
     @private
    @method _deserializeQueryParams
    @param {Array<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _deserializeQueryParams(routeInfos, queryParams) {
    forEachQueryParam(this, routeInfos, queryParams, (key, value, qp) => {
      // If we don't have QP meta info for a given key, then we do nothing
      // because all values will be treated as strings
      if (qp) {
        delete queryParams[key];
        queryParams[qp.prop] = qp.route.deserializeQueryParam(value, qp.urlKey, qp.type);
      }
    });
  }

  /**
    Deserializes the value of a query parameter based on a default type
     @private
    @method _deserializeQueryParam
    @param {Object} value
    @param {String} defaultType
  */
  _deserializeQueryParam(value, defaultType) {
    if (value === null || value === undefined) {
      return value;
    } else if (defaultType === 'boolean') {
      return value === 'true';
    } else if (defaultType === 'number') {
      return Number(value).valueOf();
    } else if (defaultType === 'array') {
      return A(JSON.parse(value));
    }
    return value;
  }

  /**
    Removes (prunes) any query params with default values from the given QP
    object. Default values are determined from the QP meta information per key.
     @private
    @method _pruneDefaultQueryParamValues
    @param {Array<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _pruneDefaultQueryParamValues(routeInfos, queryParams) {
    let qps = this._queryParamsFor(routeInfos);
    for (let key in queryParams) {
      let qp = qps.map[key];
      if (qp && qp.serializedDefaultValue === queryParams[key]) {
        delete queryParams[key];
      }
    }
  }
  _doTransition(_targetRouteName, models, _queryParams, _fromRouterService) {
    let targetRouteName = _targetRouteName || getActiveTargetName(this._routerMicrolib);
    (isDevelopingApp() && !(Boolean(targetRouteName) && this._routerMicrolib.hasRoute(targetRouteName)) && assert(`The route ${targetRouteName} was not found`, Boolean(targetRouteName) && this._routerMicrolib.hasRoute(targetRouteName)));
    this._initialTransitionStarted = true;
    let queryParams = {};
    this._processActiveTransitionQueryParams(targetRouteName, models, queryParams, _queryParams);
    Object.assign(queryParams, _queryParams);
    this._prepareQueryParams(targetRouteName, models, queryParams, Boolean(_fromRouterService));
    let transition = this._routerMicrolib.transitionTo(targetRouteName, ...models, {
      queryParams
    });
    didBeginTransition(transition, this);
    return transition;
  }
  _processActiveTransitionQueryParams(targetRouteName, models, queryParams, _queryParams) {
    // merge in any queryParams from the active transition which could include
    // queryParams from the url on initial load.
    if (!this._routerMicrolib.activeTransition) {
      return;
    }
    let unchangedQPs = {};
    let qpUpdates = this._qpUpdates;
    let params = getFullQueryParams(this, this._routerMicrolib.activeTransition[STATE_SYMBOL]);
    for (let key in params) {
      if (!qpUpdates.has(key)) {
        unchangedQPs[key] = params[key];
      }
    }

    // We need to fully scope queryParams so that we can create one object
    // that represents both passed-in queryParams and ones that aren't changed
    // from the active transition.
    this._fullyScopeQueryParams(targetRouteName, models, _queryParams);
    this._fullyScopeQueryParams(targetRouteName, models, unchangedQPs);
    Object.assign(queryParams, unchangedQPs);
  }

  /**
    Prepares the query params for a URL or Transition. Restores any undefined QP
    keys/values, serializes all values, and then prunes any default values.
     @private
    @method _prepareQueryParams
    @param {String} targetRouteName
    @param {Array<Object>} models
    @param {Object} queryParams
    @param {boolean} keepDefaultQueryParamValues
    @return {Void}
  */
  _prepareQueryParams(targetRouteName, models, queryParams, _fromRouterService) {
    let state = calculatePostTransitionState(this, targetRouteName, models);
    this._hydrateUnsuppliedQueryParams(state, queryParams, Boolean(_fromRouterService));
    this._serializeQueryParams(state.routeInfos, queryParams);
    if (!_fromRouterService) {
      this._pruneDefaultQueryParamValues(state.routeInfos, queryParams);
    }
  }

  /**
    Returns the meta information for the query params of a given route. This
    will be overridden to allow support for lazy routes.
     @private
    @method _getQPMeta
    @param {RouteInfo} routeInfo
    @return {Object}
  */
  _getQPMeta(routeInfo) {
    let route = routeInfo.route;
    return route && get(route, '_qp');
  }

  /**
    Returns a merged query params meta object for a given set of routeInfos.
    Useful for knowing what query params are available for a given route hierarchy.
     @private
    @method _queryParamsFor
    @param {Array<RouteInfo>} routeInfos
    @return {Object}
   */
  _queryParamsFor(routeInfos) {
    let routeInfoLength = routeInfos.length;
    let leafRouteName = routeInfos[routeInfoLength - 1].name;
    let cached = this._qpCache[leafRouteName];
    if (cached !== undefined) {
      return cached;
    }
    let shouldCache = true;
    let map = {};
    let qps = [];
    let qpsByUrlKey = isDevelopingApp() ? {} : null;
    let qpMeta;
    let urlKey;
    let qpOther;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        shouldCache = false;
        continue;
      }

      // Loop over each QP to make sure we don't have any collisions by urlKey
      for (let qp of qpMeta.qps) {
        if (isDevelopingApp()) {
          urlKey = qp.urlKey;
          qpOther = qpsByUrlKey[urlKey];
          if (qpOther && qpOther.controllerName !== qp.controllerName) {
            (isDevelopingApp() && !(false) && assert(`You're not allowed to have more than one controller property map to the same query param key, but both \`${qpOther.scopedPropertyName}\` and \`${qp.scopedPropertyName}\` map to \`${urlKey}\`. You can fix this by mapping one of the controller properties to a different query param key via the \`as\` config option, e.g. \`${qpOther.prop}: { as: 'other-${qpOther.prop}' }\``, false));
          }
          qpsByUrlKey[urlKey] = qp;
        }
        qps.push(qp);
      }
      Object.assign(map, qpMeta.map);
    }
    let finalQPMeta = {
      qps,
      map
    };
    if (shouldCache) {
      this._qpCache[leafRouteName] = finalQPMeta;
    }
    return finalQPMeta;
  }

  /**
    Maps all query param keys to their fully scoped property name of the form
    `controllerName:propName`.
     @private
    @method _fullyScopeQueryParams
    @param {String} leafRouteName
    @param {Array<Object>} contexts
    @param {Object} queryParams
    @return {Void}
  */
  _fullyScopeQueryParams(leafRouteName, contexts, queryParams) {
    let state = calculatePostTransitionState(this, leafRouteName, contexts);
    let routeInfos = state.routeInfos;
    let qpMeta;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        continue;
      }
      for (let qp of qpMeta.qps) {
        let presentProp = qp.prop in queryParams && qp.prop || qp.scopedPropertyName in queryParams && qp.scopedPropertyName || qp.urlKey in queryParams && qp.urlKey;
        if (presentProp) {
          if (presentProp !== qp.scopedPropertyName) {
            queryParams[qp.scopedPropertyName] = queryParams[presentProp];
            delete queryParams[presentProp];
          }
        }
      }
    }
  }

  /**
    Hydrates (adds/restores) any query params that have pre-existing values into
    the given queryParams hash. This is what allows query params to be "sticky"
    and restore their last known values for their scope.
     @private
    @method _hydrateUnsuppliedQueryParams
    @param {TransitionState} state
    @param {Object} queryParams
    @return {Void}
  */
  _hydrateUnsuppliedQueryParams(state, queryParams, _fromRouterService) {
    let routeInfos = state.routeInfos;
    let appCache = this._bucketCache;
    let qpMeta;
    let qp;
    let presentProp;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        continue;
      }

      // Needs to stay for index loop to avoid throwIfClosureRequired
      for (let j = 0, qpLen = qpMeta.qps.length; j < qpLen; ++j) {
        qp = qpMeta.qps[j];
        (isDevelopingApp() && !(qp) && assert('expected qp', qp));
        presentProp = qp.prop in queryParams && qp.prop || qp.scopedPropertyName in queryParams && qp.scopedPropertyName || qp.urlKey in queryParams && qp.urlKey;
        (isDevelopingApp() && !(function () {
          if (qp.urlKey === presentProp || qp.scopedPropertyName === presentProp) {
            return true;
          }
          if (_fromRouterService && presentProp !== false && qp.urlKey !== qp.prop) {
            // assumptions (mainly from current transitionTo_test):
            // - this is only supposed to be run when there is an alias to a query param and the alias is used to set the param
            // - when there is no alias: qp.urlKey == qp.prop
            return false;
          }
          return true;
        }()) && assert(`You passed the \`${presentProp}\` query parameter during a transition into ${qp.route.routeName}, please update to ${qp.urlKey}`, function () {
          if (qp.urlKey === presentProp || qp.scopedPropertyName === presentProp) {
            return true;
          }
          if (_fromRouterService && presentProp !== false && qp.urlKey !== qp.prop) {
            return false;
          }
          return true;
        }()));
        if (presentProp) {
          if (presentProp !== qp.scopedPropertyName) {
            queryParams[qp.scopedPropertyName] = queryParams[presentProp];
            delete queryParams[presentProp];
          }
        } else {
          let cacheKey = calculateCacheKey(qp.route.fullRouteName, qp.parts, state.params);
          (isDevelopingApp() && !(appCache) && assert('ROUTER BUG: expected appCache to be defined. This is an internal bug, please open an issue on Github if you see this message!', appCache));
          queryParams[qp.scopedPropertyName] = appCache.lookup(cacheKey, qp.prop, qp.defaultValue);
        }
      }
    }
  }
  _scheduleLoadingEvent(transition, originRoute) {
    this._cancelSlowTransitionTimer();
    this._slowTransitionTimer = scheduleOnce('routerTransitions', this, this._handleSlowTransition, transition, originRoute);
  }
  currentState = null;
  targetState = null;
  _handleSlowTransition(transition, originRoute) {
    if (!this._routerMicrolib.activeTransition) {
      // Don't fire an event if we've since moved on from
      // the transition that put us in a loading state.
      return;
    }
    let targetState = new RouterState(this, this._routerMicrolib, this._routerMicrolib.activeTransition[STATE_SYMBOL]);
    this.set('targetState', targetState);
    transition.trigger(true, 'loading', transition, originRoute);
  }
  _cancelSlowTransitionTimer() {
    if (this._slowTransitionTimer) {
      cancel(this._slowTransitionTimer);
    }
    this._slowTransitionTimer = null;
  }

  // These three helper functions are used to ensure errors aren't
  // re-raised if they're handled in a route's error action.
  _markErrorAsHandled(error) {
    this._handledErrors.add(error);
  }
  _isErrorHandled(error) {
    return this._handledErrors.has(error);
  }
  _clearHandledError(error) {
    this._handledErrors.delete(error);
  }
  _getEngineInstance({
    name,
    instanceId,
    mountPoint
  }) {
    let engineInstances = this._engineInstances;
    let namedInstances = engineInstances[name];
    if (!namedInstances) {
      namedInstances = Object.create(null);
      engineInstances[name] = namedInstances;
    }

    // We just set these!
    (isDevelopingApp() && !(namedInstances) && assert('has namedInstances', namedInstances));
    let engineInstance = namedInstances[instanceId];
    if (!engineInstance) {
      let owner = getOwner$1(this);
      (isDevelopingApp() && !(owner instanceof EmberEngineInstance) && assert('Expected router to have EngineInstance as owner', owner instanceof EmberEngineInstance));
      (isDevelopingApp() && !(owner.hasRegistration(`engine:${name}`)) && assert(`You attempted to mount the engine '${name}' in your router map, but the engine can not be found.`, owner.hasRegistration(`engine:${name}`)));
      engineInstance = owner.buildChildEngineInstance(name, {
        routable: true,
        mountPoint
      });
      engineInstance.boot();
      namedInstances[instanceId] = engineInstance;
    }
    return engineInstance;
  }

  /**
    Handles updating the paths and notifying any listeners of the URL
    change.
     Triggers the router level `didTransition` hook.
     For example, to notify google analytics when the route changes,
    you could use this hook.  (Note: requires also including GA scripts, etc.)
     ```javascript
    import config from './config/environment';
    import EmberRouter from '@ember/routing/router';
    import { service } from '@ember/service';
     let Router = EmberRouter.extend({
      location: config.locationType,
       router: service(),
       didTransition: function() {
        this._super(...arguments);
         ga('send', 'pageview', {
          page: this.router.currentURL,
          title: this.router.currentRouteName,
        });
      }
    });
    ```
     @method didTransition
    @private
    @since 1.2.0
  */
  // Set with reopen to allow overriding via extend

  /**
    Handles notifying any listeners of an impending URL
    change.
     Triggers the router level `willTransition` hook.
     @method willTransition
    @private
    @since 1.11.0
  */
  // Set with reopen to allow overriding via extend

  /**
   Represents the current URL.
     @property url
    @type {String}
    @private
  */
  // Set with reopen to allow overriding via extend
}

/*
  Helper function for iterating over routes in a set of routeInfos that are
  at or above the given origin route. Example: if `originRoute` === 'foo.bar'
  and the routeInfos given were for 'foo.bar.baz', then the given callback
  will be invoked with the routes for 'foo.bar', 'foo', and 'application'
  individually.

  If the callback returns anything other than `true`, then iteration will stop.

  @private
  @param {Route} originRoute
  @param {Array<RouteInfo>} routeInfos
  @param {Function} callback
  @return {Void}
 */
function forEachRouteAbove(routeInfos, callback) {
  for (let i = routeInfos.length - 1; i >= 0; --i) {
    let routeInfo = routeInfos[i];
    (isDevelopingApp() && !(routeInfo) && assert('has routeInfo', routeInfo));
    let route = routeInfo.route;

    // routeInfo.handler being `undefined` generally means either:
    //
    // 1. an error occurred during creation of the route in question
    // 2. the route is across an async boundary (e.g. within an engine)
    //
    // In both of these cases, we cannot invoke the callback on that specific
    // route, because it just doesn't exist...
    if (route === undefined) {
      continue;
    }
    if (callback(route, routeInfo) !== true) {
      return;
    }
  }
}

// These get invoked when an action bubbles above ApplicationRoute
// and are not meant to be overridable.
let defaultActionHandlers = {
  willResolveModel(_routeInfos, transition, originRoute) {
    this._scheduleLoadingEvent(transition, originRoute);
  },
  // Attempt to find an appropriate error route or substate to enter.
  error(routeInfos, error, transition) {
    let router = this;
    let routeInfoWithError = routeInfos[routeInfos.length - 1];
    forEachRouteAbove(routeInfos, (route, routeInfo) => {
      // We don't check the leaf most routeInfo since that would
      // technically be below where we're at in the route hierarchy.
      if (routeInfo !== routeInfoWithError) {
        // Check for the existence of an 'error' route.
        let errorRouteName = findRouteStateName(route, 'error');
        if (errorRouteName) {
          router._markErrorAsHandled(error);
          router.intermediateTransitionTo(errorRouteName, error);
          return false;
        }
      }

      // Check for an 'error' substate route
      let errorSubstateName = findRouteSubstateName(route, 'error');
      if (errorSubstateName) {
        router._markErrorAsHandled(error);
        router.intermediateTransitionTo(errorSubstateName, error);
        return false;
      }
      return true;
    });
    logError(error, `Error while processing route: ${transition.targetName}`);
  },
  // Attempt to find an appropriate loading route or substate to enter.
  loading(routeInfos, transition) {
    let router = this;
    let routeInfoWithSlowLoading = routeInfos[routeInfos.length - 1];
    forEachRouteAbove(routeInfos, (route, routeInfo) => {
      // We don't check the leaf most routeInfos since that would
      // technically be below where we're at in the route hierarchy.
      if (routeInfo !== routeInfoWithSlowLoading) {
        // Check for the existence of a 'loading' route.
        let loadingRouteName = findRouteStateName(route, 'loading');
        if (loadingRouteName) {
          router.intermediateTransitionTo(loadingRouteName);
          return false;
        }
      }

      // Check for loading substate
      let loadingSubstateName = findRouteSubstateName(route, 'loading');
      if (loadingSubstateName) {
        router.intermediateTransitionTo(loadingSubstateName);
        return false;
      }

      // Don't bubble above pivot route.
      return transition.pivotHandler !== route;
    });
  }
};
function logError(_error, initialMessage) {
  let errorArgs = [];
  let error;
  if (_error && typeof _error === 'object' && typeof _error.errorThrown === 'object') {
    error = _error.errorThrown;
  } else {
    error = _error;
  }
  if (initialMessage) {
    errorArgs.push(initialMessage);
  }
  if (error) {
    if (error.message) {
      errorArgs.push(error.message);
    }
    if (error.stack) {
      errorArgs.push(error.stack);
    }
    if (typeof error === 'string') {
      errorArgs.push(error);
    }
  }
  console.error(...errorArgs); //eslint-disable-line no-console
}

/**
  Finds the name of the substate route if it exists for the given route. A
  substate route is of the form `route_state`, such as `foo_loading`.

  @private
  @param {Route} route
  @param {String} state
  @return {String}
*/
function findRouteSubstateName(route, state) {
  let owner = getOwner$1(route);
  (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
  let {
    routeName,
    fullRouteName,
    _router: router
  } = route;
  let substateName = `${routeName}_${state}`;
  let substateNameFull = `${fullRouteName}_${state}`;
  return routeHasBeenDefined(owner, router, substateName, substateNameFull) ? substateNameFull : '';
}

/**
  Finds the name of the state route if it exists for the given route. A state
  route is of the form `route.state`, such as `foo.loading`. Properly Handles
  `application` named routes.

  @private
  @param {Route} route
  @param {String} state
  @return {String}
*/
function findRouteStateName(route, state) {
  let owner = getOwner$1(route);
  (isDevelopingApp() && !(owner) && assert('Route is unexpectedly missing an owner', owner));
  let {
    routeName,
    fullRouteName,
    _router: router
  } = route;
  let stateName = routeName === 'application' ? state : `${routeName}.${state}`;
  let stateNameFull = fullRouteName === 'application' ? state : `${fullRouteName}.${state}`;
  return routeHasBeenDefined(owner, router, stateName, stateNameFull) ? stateNameFull : '';
}

/**
  Determines whether or not a route has been defined by checking that the route
  is in the Router's map and the owner has a registration for that route.

  @private
  @param {Owner} owner
  @param {Router} router
  @param {String} localName
  @param {String} fullName
  @return {Boolean}
*/
function routeHasBeenDefined(owner, router, localName, fullName) {
  let routerHasRoute = router.hasRoute(fullName);
  let ownerHasRoute = owner.factoryFor(`template:${localName}`) || owner.factoryFor(`route:${localName}`);
  return routerHasRoute && ownerHasRoute;
}
function triggerEvent(routeInfos, ignoreFailure, name, args) {
  if (!routeInfos) {
    if (ignoreFailure) {
      return;
    }
    // TODO: update?
    throw new Error(`Can't trigger action '${name}' because your app hasn't finished transitioning into its first route. To trigger an action on destination routes during a transition, you can call \`.send()\` on the \`Transition\` object passed to the \`model/beforeModel/afterModel\` hooks.`);
  }
  let eventWasHandled = false;
  let routeInfo, handler, actionHandler;
  for (let i = routeInfos.length - 1; i >= 0; i--) {
    routeInfo = routeInfos[i];
    (isDevelopingApp() && !(routeInfo) && assert('[BUG] Missing routeInfo', routeInfo));
    handler = routeInfo.route;
    actionHandler = handler && handler.actions && handler.actions[name];
    if (actionHandler) {
      if (actionHandler.apply(handler, args) === true) {
        eventWasHandled = true;
      } else {
        // Should only hit here if a non-bubbling error action is triggered on a route.
        if (name === 'error') {
          (isDevelopingApp() && !(handler) && assert('[BUG] Missing handler', handler));
          handler._router._markErrorAsHandled(args[0]);
        }
        return;
      }
    }
  }
  let defaultHandler = defaultActionHandlers[name];
  if (defaultHandler) {
    defaultHandler.call(this, routeInfos, ...args);
    return;
  }
  if (!eventWasHandled && !ignoreFailure) {
    throw new Error(`Nothing handled the action '${name}'. If you did handle the action, this error can be caused by returning true from an action handler in a controller, causing the action to bubble.`);
  }
}
function calculatePostTransitionState(emberRouter, leafRouteName, contexts) {
  let state = emberRouter._routerMicrolib.applyIntent(leafRouteName, contexts);
  let {
    routeInfos,
    params
  } = state;
  for (let routeInfo of routeInfos) {
    // If the routeInfo is not resolved, we serialize the context into params
    if (!routeInfo.isResolved) {
      params[routeInfo.name] = routeInfo.serialize(routeInfo.context);
    } else {
      params[routeInfo.name] = routeInfo.params;
    }
  }
  return state;
}
function updatePaths(router) {
  let infos = router._routerMicrolib.currentRouteInfos;
  if (infos.length === 0) {
    return;
  }
  let path = EmberRouter._routePath(infos);
  let info = infos[infos.length - 1];
  (isDevelopingApp() && !(info) && assert('expected info', info));
  let currentRouteName = info.name;
  let location = router.location;
  (isDevelopingApp() && !(typeof location !== 'string') && assert('expected location to not be a string', typeof location !== 'string'));
  let currentURL = location.getURL();
  set(router, 'currentPath', path);
  set(router, 'currentRouteName', currentRouteName);
  set(router, 'currentURL', currentURL);
}
function didBeginTransition(transition, router) {
  let routerState = new RouterState(router, router._routerMicrolib, transition[STATE_SYMBOL]);
  if (!router.currentState) {
    router.set('currentState', routerState);
  }
  router.set('targetState', routerState);
  transition.promise = transition.catch(error => {
    if (router._isErrorHandled(error)) {
      router._clearHandledError(error);
    } else {
      throw error;
    }
  }, 'Transition Error');
}
function forEachQueryParam(router, routeInfos, queryParams, callback) {
  let qpCache = router._queryParamsFor(routeInfos);
  for (let key in queryParams) {
    if (!Object.prototype.hasOwnProperty.call(queryParams, key)) {
      continue;
    }
    let value = queryParams[key];
    let qp = qpCache.map[key];
    callback(key, value, qp);
  }
}
EmberRouter.reopen({
  didTransition: defaultDidTransition,
  willTransition: defaultWillTransition,
  rootURL: '/',
  location: 'hash',
  // FIXME: Does this need to be overrideable via extend?
  url: computed(function () {
    let location = get(this, 'location');
    if (typeof location === 'string') {
      return undefined;
    }
    return location.getURL();
  })
});
const EmberRouter$1 = EmberRouter;

/**
 * @module @ember/routing/router-service
 */
const ROUTER = Symbol('ROUTER');
function cleanURL(url, rootURL) {
  if (rootURL === '/') {
    return url;
  }
  return url.substring(rootURL.length);
}

/**
   The Router service is the public API that provides access to the router.

   The immediate benefit of the Router service is that you can inject it into components,
   giving them a friendly way to initiate transitions and ask questions about the current
   global router state.

   In this example, the Router service is injected into a component to initiate a transition
   to a dedicated route:

   ```app/components/example.js
   import Component from '@glimmer/component';
   import { action } from '@ember/object';
   import { service } from '@ember/service';

   export default class ExampleComponent extends Component {
     @service router;

     @action
     next() {
       this.router.transitionTo('other.route');
     }
   }
   ```

   Like any service, it can also be injected into helpers, routes, etc.

   @public
   @extends Service
   @class RouterService
 */

class RouterService extends Service.extend(Evented) {
  [ROUTER];
  get _router() {
    let router = this[ROUTER];
    if (router !== undefined) {
      return router;
    }
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('RouterService is unexpectedly missing an owner', owner));
    let _router = owner.lookup('router:main');
    (isDevelopingApp() && !(_router instanceof EmberRouter$1) && assert('ROUTER SERVICE BUG: Expected router to be an instance of EmberRouter', _router instanceof EmberRouter$1));
    return this[ROUTER] = _router;
  }
  willDestroy() {
    super.willDestroy();
    this[ROUTER] = undefined;
  }

  /**
     Transition the application into another route. The route may
     be either a single route or route path:
      Calling `transitionTo` from the Router service will cause default query parameter values to be included in the URL.
     This behavior is different from calling `transitionTo` on a route or `transitionToRoute` on a controller.
     See the [Router Service RFC](https://github.com/emberjs/rfcs/blob/master/text/0095-router-service.md#query-parameter-semantics) for more info.
      In the following example we use the Router service to navigate to a route with a
     specific model from a Component in the first action, and in the second we trigger
     a query-params only transition.
      ```app/components/example.js
     import Component from '@glimmer/component';
     import { action } from '@ember/object';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        @action
       goToComments(post) {
         this.router.transitionTo('comments', post);
       }
        @action
       fetchMoreComments(latestComment) {
         this.router.transitionTo({
           queryParams: { commentsAfter: latestComment }
         });
       }
     }
     ```
      @method transitionTo
     @param {String} [routeNameOrUrl] the name of the route or a URL
     @param {...Object} [models] the model(s) or identifier(s) to be used while
       transitioning to the route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters. May be supplied as the only
      parameter to trigger a query-parameter-only transition.
     @return {Transition} the transition object associated with this
       attempted transition
     @public
   */
  transitionTo(...args) {
    if (resemblesURL(args[0])) {
      // NOTE: this `args[0] as string` cast is safe and TS correctly infers it
      // in 3.6+, so it can be removed when TS is upgraded.
      return this._router._doURLTransition('transitionTo', args[0]);
    }
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    let transition = this._router._doTransition(routeName, models, queryParams, true);
    return transition;
  }

  /**
     Similar to `transitionTo`, but instead of adding the destination to the browser's URL history,
     it replaces the entry for the current route.
     When the user clicks the "back" button in the browser, there will be fewer steps.
     This is most commonly used to manage redirects in a way that does not cause confusing additions
     to the user's browsing history.
      Calling `replaceWith` from the Router service will cause default query parameter values to be included in the URL.
     This behavior is different from calling `replaceWith` on a route.
     See the [Router Service RFC](https://github.com/emberjs/rfcs/blob/master/text/0095-router-service.md#query-parameter-semantics) for more info.
      Usage example:
      ```app/routes/application.js
     import Route from '@ember/routing/route';
     import { service } from '@ember/service';
      export default class extends Route {
       @service router;
       beforeModel() {
         if (!authorized()){
           this.router.replaceWith('unauthorized');
         }
       }
     });
     ```
      @method replaceWith
     @param {String} routeNameOrUrl the name of the route or a URL of the desired destination
     @param {...Object} models the model(s) or identifier(s) to be used while
       transitioning to the route i.e. an object of params to pass to the destination route
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {Transition} the transition object associated with this
       attempted transition
     @public
   */
  replaceWith(...args) {
    return this.transitionTo(...args).method('replace');
  }

  /**
    Generate a URL based on the supplied route name and optionally a model. The
    URL is returned as a string that can be used for any purpose.
     In this example, the URL for the `author.books` route for a given author
    is copied to the clipboard.
     ```app/templates/application.hbs
    <CopyLink @author={{hash id="tomster" name="Tomster"}} />
    ```
     ```app/components/copy-link.js
    import Component from '@glimmer/component';
    import { service } from '@ember/service';
    import { action } from '@ember/object';
     export default class CopyLinkComponent extends Component {
      @service router;
      @service clipboard;
       @action
      copyBooksURL() {
        if (this.author) {
          const url = this.router.urlFor('author.books', this.args.author);
          this.clipboard.set(url);
          // Clipboard now has /author/tomster/books
        }
      }
    }
    ```
     Just like with `transitionTo` and `replaceWith`, `urlFor` can also handle
    query parameters.
     ```app/templates/application.hbs
    <CopyLink @author={{hash id="tomster" name="Tomster"}} />
    ```
     ```app/components/copy-link.js
    import Component from '@glimmer/component';
    import { service } from '@ember/service';
    import { action } from '@ember/object';
     export default class CopyLinkComponent extends Component {
      @service router;
      @service clipboard;
       @action
      copyOnlyEmberBooksURL() {
        if (this.author) {
          const url = this.router.urlFor('author.books', this.author, {
            queryParams: { filter: 'emberjs' }
          });
          this.clipboard.set(url);
          // Clipboard now has /author/tomster/books?filter=emberjs
        }
      }
    }
    ```
      @method urlFor
     @param {String} routeName the name of the route
     @param {...Object} models the model(s) for the route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {String} the string representing the generated URL
     @public
   */
  urlFor(routeName, ...args) {
    this._router.setupRouter();
    return this._router.generate(routeName, ...args);
  }

  /**
     Returns `true` if `routeName/models/queryParams` is the active route, where `models` and `queryParams` are optional.
     See [model](api/ember/release/classes/Route/methods/model?anchor=model) and
     [queryParams](/api/ember/3.7/classes/Route/properties/queryParams?anchor=queryParams) for more information about these arguments.
      In the following example, `isActive` will return `true` if the current route is `/posts`.
      ```app/components/posts.js
     import Component from '@glimmer/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        displayComments() {
         return this.router.isActive('posts');
       }
     });
     ```
      The next example includes a dynamic segment, and will return `true` if the current route is `/posts/1`,
     assuming the post has an id of 1:
      ```app/components/posts.js
     import Component from '@glimmer/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        displayComments(post) {
         return this.router.isActive('posts', post.id);
       }
     });
     ```
      Where `post.id` is the id of a specific post, which is represented in the route as /posts/[post.id].
     If `post.id` is equal to 1, then isActive will return true if the current route is /posts/1, and false if the route is anything else.
      @method isActive
     @param {String} routeName the name of the route
     @param {...Object} models the model(s) or identifier(s) to be used when determining the active route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {boolean} true if the provided routeName/models/queryParams are active
     @public
   */
  isActive(...args) {
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    let routerMicrolib = this._router._routerMicrolib;

    // When using isActive() in a getter, we want to entagle with the auto-tracking system
    // for example,
    // in
    // get isBarActive() {
    //   return isActive('foo.bar');
    // }
    //
    // you'd expect isBarActive to be dirtied when the route changes.
    //
    // https://github.com/emberjs/ember.js/issues/19004
    consumeTag(tagFor(this._router, 'currentURL'));

    // UNSAFE: casting `routeName as string` here encodes the existing
    // assumption but may be wrong: `extractRouteArgs` correctly returns it as
    // `string | undefined`. There may be bugs if `isActiveIntent` does
    // not correctly account for `undefined` values for `routeName`. Spoilers:
    // it *does not* account for this being `undefined`.
    if (!routerMicrolib.isActiveIntent(routeName, models)) {
      return false;
    }
    let hasQueryParams = Object.keys(queryParams).length > 0;
    if (hasQueryParams) {
      // UNSAFE: casting `routeName as string` here encodes the existing
      // assumption but may be wrong: `extractRouteArgs` correctly returns it
      // as `string | undefined`. There may be bugs if `_prepareQueryParams`
      // does not correctly account for `undefined` values for `routeName`.
      //  Spoilers: under the hood this currently uses router.js APIs which
      // *do not* account for this being `undefined`.
      let targetRouteName = routeName;
      queryParams = Object.assign({}, queryParams);
      this._router._prepareQueryParams(targetRouteName, models, queryParams, true /* fromRouterService */);
      let currentQueryParams = Object.assign({}, routerMicrolib.state.queryParams);
      this._router._prepareQueryParams(targetRouteName, models, currentQueryParams, true /* fromRouterService */);
      return shallowEqual(queryParams, currentQueryParams);
    }
    return true;
  }

  /**
     Takes a string URL and returns a `RouteInfo` for the leafmost route represented
     by the URL. Returns `null` if the URL is not recognized. This method expects to
     receive the actual URL as seen by the browser including the app's `rootURL`.
      See [RouteInfo](/ember/release/classes/RouteInfo) for more info.
      In the following example `recognize` is used to verify if a path belongs to our
     application before transitioning to it.
      ```
     import Component from '@ember/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
       path = '/';
        click() {
         if (this.router.recognize(this.path)) {
           this.router.transitionTo(this.path);
         }
       }
     }
     ```
       @method recognize
      @param {String} url
      @return {RouteInfo | null}
      @public
    */
  recognize(url) {
    (isDevelopingApp() && !(url.indexOf(this.rootURL) === 0) && assert(`You must pass a url that begins with the application's rootURL "${this.rootURL}"`, url.indexOf(this.rootURL) === 0));
    this._router.setupRouter();
    let internalURL = cleanURL(url, this.rootURL);
    return this._router._routerMicrolib.recognize(internalURL);
  }

  /**
    Takes a string URL and returns a promise that resolves to a
    `RouteInfoWithAttributes` for the leafmost route represented by the URL.
    The promise rejects if the URL is not recognized or an unhandled exception
    is encountered. This method expects to receive the actual URL as seen by
    the browser including the app's `rootURL`.
       @method recognizeAndLoad
      @param {String} url
      @return {RouteInfo}
      @public
   */
  recognizeAndLoad(url) {
    (isDevelopingApp() && !(url.indexOf(this.rootURL) === 0) && assert(`You must pass a url that begins with the application's rootURL "${this.rootURL}"`, url.indexOf(this.rootURL) === 0));
    this._router.setupRouter();
    let internalURL = cleanURL(url, this.rootURL);
    return this._router._routerMicrolib.recognizeAndLoad(internalURL);
  }

  /**
    You can register a listener for events emitted by this service with `.on()`:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeWillChange', (transition) => {
          if (!transition.to.find(route => route.name === this.routeName)) {
            alert("Please save or cancel your changes.");
            transition.abort();
          }
        })
      }
    }
    ```
     @method on
    @param {String} eventName
    @param {Function} callback
    @public
  */

  /**
    You can unregister a listener for events emitted by this service with `.off()`:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class ContactFormRoute extends Route {
      @service router;
       callback = (transition) => {
        if (!transition.to.find(route => route.name === this.routeName)) {
          alert('Please save or cancel your changes.');
          transition.abort();
        }
      };
       activate() {
        this.router.on('routeWillChange', this.callback);
      }
       deactivate() {
        this.router.off('routeWillChange', this.callback);
      }
    }
    ```
     @method off
    @param {String} eventName
    @param {Function} callback
    @public
  */

  /**
    The `routeWillChange` event is fired at the beginning of any
    attempted transition with a `Transition` object as the sole
    argument. This action can be used for aborting, redirecting,
    or decorating the transition from the currently active routes.
     A good example is preventing navigation when a form is
    half-filled out:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeWillChange', (transition) => {
          if (!transition.to.find(route => route.name === this.routeName)) {
            alert("Please save or cancel your changes.");
            transition.abort();
          }
        })
      }
    }
    ```
     The `routeWillChange` event fires whenever a new route is chosen as the desired target of a transition. This includes `transitionTo`, `replaceWith`, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, `routeDidChange` fires.
     @event routeWillChange
    @param {Transition} transition
    @public
  */

  /**
    The `routeDidChange` event only fires once a transition has settled.
    This includes aborts and error substates. Like the `routeWillChange` event
    it receives a Transition as the sole argument.
     A good example is sending some analytics when the route has transitioned:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeDidChange', (transition) => {
          ga.send('pageView', {
            current: transition.to.name,
            from: transition.from.name
          });
        })
      }
    }
    ```
     `routeDidChange` will be called after any `Route`'s
    [didTransition](/ember/release/classes/Route/events/didTransition?anchor=didTransition)
    action has been fired.
    The updates of properties
    [currentURL](/ember/release/classes/RouterService/properties/currentURL?anchor=currentURL),
    [currentRouteName](/ember/release/classes/RouterService/properties/currentURL?anchor=currentRouteName)
    and
    [currentRoute](/ember/release/classes/RouterService/properties/currentURL?anchor=currentRoute)
    are completed at the time `routeDidChange` is called.
     @event routeDidChange
    @param {Transition} transition
    @public
  */

  /**
   * Refreshes all currently active routes, doing a full transition.
   * If a route name is provided and refers to a currently active route,
   * it will refresh only that route and its descendents.
   * Returns a promise that will be resolved once the refresh is complete.
   * All resetController, beforeModel, model, afterModel, redirect, and setupController
   * hooks will be called again. You will get new data from the model hook.
   *
   * @method refresh
   * @param {String} [routeName] the route to refresh (along with all child routes)
   * @return Transition
   * @public
   */
  refresh(pivotRouteName) {
    if (!pivotRouteName) {
      return this._router._routerMicrolib.refresh();
    }
    (isDevelopingApp() && !(this._router.hasRoute(pivotRouteName)) && assert(`The route "${pivotRouteName}" was not found`, this._router.hasRoute(pivotRouteName)));
    (isDevelopingApp() && !(this.isActive(pivotRouteName)) && assert(`The route "${pivotRouteName}" is currently not active`, this.isActive(pivotRouteName)));
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('RouterService is unexpectedly missing an owner', owner));
    let pivotRoute = owner.lookup(`route:${pivotRouteName}`);
    return this._router._routerMicrolib.refresh(pivotRoute);
  }

  /**
   Name of the current route.
     This property represents the logical name of the route,
    which is dot separated.
    For the following router:
     ```app/router.js
    Router.map(function() {
      this.route('about');
      this.route('blog', function () {
        this.route('post', { path: ':post_id' });
      });
    });
    ```
     It will return:
     * `index` when you visit `/`
    * `about` when you visit `/about`
    * `blog.index` when you visit `/blog`
    * `blog.post` when you visit `/blog/some-post-id`
     @property currentRouteName
    @type {String | null}
    @public
  */
  static {
    decorateFieldV2(this.prototype, "currentRouteName", [readOnly('_router.currentRouteName')]);
  }
  #currentRouteName = (initializeDeferredDecorator(this, "currentRouteName"), void 0);
  static {
    decorateFieldV2(this.prototype, "currentURL", [readOnly('_router.currentURL')]);
  }
  #currentURL = (initializeDeferredDecorator(this, "currentURL"), void 0);
  /**
   Current URL for the application.
   This property represents the URL path for this route.
  For the following router:
     ```app/router.js
    Router.map(function() {
      this.route('about');
      this.route('blog', function () {
        this.route('post', { path: ':post_id' });
      });
    });
    ```
     It will return:
     * `/` when you visit `/`
    * `/about` when you visit `/about`
    * `/blog` when you visit `/blog`
    * `/blog/some-post-id` when you visit `/blog/some-post-id`
     @property currentURL
    @type String
    @public
  */
  static {
    decorateFieldV2(this.prototype, "location", [readOnly('_router.location')]);
  }
  #location = (initializeDeferredDecorator(this, "location"), void 0);
  /**
    The `location` property returns what implementation of the `location` API
    your application is using, which determines what type of URL is being used.
     See [Location](/ember/release/classes/Location) for more information.
     To force a particular `location` API implementation to be used in your
    application you can set a location type on your `config/environment`.
    For example, to set the `history` type:
     ```config/environment.js
    'use strict';
     module.exports = function(environment) {
      let ENV = {
        modulePrefix: 'router-service',
        environment,
        rootURL: '/',
        locationType: 'history',
        ...
      }
    }
    ```
     The following location types are available by default:
    `hash`, `history`, `none`.
     See [HashLocation](/ember/release/classes/HashLocation).
    See [HistoryLocation](/ember/release/classes/HistoryLocation).
    See [NoneLocation](/ember/release/classes/NoneLocation).
     @property location
    @default 'hash'
    @see {Location}
    @public
  */
  static {
    decorateFieldV2(this.prototype, "rootURL", [readOnly('_router.rootURL')]);
  }
  #rootURL = (initializeDeferredDecorator(this, "rootURL"), void 0);
  /**
    The `rootURL` property represents the URL of the root of
    the application, '/' by default.
    This prefix is assumed on all routes defined on this app.
     If you change the `rootURL` in your environment configuration
    like so:
     ```config/environment.js
    'use strict';
     module.exports = function(environment) {
      let ENV = {
        modulePrefix: 'router-service',
        environment,
        rootURL: '/my-root',
      …
      }
    ]
    ```
     This property will return `/my-root`.
     @property rootURL
    @default '/'
    @public
  */
  static {
    decorateFieldV2(this.prototype, "currentRoute", [readOnly('_router.currentRoute')]);
  }
  #currentRoute = (initializeDeferredDecorator(this, "currentRoute"), void 0);
  /**
    The `currentRoute` property contains metadata about the current leaf route.
    It returns a `RouteInfo` object that has information like the route name,
    params, query params and more.
     See [RouteInfo](/ember/release/classes/RouteInfo) for more info.
     This property is guaranteed to change whenever a route transition
    happens (even when that transition only changes parameters
    and doesn't change the active route).
     Usage example:
    ```app/components/header.js
      import Component from '@glimmer/component';
      import { service } from '@ember/service';
      import { notEmpty } from '@ember/object/computed';
       export default class extends Component {
        @service router;
         @notEmpty('router.currentRoute.child') isChildRoute;
      });
    ```
     @property currentRoute
    @type RouteInfo
    @public
  */
}

/**
@module ember
*/

class RoutingService extends Service {
  [ROUTER];
  get router() {
    let router = this[ROUTER];
    if (router !== undefined) {
      return router;
    }
    let owner = getOwner(this);
    (isDevelopingApp() && !(owner) && assert('RoutingService is unexpectedly missing an owner', owner));
    let _router = owner.lookup('router:main');
    (isDevelopingApp() && !(_router instanceof EmberRouter$1) && assert('ROUTING SERVICE BUG: Expected router to be an instance of EmberRouter', _router instanceof EmberRouter$1));
    _router.setupRouter();
    return this[ROUTER] = _router;
  }
  hasRoute(routeName) {
    return this.router.hasRoute(routeName);
  }
  transitionTo(routeName, models, queryParams, shouldReplace) {
    let transition = this.router._doTransition(routeName, models, queryParams);
    if (shouldReplace) {
      transition.method('replace');
    }
    return transition;
  }
  normalizeQueryParams(routeName, models, queryParams) {
    this.router._prepareQueryParams(routeName, models, queryParams);
  }
  _generateURL(routeName, models, queryParams) {
    let visibleQueryParams = {};
    if (queryParams) {
      Object.assign(visibleQueryParams, queryParams);
      this.normalizeQueryParams(routeName, models, visibleQueryParams);
    }
    return this.router.generate(routeName, ...models, {
      queryParams: visibleQueryParams
    });
  }
  generateURL(routeName, models, queryParams) {
    if (this.router._initialTransitionStarted) {
      return this._generateURL(routeName, models, queryParams);
    } else {
      // Swallow error when transition has not started.
      // When rendering in tests without visit(), we cannot infer the route context which <LinkTo/> needs be aware of
      try {
        return this._generateURL(routeName, models, queryParams);
      } catch (_e) {
        return;
      }
    }
  }
  isActiveForRoute(contexts, queryParams, routeName, routerState) {
    let handlers = this.router._routerMicrolib.recognizer.handlersFor(routeName);
    let leafName = handlers[handlers.length - 1].handler;
    let maximumContexts = numberOfContextsAcceptedByHandler(routeName, handlers);

    // NOTE: any ugliness in the calculation of activeness is largely
    // due to the fact that we support automatic normalizing of
    // `resource` -> `resource.index`, even though there might be
    // dynamic segments / query params defined on `resource.index`
    // which complicates (and makes somewhat ambiguous) the calculation
    // of activeness for links that link to `resource` instead of
    // directly to `resource.index`.

    // if we don't have enough contexts revert back to full route name
    // this is because the leaf route will use one of the contexts
    if (contexts.length > maximumContexts) {
      routeName = leafName;
    }
    return routerState.isActiveIntent(routeName, contexts, queryParams);
  }
}
RoutingService.reopen({
  targetState: readOnly('router.targetState'),
  currentState: readOnly('router.currentState'),
  currentRouteName: readOnly('router.currentRouteName'),
  currentPath: readOnly('router.currentPath')
});
function numberOfContextsAcceptedByHandler(handlerName, handlerInfos) {
  let req = 0;
  for (let i = 0; i < handlerInfos.length; i++) {
    req += handlerInfos[i].names.length;
    if (handlerInfos[i].handler === handlerName) {
      break;
    }
  }
  return req;
}

export { getRenderState as A, getFullQueryParams as B, Component as C, defaultSerialize as D, Engine as E, hasDefaultSerialize as F, triggerEvent as G, Helper as H, Input as I, ROUTER as J, LinkTo as L, OutletView as O, RouterState as R, SafeString as S, Textarea as T, _resetRenderers as _, RoutingService as a, RootTemplate as b, htmlSafe as c, Renderer as d, escapeExpression as e, setupApplicationRegistry as f, buildInitializerMethod as g, helper$1 as h, isHTMLSafe as i, EmberRouter$1 as j, Route as k, RouterService as l, EmberEngineInstance as m, setModifierManager as n, on as o, prefixRouteNameArg as p, extractRouteArgs as q, renderSettled as r, setupEngineRegistry as s, getActiveTargetName as t, uniqueId$1 as u, stashParamNames as v, calculateCacheKey as w, normalizeControllerQueryParams as x, resemblesURL as y, shallowEqual as z };

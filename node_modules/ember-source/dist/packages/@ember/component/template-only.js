import { templateOnlyComponent } from '../../@glimmer/runtime/index.js';

/**
  @module @ember/component/template-only
  @public
*/


/**
 * Template-only components have no backing class instance, so this in their
 * templates is null. This means that you can only reference passed in arguments
 * via named argument syntax (e.g. `{{@arg}}`):
 *
 * ```hbs
 * {{!--
 *   This does not work, since `this` does not exist
 * --}}
 * <label for="title">Title</label>
 * <Input @value={{this.value}} id="title" />
 * ```
 *
 * Additionally, the mut helper generally can't be used for the same reason:
 *
 * ```hbs
 * {{!-- This does not work --}}
 * <input
 *   value={{this.value}}
 *   onkeyup={{action (mut this.value) target="value"}}
 * />
 * ```
 *
 * Since Octane, a template-only component shares a subset of features that are
 * available in `@glimmer/component`. Such component can be seamlessly
 * "upgraded" to a Glimmer component, when you add a JavaScript file alongside
 * the template.
 */
// eslint-disable-next-line @typescript-eslint/no-empty-interface

/**
 * A convenience alias for {@link TemplateOnlyComponent}
 */

// NOTES:
//
// 1. The generic here is for a *signature: a way to hang information for tools
//    like Glint which can provide typey checking for component templates using
//    information supplied via this generic. While it may appear useless on this
//    class definition and extension, it is used by external tools and should
//    not be removed.
// 2. SAFETY: this cast is *throwing away* information that is not part of the
//    public API and replacing it with something which has the same calling
//    contract, but much less information (since we do not want to expose the
//    internal APIs like `moduleName` etc.).
// prettier-ignore
const templateOnly = templateOnlyComponent;

export { templateOnly as default };
